<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sparta - AWS Lambda Microservices</title>
    <link>/</link>
    <description>Recent content on Sparta - AWS Lambda Microservices</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 08 Mar 2016 21:07:13 +0100</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Magefiles</title>
      <link>/reference/operations/magefile/</link>
      <pubDate>Wed, 28 Nov 2018 16:17:43 +0000</pubDate>
      
      <guid>/reference/operations/magefile/</guid>
      <description>Magefile To support cross platform development and usage, Sparta uses magefiles rather than Makefiles. Most projects can start with the magefile.go sample below. The Magefiles provide a discoverable CLI, but are entirely optional. go run main.go XXXX style invocation remains available as well.
Default Sparta magefile.go This magefile.go can be used, unchanged, for most standard Sparta projects.
// +build mage // File: magefile.go package main import ( spartaMage &amp;quot;github.com/mweagle/Sparta/magefile&amp;quot; ) // Provision the service func Provision() error { return spartaMage.</description>
    </item>
    
    <item>
      <title>CloudMap Service Discovery</title>
      <link>/reference/decorators/cloudmap/</link>
      <pubDate>Mon, 27 May 2019 22:31:25 +0000</pubDate>
      
      <guid>/reference/decorators/cloudmap/</guid>
      <description></description>
    </item>
    
    <item>
      <title>CodeCommit</title>
      <link>/reference/archetypes/codecommit/</link>
      <pubDate>Thu, 31 Jan 2019 05:47:27 +0000</pubDate>
      
      <guid>/reference/archetypes/codecommit/</guid>
      <description>The CodeCommit Lambda event source allows you to trigger lambda functions in response to CodeCommit repository events.
Events Lambda functions triggered in response to CodeCommit evetms use a combination of events and branches to manage which state changes trigger your lambda function.
To create an event subscriber use a constructor as in:
// CodeCommit reactor function func reactorFunc(ctx context.Context, event awsLambdaEvents.CodeCommitEvent) (interface{}, error) { logger, _ := ctx.Value(sparta.ContextKeyRequestLogger).(*logrus.Entry) logger.WithFields(logrus.Fields{ &amp;quot;Event&amp;quot;: event, }).</description>
    </item>
    
    <item>
      <title>CodeCommit</title>
      <link>/reference/eventsources/codecommit/</link>
      <pubDate>Thu, 31 Jan 2019 05:44:32 +0000</pubDate>
      
      <guid>/reference/eventsources/codecommit/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to CodeCommit Events.
Goal Assume that we&amp;rsquo;re supposed to write a Lambda function that is triggered in response to any event emitted by a CodeCommit repository.
Getting Started Our lambda function is relatively short:
import ( awsLambdaEvents &amp;quot;github.com/aws/aws-lambda-go/events&amp;quot; ) func echoCodeCommit(ctx context.Context, event awsLambdaEvents.CodeCommitEvent) (interface{}, error) { logger, _ := ctx.Value(sparta.ContextKeyRequestLogger).(*logrus.Entry) logger.WithFields(logrus.Fields{ &amp;quot;Event&amp;quot;: event, }).Info(&amp;quot;Event received&amp;quot;) return &amp;amp;event, nil }  Our lambda function doesn&amp;rsquo;t need to do much with the repository message other than log and return it.</description>
    </item>
    
    <item>
      <title>AWS Batch</title>
      <link>/reference/step/services/batch/</link>
      <pubDate>Mon, 10 Dec 2018 21:45:23 +0000</pubDate>
      
      <guid>/reference/step/services/batch/</guid>
      <description>TODO: Document [Batch](https://docs.aws.amazon.com/step-functions/latest/dg/connectors-batch.html) integration.  </description>
    </item>
    
    <item>
      <title>AWS Fargate</title>
      <link>/reference/step/services/fargate/</link>
      <pubDate>Mon, 10 Dec 2018 21:45:23 +0000</pubDate>
      
      <guid>/reference/step/services/fargate/</guid>
      <description>TODO: Document [Fargate](https://docs.aws.amazon.com/step-functions/latest/dg/connectors-ecs.html) integration.  </description>
    </item>
    
    <item>
      <title>AWS Glue</title>
      <link>/reference/step/services/glue/</link>
      <pubDate>Mon, 10 Dec 2018 21:45:23 +0000</pubDate>
      
      <guid>/reference/step/services/glue/</guid>
      <description>TODO: Document [Glue](https://docs.aws.amazon.com/step-functions/latest/dg/connectors-glue.html) integration.  </description>
    </item>
    
    <item>
      <title>Amazon DynamoDb</title>
      <link>/reference/step/services/dynamodb/</link>
      <pubDate>Mon, 10 Dec 2018 21:45:23 +0000</pubDate>
      
      <guid>/reference/step/services/dynamodb/</guid>
      <description>TODO: Document [Dynamo](https://docs.aws.amazon.com/step-functions/latest/dg/connectors-ddb.html) integration.  </description>
    </item>
    
    <item>
      <title>Amazon SNS</title>
      <link>/reference/step/services/sns/</link>
      <pubDate>Mon, 10 Dec 2018 21:45:23 +0000</pubDate>
      
      <guid>/reference/step/services/sns/</guid>
      <description>TODO: Document [SNS](https://docs.aws.amazon.com/step-functions/latest/dg/connectors-sns.html) integration.  </description>
    </item>
    
    <item>
      <title>Amazon SQS</title>
      <link>/reference/step/services/sqs/</link>
      <pubDate>Mon, 10 Dec 2018 21:45:23 +0000</pubDate>
      
      <guid>/reference/step/services/sqs/</guid>
      <description>TODO: Document [SQS](https://docs.aws.amazon.com/step-functions/latest/dg/connectors-sqs.html) integration.  </description>
    </item>
    
    <item>
      <title>Amazon SageMaker</title>
      <link>/reference/step/services/sagemaker/</link>
      <pubDate>Mon, 10 Dec 2018 21:45:23 +0000</pubDate>
      
      <guid>/reference/step/services/sagemaker/</guid>
      <description>TODO: Document [SageMaker](https://docs.aws.amazon.com/step-functions/latest/dg/connectors-sagemaker.html) integration.  </description>
    </item>
    
    <item>
      <title>Lambda</title>
      <link>/reference/step/lambda/</link>
      <pubDate>Mon, 10 Dec 2018 21:45:23 +0000</pubDate>
      
      <guid>/reference/step/lambda/</guid>
      <description>Step Functions AWS Step Functions are a powerful way to express long-running, complex workflows comprised of Lambda functions. With Sparta 0.20.2, you can build a State Machine as part of your application. This section walks through the three steps necessary to provision a sample &amp;ldquo;Roll Die&amp;rdquo; state machine using a single Lambda function. See SpartaStep for the full source.
Lambda Functions The first step is to define the core Lambda function Task that will be our Step function&amp;rsquo;s core logic.</description>
    </item>
    
    <item>
      <title>XRayInterceptor</title>
      <link>/reference/interceptors/xray_interceptor/</link>
      <pubDate>Sat, 01 Dec 2018 06:24:24 +0000</pubDate>
      
      <guid>/reference/interceptors/xray_interceptor/</guid>
      <description>TODO: Document the [XRayInterceptor](https://godoc.org/github.com/mweagle/Sparta/interceptor#RegisterXRayInterceptor)  üéâ Sparta v1.7.0: The Time Machine Edition üï∞ üéâ For those times when you wish you could go back in time and enable debug logging for a single request.https://t.co/BP60qQpKva#serverless #go
&amp;mdash; Matt Weagle (@mweagle) November 12, 2018  Sparta v1.7.0 adds `Interceptors`: user defined hooks called during the lambda event handling flow to support cross-cutting concerns. The first interceptor is an XRay annotation and metadata interceptor.</description>
    </item>
    
    <item>
      <title>CloudWatch</title>
      <link>/reference/archetypes/cloudwatch/</link>
      <pubDate>Wed, 28 Nov 2018 20:03:46 +0000</pubDate>
      
      <guid>/reference/archetypes/cloudwatch/</guid>
      <description>The CloudWatch Logs Lambda event source allows you to trigger lambda functions in response to either cron schedules or account events. There are three different archetype functions available.
Scheduled Scheduled Lambdas execute either at fixed times or periodically depending on the schedule expression.
To create a scheduled function use a constructor as in:
import ( awsLambdaEvents &amp;quot;github.com/aws/aws-lambda-go/events&amp;quot; spartaArchetype &amp;quot;github.com/mweagle/Sparta/archetype&amp;quot; ) // CloudWatch reactor function func reactorFunc(ctx context.Context, cwLogs awsLambdaEvents.CloudwatchLogsEvent) (interface{}, error) { logger, _ := ctx.</description>
    </item>
    
    <item>
      <title>DynamoDB</title>
      <link>/reference/archetypes/dynamodb/</link>
      <pubDate>Wed, 28 Nov 2018 20:03:46 +0000</pubDate>
      
      <guid>/reference/archetypes/dynamodb/</guid>
      <description>To create a DynamoDB reactor that subscribes via an EventSourceMapping, use the NewDynamoDBReactor constructor as in:
import ( awsLambdaEvents &amp;quot;github.com/aws/aws-lambda-go/events&amp;quot; spartaArchetype &amp;quot;github.com/mweagle/Sparta/archetype&amp;quot; ) // DynamoDB reactor function func reactorFunc(ctx context.Context, dynamoEvent awsLambdaEvents.DynamoDBEvent) (interface{}, error) { logger, _ := ctx.Value(sparta.ContextKeyRequestLogger).(*logrus.Entry) logger.WithFields(logrus.Fields{ &amp;quot;Event&amp;quot;: dynamoEvent, }).Info(&amp;quot;DynamoDB Event&amp;quot;) return &amp;quot;Hello World üëã. Welcome to AWS Lambda! üôåüéâüçæ&amp;quot;, nil } func main() { // ... handler := spartaArchetype.DynamoDBReactorFunc(reactorFunc) lambdaFn, lambdaFnErr := spartaArchetype.NewDynamoDBReactor(handler, &amp;quot;DYNAMO_DB_ARN_OR_CLOUDFORMATION_REF_VALUE&amp;quot;, &amp;quot;TRIM_HORIZON&amp;quot;, 10, nil) }  </description>
    </item>
    
    <item>
      <title>Kinesis</title>
      <link>/reference/archetypes/kinesis/</link>
      <pubDate>Wed, 28 Nov 2018 20:03:46 +0000</pubDate>
      
      <guid>/reference/archetypes/kinesis/</guid>
      <description>To create a Kinesis Stream reactor that subscribes via an EventSourceMapping, use the NewKinesisReactor constructor as in:
import ( awsLambdaEvents &amp;quot;github.com/aws/aws-lambda-go/events&amp;quot; spartaArchetype &amp;quot;github.com/mweagle/Sparta/archetype&amp;quot; ) // KinesisStream reactor function func reactorFunc(ctx context.Context, kinesisEvent awsLambdaEvents.KinesisEvent) (interface{}, error) { logger, _ := ctx.Value(sparta.ContextKeyRequestLogger).(*logrus.Entry) logger.WithFields(logrus.Fields{ &amp;quot;Event&amp;quot;: kinesisEvent, }).Info(&amp;quot;Kinesis Event&amp;quot;) return &amp;quot;Hello World üëã. Welcome to AWS Lambda! üôåüéâüçæ&amp;quot;, nil } func main() { // ... handler := spartaArchetype.KinesisReactorFunc(reactorFunc) lambdaFn, lambdaFnErr := spartaArchetype.NewKinesisReactor(handler, &amp;quot;KINESIS_STREAM_ARN_OR_CLOUDFORMATION_REF_VALUE&amp;quot;, &amp;quot;TRIM_HORIZON&amp;quot;, 10, nil) }  </description>
    </item>
    
    <item>
      <title>REST Service</title>
      <link>/reference/archetypes/rest/</link>
      <pubDate>Wed, 28 Nov 2018 20:03:46 +0000</pubDate>
      
      <guid>/reference/archetypes/rest/</guid>
      <description>The rest package provides convenience functions to define a serverless REST style service.
The package uses three concepts:
 Routes: URL paths that resolve to a single go struct Resources: go structs that optionally define HTTP method (GET, POST, etc.). ResourceDefinition: an interface that go structs must implement in order to support resource-based registration.  Routes Routes are similar many HTTP-routing libraries. They support path parameters.
Resources Resources are the targets of Routes.</description>
    </item>
    
    <item>
      <title>S3</title>
      <link>/reference/archetypes/s3/</link>
      <pubDate>Wed, 28 Nov 2018 20:03:46 +0000</pubDate>
      
      <guid>/reference/archetypes/s3/</guid>
      <description>There are two different S3-based constructors depending on whether your lambda function should use an Object Key Name filter. The S3 subscriber is preconfigured to be notified of both s3:ObjectCreated:* and s3:ObjectRemoved:* events.
Object Key Name Filtering Object key name filtering only invokes a lambda function when objects with the given prefix are created.
To subscribe to object events created by objects with a given prefix, use the NewS3ScopedReactor constructor as in:</description>
    </item>
    
    <item>
      <title>SNS</title>
      <link>/reference/archetypes/sns/</link>
      <pubDate>Wed, 28 Nov 2018 20:03:46 +0000</pubDate>
      
      <guid>/reference/archetypes/sns/</guid>
      <description>To create a SNS reactor that subscribes via an subscription configuration, use the NewSNSReactor constructor as in:
import ( awsLambdaEvents &amp;quot;github.com/aws/aws-lambda-go/events&amp;quot; spartaArchetype &amp;quot;github.com/mweagle/Sparta/archetype&amp;quot; ) // DynamoDB reactor function func reactorFunc(ctx context.Context, snsEvent awsLambdaEvents.SNSEvent) (interface{}, error) { logger, _ := ctx.Value(sparta.ContextKeyRequestLogger).(*logrus.Entry) logger.WithFields(logrus.Fields{ &amp;quot;Event&amp;quot;: snsEvent, }).Info(&amp;quot;SNS Event&amp;quot;) return &amp;quot;Hello World üëã. Welcome to AWS Lambda! üôåüéâüçæ&amp;quot;, nil } func main() { // ... handler := spartaArchetype.SNSReactorFunc(reactorFunc) lambdaFn, lambdaFnErr := spartaArchetype.NewDynamoDBReactor(handler, &amp;quot;SNS_ARN_OR_CLOUDFORMATION_REF_VALUE&amp;quot;, nil) }  </description>
    </item>
    
    <item>
      <title>CloudFront Distribution</title>
      <link>/reference/decorators/cloudfront_distribution/</link>
      <pubDate>Mon, 22 Jan 2018 21:49:38 +0000</pubDate>
      
      <guid>/reference/decorators/cloudfront_distribution/</guid>
      <description>The CloudFrontDistributionDecorator associates a CloudFront Distribution with your S3-backed website. It is implemented as a ServiceDecoratorHookHandler as a single service can only provision one CloudFront distribution.
Sample usage:
//////////////////////////////////////////////////////////////////////////////// // CloudFront settings const subdomain = &amp;quot;mySiteSubdomain&amp;quot; // The domain managed by Route53. const domainName = &amp;quot;myRoute53ManagedDomain.net&amp;quot; // The site will be available at // https://mySiteSubdomain.myRoute53ManagedDomain.net // The S3 bucketname must match the subdomain.domain // name pattern to serve as a CloudFront Distribution target var bucketName = fmt.</description>
    </item>
    
    <item>
      <title>CloudWatch Alarms</title>
      <link>/reference/operations/cloudwatch_alarms/</link>
      <pubDate>Mon, 22 Jan 2018 21:49:38 +0000</pubDate>
      
      <guid>/reference/operations/cloudwatch_alarms/</guid>
      <description>The CloudWatchErrorAlarmDecorator associates a CloudWatch alarm and destination with your Lambda function.
Sample usage:
lambdaFn, _ := sparta.NewAWSLambda(&amp;quot;Hello World&amp;quot;, helloWorld, sparta.IAMRoleDefinition{}) lambdaFn.Decorators = []sparta.TemplateDecoratorHandler{ spartaDecorators.CloudWatchErrorAlarmDecorator(1, 1, 1, gocf.String(&amp;quot;MY_SNS_ARN&amp;quot;)), }  </description>
    </item>
    
    <item>
      <title>CloudWatch Dashboard</title>
      <link>/reference/operations/cloudwatch_dashboard/</link>
      <pubDate>Mon, 22 Jan 2018 21:49:38 +0000</pubDate>
      
      <guid>/reference/operations/cloudwatch_dashboard/</guid>
      <description>The DashboardDecorator creates a CloudWatch Dashboard that produces a single CloudWatch Dashboard to summarize your stack&amp;rsquo;s behavior.
Sample usage:
func workflowHooks(connections *service.Connections, lambdaFunctions []*sparta.LambdaAWSInfo, websiteURL *gocf.StringExpr) *sparta.WorkflowHooks { // Setup the DashboardDecorator lambda hook workflowHooks := &amp;amp;sparta.WorkflowHooks{ ServiceDecorators: []sparta.ServiceDecoratorHookHandler{ spartaDecorators.DashboardDecorator(lambdaFunctions, 60), serviceResourceDecorator(connections, websiteURL), }, } return workflowHooks }  A sample dashboard for the SpartaGeekwire project is:
Related to this, see the recently announced AWS Lambda Application Dashboard.</description>
    </item>
    
    <item>
      <title>CodeDeploy Service Update</title>
      <link>/reference/operations/codedeploy_service_update/</link>
      <pubDate>Mon, 22 Jan 2018 21:49:38 +0000</pubDate>
      
      <guid>/reference/operations/codedeploy_service_update/</guid>
      <description>TODO: Document the [CodeDeployServiceUpdateDecorator](https://godoc.org/github.com/mweagle/Sparta/decorator#CodeDeployServiceUpdateDecorator) decorator. See also the [Deployment Strategy](/reference/operations/deployment_strategies.md) page.  </description>
    </item>
    
    <item>
      <title>Lambda Versioning Decorator</title>
      <link>/reference/decorators/lambda_versioning/</link>
      <pubDate>Mon, 22 Jan 2018 21:49:38 +0000</pubDate>
      
      <guid>/reference/decorators/lambda_versioning/</guid>
      <description>TODO: [LambdaVersioningDecorator](https://godoc.org/github.com/mweagle/Sparta/decorator#LambdaVersioningDecorator)  </description>
    </item>
    
    <item>
      <title>Publishing Outputs</title>
      <link>/reference/decorators/publish_outputs/</link>
      <pubDate>Mon, 22 Jan 2018 21:49:38 +0000</pubDate>
      
      <guid>/reference/decorators/publish_outputs/</guid>
      <description>CloudFormation stack outputs can be used to advertise information about a service.
Sparta provides different publishing output decorators depending on the type of CloudFormation resource output:
 Ref: PublishRefOutputDecorator Fn::Att: PublishAttOutputDecorator  Publishing Resource Ref Values For example, to publish the dynamically lambda resource name for a given AWS Lambda function, use PublishRefOutputDecorator such as:
lambdaFunctionName := &amp;quot;Hello World&amp;quot; lambdaFn, _ := sparta.NewAWSLambda(lambdaFunctionName, helloWorld, sparta.IAMRoleDefinition{}) lambdaFn.Decorators = append(lambdaFn.Decorators, spartaDecorators.PublishRefOutputDecorator(fmt.Sprintf(&amp;quot;%s FunctionName&amp;quot;, lambdaFunctionName), fmt.</description>
    </item>
    
    <item>
      <title>S3 Artifact Publisher</title>
      <link>/reference/decorators/s3_artifact_publisher/</link>
      <pubDate>Mon, 22 Jan 2018 21:49:38 +0000</pubDate>
      
      <guid>/reference/decorators/s3_artifact_publisher/</guid>
      <description>The S3ArtifactPublisherDecorator enables a service to publish objects to S3 locations as part of the service lifecycle.
This decorator is implemented as a ServiceDecoratorHookHandler which is supplied to MainEx. For example:
hooks := &amp;amp;sparta.WorkflowHooks{} payloadData := map[string]interface{}{ &amp;quot;SomeValue&amp;quot;: gocf.Ref(&amp;quot;AWS::StackName&amp;quot;), } serviceHook := spartaDecorators.S3ArtifactPublisherDecorator(gocf.String(&amp;quot;MY-S3-BUCKETNAME&amp;quot;), gocf.Join(&amp;quot;&amp;quot;, gocf.String(&amp;quot;metadata/&amp;quot;), gocf.Ref(&amp;quot;AWS::StackName&amp;quot;), gocf.String(&amp;quot;.json&amp;quot;)), payloadData) hooks.ServiceDecorators = []sparta.ServiceDecoratorHookHandler{serviceHook}  </description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>/example_service/step1/</link>
      <pubDate>Tue, 03 Oct 2017 07:15:40 +0000</pubDate>
      
      <guid>/example_service/step1/</guid>
      <description>Sparta is a framework for developing and deploying go based AWS Lambda-backed microservices. To help understand what that means we&amp;rsquo;ll begin with a &amp;ldquo;Hello World&amp;rdquo; lambda function and eventually deploy that to AWS. Note that we&amp;rsquo;re not going to handle all error cases to keep the example code to a minimum.
Please be aware that running Lambda functions may incur [costs](https://aws.amazon.com/lambda/pricing&#34;). Be sure to decommission Sparta stacks after you are finished using them (via the `delete` command line option) to avoid unwanted charges.</description>
    </item>
    
    <item>
      <title>CI/CD</title>
      <link>/reference/operations/cicd/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/operations/cicd/</guid>
      <description>TODO: Document the [SpartaCodePipeline](https://github.com/mweagle/SpartaCodePipeline) example. Also see the [Medium Post](https://medium.com/@mweagle/serverless-serverfull-and-weaving-pipelines-c9f83eec9227)  </description>
    </item>
    
    <item>
      <title>CloudFormation</title>
      <link>/reference/eventsources/cloudformation/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/cloudformation/</guid>
      <description>TODO: CloudFormation source documentation  </description>
    </item>
    
    <item>
      <title>CloudWatch Events</title>
      <link>/reference/eventsources/cloudwatchevents/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/cloudwatchevents/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to different types of CloudWatch Events. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume that we&amp;rsquo;re supposed to write a simple &amp;ldquo;HelloWorld&amp;rdquo; CloudWatch event function that has two requirements:
 Run every 5 minutes to provide a heartbeat notification to our alerting system via a logfile entry Log EC2-related events for later processing  Getting Started The lambda function is relatively small:</description>
    </item>
    
    <item>
      <title>CloudWatch Logs</title>
      <link>/reference/eventsources/cloudwatchlogs/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/cloudwatchlogs/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to CloudWatch Logs. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume that we&amp;rsquo;re supposed to write a simple &amp;ldquo;HelloWorld&amp;rdquo; CloudWatch Logs function that should be triggered in response to any log message issued to a specific Log Group.
Getting Started Our lambda function is relatively short:</description>
    </item>
    
    <item>
      <title>Cognito</title>
      <link>/reference/eventsources/cognito/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/cognito/</guid>
      <description>TODO: Cognito source documentation  </description>
    </item>
    
    <item>
      <title>Custom Commands</title>
      <link>/reference/application/custom_commands/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/application/custom_commands/</guid>
      <description>In addition to custom flags, an application may register completely new commands. For example, to support alternative topologies or integrated automated acceptance tests as part of a CI/CD pipeline.
To register a custom command, define a new cobra.Command and add it to the sparta.CommandLineOptions.Root command value. Ensure you use the xxxxE Cobra functions so that errors can be properly propagated.
httpServerCommand := &amp;amp;cobra.Command{ Use: &amp;quot;httpServer&amp;quot;, Short: &amp;quot;Sample HelloWorld HTTP server&amp;quot;, Long: `Sample HelloWorld HTTP server that binds to port: ` + HTTPServerPort, RunE: func(cmd *cobra.</description>
    </item>
    
    <item>
      <title>Custom Flags</title>
      <link>/reference/application/custom_flags/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/application/custom_flags/</guid>
      <description>Some commands (eg: provision) may require additional options. For instance, your application&amp;rsquo;s provision logic may require VPC subnets or EC2 SSH Key Names.
The default Sparta command line option flags may be extended and validated by building on the exposed Cobra command objects.
Adding Flags To add a flag, use one of the pflag functions to register your custom flag with one of the standard CommandLineOption values.
For example:</description>
    </item>
    
    <item>
      <title>DynamoDB</title>
      <link>/reference/eventsources/dynamodb/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/dynamodb/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to DynamoDB stream events. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume that we&amp;rsquo;re given a DynamoDB stream. See below for details on how to create the stream. We&amp;rsquo;ve been asked to write a lambda function that logs when operations are performed to the table so that we can perform offline analysis.</description>
    </item>
    
    <item>
      <title>Echo</title>
      <link>/reference/apigateway/echo_event/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/echo_event/</guid>
      <description>To start, we&amp;rsquo;ll create a HTTPS accessible lambda function that simply echoes back the contents of incoming API Gateway Lambda event. The source for this is the SpartaHTML.
For reference, the helloWorld function is below.
import ( awsLambdaEvents &amp;quot;github.com/aws/aws-lambda-go/events&amp;quot; spartaAPIGateway &amp;quot;github.com/mweagle/Sparta/aws/apigateway&amp;quot; ) func helloWorld(ctx context.Context, gatewayEvent spartaAWSEvents.APIGatewayRequest) (*spartaAPIGateway.Response, error) { logger, loggerOk := ctx.Value(sparta.ContextKeyLogger).(*logrus.Logger) if loggerOk { logger.Info(&amp;quot;Hello world structured log message&amp;quot;) } // Return a message, together with the incoming input.</description>
    </item>
    
    <item>
      <title>Kinesis</title>
      <link>/reference/eventsources/kinesis/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/kinesis/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to Amazon Kinesis streams. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal The goal of this example is to provision a Sparta lambda function that logs Amazon Kinesis events to CloudWatch logs.
Getting Started We&amp;rsquo;ll start with an empty lambda function and build up the needed functionality.</description>
    </item>
    
    <item>
      <title>Managing Environments</title>
      <link>/reference/application/environments/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/application/environments/</guid>
      <description>It&amp;rsquo;s common for a single Sparta application to target multiple environments. For example:
 Development Staging Production  Each environment is largely similar, but the application may need slightly different configuration in each context.
To support this, Sparta uses Go&amp;rsquo;s conditional compilation support to ensure that configuration information is validated at build time. Conditional compilation is supported via the --tags/-t command line argument.
This example will work through the SpartaConfig sample.</description>
    </item>
    
    <item>
      <title>S3</title>
      <link>/reference/eventsources/s3/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/s3/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to S3 events. This overview is based on the SpartaImager sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume we have an S3 bucket that stores images. You&amp;rsquo;ve been asked to write a service that creates a duplicate image that includes a characteristic stamp overlay and store it in the same S3 bucket.</description>
    </item>
    
    <item>
      <title>SES</title>
      <link>/reference/eventsources/ses/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/ses/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to inbound email. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume that we have already verified our email domain with AWS. This allows our domain&amp;rsquo;s email to be handled by SES.
We&amp;rsquo;ve been asked to write a lambda function that logs inbound messages, including the metadata associated with the message body itself.</description>
    </item>
    
    <item>
      <title>SNS</title>
      <link>/reference/eventsources/sns/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/sns/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to SNS events. This overview is based on the SpartaApplication sample code if you&amp;rsquo;d rather jump to the end result.
Goal Assume that we have an SNS topic that broadcasts notifications. We&amp;rsquo;ve been asked to write a lambda function that logs the Subject and Message text to CloudWatch logs for later processing.
Getting Started We&amp;rsquo;ll start with an empty lambda function and build up the needed functionality.</description>
    </item>
    
    <item>
      <title>SQS</title>
      <link>/reference/eventsources/sqs/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/eventsources/sqs/</guid>
      <description>In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to AWS Simple Queue Service (SQS) events. This overview is based on the SpartaSQS sample code if you&amp;rsquo;d rather jump to the end result.
Goal The goal here is to create a self-contained service that provisions a SQS queue, an AWS Lambda function that processes messages posted to the queue
Getting Started We&amp;rsquo;ll start with an empty lambda function and build up the needed functionality.</description>
    </item>
    
    <item>
      <title>Request Parameters</title>
      <link>/reference/apigateway/request_params/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/request_params/</guid>
      <description>Request Parameters This example demonstrates how to accept client request params supplied as HTTP query params and return an expiring S3 URL to access content. The source for this is the s3ItemInfo function defined as part of the SpartaApplication.
Lambda Definition Our function will accept two params:
 bucketName : The S3 bucket name storing the asset keyName : The S3 item key  Those params will be passed as part of the URL query string.</description>
    </item>
    
    <item>
      <title>Request Context</title>
      <link>/reference/apigateway/context/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/context/</guid>
      <description>This example demonstrates how to use the Context struct provided as part of the APIGatewayRequest. The SpartaGeoIP service will return Geo information based on the inbound request&amp;rsquo;s IP address.
Lambda Definition Our function will examine the inbound request, lookup the user&amp;rsquo;s IP address in the GeoLite2 Database and return any information to the client.
As this function is only expected to be invoked from the API Gateway, we&amp;rsquo;ll unmarshall the inbound event:</description>
    </item>
    
    <item>
      <title>Fargate</title>
      <link>/reference/step/fargate/</link>
      <pubDate>Sun, 16 Dec 2018 07:02:28 +0000</pubDate>
      
      <guid>/reference/step/fargate/</guid>
      <description>Teaching people to do serverless is hard. It&amp;#39;s far less about teaching someone about FaaS and far more about getting people into the right mindset. It is not about technology, or at least, it&amp;#39;s not about doing technology
&amp;mdash; Paul Johnston (@PaulDJohnston) December 13, 2018  While Serverless and FaaS are often used interchangeably, there are types of workloads that are more challenging to move to FaaS. Perhaps due to third party libraries, latency, or storage requirements, the FaaS model isn&amp;rsquo;t an ideal fit.</description>
    </item>
    
    <item>
      <title>CORS</title>
      <link>/reference/apigateway/cors/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/cors/</guid>
      <description>Cross Origin Resource Sharing defines a protocol by which resources on different domains may establish whether cross site operations are permissible.
Sparta makes CORS support a single CORSEnabled field of the API struct:
// Register the function with the API Gateway apiStage := sparta.NewStage(&amp;quot;v1&amp;quot;) apiGateway := sparta.NewAPIGateway(&amp;quot;SpartaHTML&amp;quot;, apiStage) // Enable CORS s.t. the S3 site can access the resources apiGateway.CORSEnabled = true  Setting the boolean to true will add the necessary OPTIONS and mock responses to all resources exposed by your API.</description>
    </item>
    
    <item>
      <title>Deployment Strategies</title>
      <link>/reference/operations/deployment_strategies/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/operations/deployment_strategies/</guid>
      <description>Document the [SpartaSafeDeploy](https://github.com/mweagle/SpartaSafeDeploy) example.  </description>
    </item>
    
    <item>
      <title>Details</title>
      <link>/example_service/step2/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/example_service/step2/</guid>
      <description>The Overview walked through a simple &amp;ldquo;Hello World&amp;rdquo; example. In this section we&amp;rsquo;ll cover how Sparta works in preparation for moving on to more advanced use. Most development will use the provision command line argument, so this section will outline exactly what that entails.
Provisioning Flow The provisioning workflow is defined in provision.go, with a goal of marshalling all AWS operations into a CloudFormation template. Where CloudFormation does not support a given service, Sparta falls back to using Lambda-backed Custom Resources in the template definition.</description>
    </item>
    
    <item>
      <title>Slack SlashCommand</title>
      <link>/reference/apigateway/slack/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/slack/</guid>
      <description>In this example, we&amp;rsquo;ll walk through creating a Slack Slash Command service. The source for this is the SpartaSlackbot repo.
Our initial command handler won&amp;rsquo;t be very sophisticated, but will show the steps necessary to provision and configure a Sparta AWS Gateway-enabled Lambda function.
Define the Lambda Function This lambda handler is a bit more complicated than the other examples, primarily because of the Slack Integration requirements. The full source is:</description>
    </item>
    
    <item>
      <title>Metrics Publisher</title>
      <link>/reference/operations/metrics_publisher/</link>
      <pubDate>Sat, 01 Dec 2018 06:02:32 +0000</pubDate>
      
      <guid>/reference/operations/metrics_publisher/</guid>
      <description>AWS Lambda is tightly integrated with other AWS services and provides excellent opportunities for improving your service&amp;rsquo;s observability posture. Sparta includes a CloudWatch Metrics publisher that periodically publishes metrics to CloudWatch.
This periodic task publishes environment-level metrics that have been detected by the gopsutil package. Metrics include:
 CPU  Percent used  Disk  Percent used  Host  Uptime (milliseconds)  Load  Load1 (no units) Load5 (no units) Load15 (no units)  Network  NetBytesSent (bytes) NetBytesRecv (bytes) NetErrin (count) NetErrout (count)   You can provide an optional map[string]string set of dimensions to which the metrics should be published.</description>
    </item>
    
    <item>
      <title>Profiling</title>
      <link>/reference/operations/profiling/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/operations/profiling/</guid>
      <description>One of Lambda&amp;rsquo;s biggest strengths, its ability to automatically scale across ephemeral containers in response to increased load, also creates one of its biggest problems: observability. The traditional set of tools used to identify performance bottlenecks are no longer valid, as there is no host into which one can SSH and interactively interrogate. Identifying performance bottlenecks is even more significant due to the Lambda pricing model, where idle time often directly translates into increased costs.</description>
    </item>
    
    <item>
      <title>CloudFormation Resources</title>
      <link>/reference/application/custom_lambda_resources/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/application/custom_lambda_resources/</guid>
      <description>In addition to per-lambda custom resources, a service may benefit from the ability to include a service-scoped Lambda backed CustomResource.
Including a custom service scoped resource is a multi-step process. The code excerpts below are from the SpartaCustomResource sample application.
1. Resource Type The first step is to define a custom CloudFormation Resource Type
//////////////////////////////////////////////////////////////////////////////// // 1 - Define the custom type const spartaHelloWorldResourceType = &amp;quot;Custom::sparta::HelloWorldResource&amp;quot;  2. Request Parameters The next step is to define the parameters that are supplied to the custom resource invocation.</description>
    </item>
    
    <item>
      <title>Custom Resources</title>
      <link>/reference/application/custom_resources/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/application/custom_resources/</guid>
      <description>In some circumstances your service may need to provision or access resources that fall outside the standard workflow. In this case you can use CloudFormation Lambda-backed CustomResources to create or access resources during your CloudFormation stack&amp;rsquo;s lifecycle.
Sparta provides unchecked access to the CloudFormation resource lifecycle via the RequireCustomResource function. This function registers an AWS Lambda Function as an CloudFormation custom resource lifecycle.
In this section we&amp;rsquo;ll walk through a sample user-defined custom resource and discuss how a custom resource&amp;rsquo;s outputs can be propagated to an application-level Sparta lambda function.</description>
    </item>
    
    <item>
      <title>Discovery Service</title>
      <link>/reference/discovery/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/discovery/</guid>
      <description>The ability to provision dynamic infrastructure (see also the SES Event Source Example) as part of a Sparta application creates a need to discover those resources at lambda execution time.
Sparta exposes this functionality via sparta.Discover. This function returns information about the current stack (eg, name, region, ID) as well as metadata about the immediate dependencies of the calling go lambda function.
The following sections walk through provisioning a S3 bucket, declaring an explicit dependency on that resource, and then discovering the resource at lambda execution time.</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>/reference/docker/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/docker/</guid>
      <description>TODO  Docker Support Document the SpartaDocker project.</description>
    </item>
    
    <item>
      <title>Hybrid Topologies</title>
      <link>/reference/hybrid_topologies/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/hybrid_topologies/</guid>
      <description>At a broad level, AWS Lambda represents a new level of compute abstraction for services. Developers don&amp;rsquo;t immediately concern themselves with HA topologies, configuration management, capacity planning, or many of the other areas traditionally handled by operations. These are handled by the vendor supplied execution environment.
However, Lambda is a relatively new technology and is not ideally suited to certain types of tasks. For example, given the current Lambda limits, the following task types might better be handled by &amp;ldquo;legacy&amp;rdquo; AWS services:</description>
    </item>
    
    <item>
      <title>S3 Sites with CORS</title>
      <link>/reference/apigateway/s3site/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/apigateway/s3site/</guid>
      <description>Sparta supports provisioning an S3-backed static website as part of provisioning. We&amp;rsquo;ll walk through provisioning a minimal Bootstrap website that accesses API Gateway lambda functions provisioned by a single service in this example.
The source for this is the SpartaHTML example application.
Lambda Definition We&amp;rsquo;ll start by creating a very simple lambda function:
import ( spartaAPIGateway &amp;quot;github.com/mweagle/Sparta/aws/apigateway&amp;quot; spartaAWSEvents &amp;quot;github.com/mweagle/Sparta/aws/events&amp;quot; ) type helloWorldResponse struct { Message string Request spartaAWSEvents.APIGatewayRequest } //////////////////////////////////////////////////////////////////////////////// // Hello world event handler func helloWorld(ctx context.</description>
    </item>
    
    <item>
      <title>Dynamic Infrastructure</title>
      <link>/reference/decorators/dynamic_infrastructure/</link>
      <pubDate>Sat, 01 Dec 2018 06:28:42 +0000</pubDate>
      
      <guid>/reference/decorators/dynamic_infrastructure/</guid>
      <description>In addition to provisioning AWS Lambda functions, Sparta supports the creation of other CloudFormation Resources. This enables a service to move towards immutable infrastructure, where the service and its infrastructure requirements are treated as a logical unit.
For instance, consider the case where two developers are working in the same AWS account.
 Developer 1 is working on analyzing text documents.  Their lambda code is triggered in response to uploading sample text documents to S3.</description>
    </item>
    
    <item>
      <title>Testing</title>
      <link>/reference/testing/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/testing/</guid>
      <description>While developing Sparta lambda functions it may be useful to test them locally without needing to provision each new code change. You can test your lambda functions using standard go test functionality.
To create proper event types, consider:
 AWS Lambda Go types Sparta types Use NewAPIGatewayMockRequest to generate API Gateway style requests.  </description>
    </item>
    
    <item>
      <title>Supporting Packages</title>
      <link>/reference/supporting_packages/</link>
      <pubDate>Mon, 22 Jan 2018 21:49:38 +0000</pubDate>
      
      <guid>/reference/supporting_packages/</guid>
      <description>The following packages are part of the Sparta ecosystem and can be used in combination or as standalone in other applications.
go-cloudcondensor The go-cloudcondensor package provides utilities to express CloudFormation templates as a set of go functions. Templates are evaluated and the and the resulting JSON can be integrated into existing CLI-based workflows.
go-cloudformation The go-cloudformation package provides a Go object model for the official CloudFormation JSON Schema.
SpartaVault SpartaVault uses KMS to encrypt values into Go types that can be safely committed to source control.</description>
    </item>
    
    <item>
      <title>Limitations</title>
      <link>/reference/limitations/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/limitations/</guid>
      <description> AWS Lambda Limitations  Lambda is not yet globally available. Please view the Global Infrastructure page for the latest deployment status. There are Lambda Limits that may affect your development It&amp;rsquo;s not possible to dynamically set HTTP response headers based on the Lambda response body:  https://forums.aws.amazon.com/thread.jspa?threadID=203889 https://forums.aws.amazon.com/thread.jspa?threadID=210826  Similarly, it&amp;rsquo;s not possible to set proper error response bodies.  </description>
    </item>
    
    <item>
      <title>FAQ</title>
      <link>/reference/faq/</link>
      <pubDate>Wed, 09 Mar 2016 19:56:50 +0100</pubDate>
      
      <guid>/reference/faq/</guid>
      <description>CloudFormation How do I create dynamic resource ARNs? Linking AWS resources together often requires creating dynamic ARN references. This can be achieved by using cloudformation.Join expressions.
For instance:
import ( gocf &amp;quot;github.com/mweagle/go-cloudformation&amp;quot; ) s3SiteBucketAllKeysResourceValue := gocf.Join(&amp;quot;&amp;quot;, gocf.String(&amp;quot;arn:aws:s3:::&amp;quot;), gocf.Ref(s3BucketResourceName), gocf.String(&amp;quot;/*&amp;quot;))  import ( gocf &amp;quot;github.com/mweagle/go-cloudformation&amp;quot; ) AuthorizerURI: gocf.Join(&amp;quot;&amp;quot;, gocf.String(&amp;quot;arn:aws:apigateway:&amp;quot;), gocf.Ref(&amp;quot;AWS::Region&amp;quot;).String(), gocf.String(&amp;quot;:lambda:path/2015-03-31/functions/&amp;quot;), gocf.GetAtt(myAWSLambdaInfo.LogicalResourceName(), &amp;quot;Arn&amp;quot;), gocf.String(&amp;quot;/invocations&amp;quot;)),  See the CloudFormation Fn::GetAtt docs for the set of attributes created by each resource. CloudFormation pseudo-parameters can be included in dynamic expresssions via gocf.</description>
    </item>
    
    <item>
      <title></title>
      <link>/_footer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/_footer/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>/_header/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/_header/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>