<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docs on Sparta</title>
    <link>http://gosparta.io/docs/</link>
    <description>Recent content in Docs on Sparta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>mweagle@gmail.com (Matt Weagle)</managingEditor>
    <webMaster>mweagle@gmail.com (Matt Weagle)</webMaster>
    <lastBuildDate>Tue, 16 Feb 2016 06:40:36 +0000</lastBuildDate>
    <atom:link href="http://gosparta.io/docs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Event Source - CloudWatch Logs</title>
      <link>http://gosparta.io/docs/eventsources/cloudwatchlogs/</link>
      <pubDate>Tue, 16 Feb 2016 06:40:36 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/cloudwatchlogs/</guid>
      <description>

&lt;p&gt;In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to  &lt;a href=&#34;https://aws.amazon.com/blogs/aws/new-cloudwatch-events-track-and-respond-to-changes-to-your-aws-resources/&#34;&gt;CloudWatch Logs&lt;/a&gt;.  This overview is based on the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication&#34;&gt;SpartaApplication&lt;/a&gt; sample code if you&amp;rsquo;d rather jump to the end result.&lt;/p&gt;

&lt;h1 id=&#34;goal:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Goal&lt;/h1&gt;

&lt;p&gt;Assume that we&amp;rsquo;re supposed to write a simple &amp;ldquo;HelloWorld&amp;rdquo; CloudWatch Logs function that should be triggered in response to any log message issued to a specific Log Group.&lt;/p&gt;

&lt;h1 id=&#34;getting-started:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Getting Started&lt;/h1&gt;

&lt;p&gt;Our lambda function is relatively short:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func echoCloudWatchLogsEvent(event *json.RawMessage,
                        context *sparta.LambdaContext,
                        w http.ResponseWriter,
                        logger *logrus.Logger) {

  // Note that we&amp;#39;re not going to log in this lambda function, as
  // we don&amp;#39;t want to self DDOS
  fmt.Fprintf(w, &amp;#34;Hello World!&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our lambda function doesn&amp;rsquo;t need to do much with the log message other than log it.&lt;/p&gt;

&lt;h1 id=&#34;sparta-integration:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Sparta Integration&lt;/h1&gt;

&lt;p&gt;With &lt;code&gt;echoCloudWatchLogsEvent()&lt;/code&gt; implemented, the next step is to integrate the &lt;strong&gt;Go&lt;/strong&gt; function with Sparta.  This is done by the &lt;code&gt;appendCloudWatchLogsLambda&lt;/code&gt; in the SpartaApplication &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go&#34;&gt;application.go&lt;/a&gt; source.&lt;/p&gt;

&lt;p&gt;Our lambda function only needs logfile write privileges, and since these are enabled by default, we can use an empty &lt;code&gt;sparta.IAMRoleDefinition&lt;/code&gt; value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func appendCloudWatchLogsLambda(api *sparta.API,
	lambdaFunctions []*sparta.LambdaAWSInfo) []*sparta.LambdaAWSInfo {
	lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoCloudWatchLogsEvent, nil)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The next step is to add a &lt;code&gt;CloudWatchLogsSubscriptionFilter&lt;/code&gt; value that represents the &lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/Subscriptions.html#LambdaFunctionExample&#34;&gt;CloudWatch Lambda&lt;/a&gt; subscription &lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CreateSubscriptionFilter.html&#34;&gt;filter information&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;cloudWatchLogsPermission := sparta.CloudWatchLogsPermission{}
cloudWatchLogsPermission.Filters = make(map[string]sparta.CloudWatchLogsSubscriptionFilter, 1)
cloudWatchLogsPermission.Filters[&amp;#34;MyFilter&amp;#34;] = sparta.CloudWatchLogsSubscriptionFilter{
  LogGroupName: &amp;#34;/aws/lambda/versions&amp;#34;,
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;sparta.CloudWatchLogsPermission&lt;/code&gt; struct provides fields for both the LogGroupName and optional Filter expression (not shown here) to use when calling &lt;a href=&#34;http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CloudWatchLogs.html#putSubscriptionFilter-property&#34;&gt;putSubscriptionFilter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;# Add Permission&lt;/p&gt;

&lt;p&gt;With the subscription information configured, the final step is to add the &lt;code&gt;sparta.CloudWatchLogsPermission&lt;/code&gt; to our &lt;code&gt;sparta.LambdaAWSInfo&lt;/code&gt; value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn.Permissions = append(lambdaFn.Permissions, cloudWatchLogsPermission)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our entire function is therefore:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func appendCloudWatchLogsLambda(api *sparta.API,
	lambdaFunctions []*sparta.LambdaAWSInfo) []*sparta.LambdaAWSInfo {

	lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoCloudWatchLogsEvent, nil)

	cloudWatchLogsPermission := sparta.CloudWatchLogsPermission{}
	cloudWatchLogsPermission.Filters = make(map[string]sparta.CloudWatchLogsSubscriptionFilter, 1)
	cloudWatchLogsPermission.Filters[&amp;#34;MyFilter&amp;#34;] = sparta.CloudWatchLogsSubscriptionFilter{
		LogGroupName: &amp;#34;/aws/lambda/versions&amp;#34;,
	}
	lambdaFn.Permissions = append(lambdaFn.Permissions, cloudWatchLogsPermission)
	return append(lambdaFunctions, lambdaFn)
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;wrapping-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;With the &lt;code&gt;lambdaFn&lt;/code&gt; fully defined, we can provide it to &lt;code&gt;sparta.Main()&lt;/code&gt; and deploy our service.  The workflow below is shared by all CloudWatch Logs-triggered lambda functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define the lambda function (&lt;code&gt;echoCloudWatchLogsEvent&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If needed, create the required &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta*IAMRoleDefinition&#34;&gt;IAMRoleDefinition&lt;/a&gt; with appropriate privileges.&lt;/li&gt;
&lt;li&gt;Provide the lambda function &amp;amp; IAMRoleDefinition to &lt;code&gt;sparta.NewLambda()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Create a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudWatchLogsPermission&#34;&gt;CloudWatchLogsPermission&lt;/a&gt; value.&lt;/li&gt;
&lt;li&gt;Add one or more &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudWatchLogsSubscriptionFilter&#34;&gt;CloudWatchLogsSubscriptionFilter&lt;/a&gt; to the &lt;code&gt;CloudWatchLogsPermission.Filters&lt;/code&gt; map that defines your lambda function&amp;rsquo;s logfile subscription information.&lt;/li&gt;
&lt;li&gt;Append the &lt;code&gt;CloudWatchLogsPermission&lt;/code&gt; value to the lambda function&amp;rsquo;s &lt;code&gt;Permissions&lt;/code&gt; slice.&lt;/li&gt;
&lt;li&gt;Include the reference in the call to &lt;code&gt;sparta.Main()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;other-resources:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Other Resources&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Event Sources - Overview</title>
      <link>http://gosparta.io/docs/eventsources/</link>
      <pubDate>Tue, 16 Feb 2016 05:36:20 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/</guid>
      <description>&lt;p&gt;The true power of the AWS Lambda architecture is the ability to integrate Lambda execution with other AWS service state transitions.  Depending on the service type, state change events are either pushed or transparently polled and used as the input to a Lambda execution.&lt;/p&gt;

&lt;p&gt;There are several &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/intro-core-components.html&#34;&gt;event sources&lt;/a&gt; available.  They are grouped into Pull and Push types.  Pull based models use &lt;code&gt;sparta.EventSourceMapping&lt;/code&gt; values, as the trigger configuration is stored in the AWS Lambda service.  Push based types use service specific &lt;code&gt;sparta.*Permission&lt;/code&gt; types to denote the fact that the trigger logic is configured in the remote service.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pull Based

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/dynamodb&#34;&gt;DynamoDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/kinesis&#34;&gt;Kinesis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Pushed Based

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/cloudformation&#34;&gt;CloudFormation&lt;/a&gt; &lt;span class=&#34;label label-warning&#34;&gt;NOT YET IMPLEMENTED&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/cloudwatchevents&#34;&gt;CloudWatch Events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/cloudwatchlogs&#34;&gt;CloudWatch Logs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/cognito&#34;&gt;Cognito&lt;/a&gt; &lt;span class=&#34;label label-warning&#34;&gt;NOT YET IMPLEMENTED&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/s3&#34;&gt;S3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/ses&#34;&gt;SES&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/sns&#34;&gt;SNS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>http://gosparta.io/docs/</link>
      <pubDate>Tue, 16 Feb 2016 05:36:20 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/</guid>
      <description>

&lt;p&gt;This is a brief overview of Sparta&amp;rsquo;s core concepts.  Additional information regarding specific features is available from the menu.&lt;/p&gt;

&lt;h1 id=&#34;terms-and-concepts:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Terms and Concepts&lt;/h1&gt;

&lt;p&gt;At a high level, Sparta transforms a single &lt;strong&gt;Go&lt;/strong&gt; binary&amp;rsquo;s registered lambda functions into a set of independently addressable AWS Lambda functions .  Additionally, Sparta provides microservice authors an opportunity to satisfy other requirements such as defining the IAM Roles under which their function will execute in AWS, additional infrastructure requirements, and telemetry and alerting information (via CloudWatch).&lt;/p&gt;

&lt;p&gt;The table below summarizes some of the primary Sparta terminology.&lt;/p&gt;

&lt;div class=&#34;list-group&#34;&gt;
  &lt;!-- Service Name --&gt;
  &lt;div class=&#34;list-group-item&#34;&gt;
    &lt;h3 class=&#34;list-group-item-heading&#34;&gt;Service Name&lt;/h3&gt;
    &lt;h5 class=&#34;list-group-item-text large&#34;&gt;Sparta applications are deployed as a single unit, using the &lt;b&gt;ServiceName&lt;/b&gt; as a stable logical identifier.  The &lt;b&gt;ServiceName&lt;/b&gt; is used as your application&#39;s &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/pseudo-parameter-reference.html&#34;&gt;CloudFormation StackName&lt;/a&gt; .&lt;/h5&gt;
    &lt;p /&gt;
    &lt;pre&gt;&lt;code class=&#34;go&#34;&gt;stackName := &amp;#34;MyUniqueServiceName&amp;#34;
sparta.Main(stackName,
  &amp;#34;Simple Sparta application,
  myLambdaFunctions,
  nil,
  nil)&lt;/code&gt;&lt;/pre&gt;

    &lt;/p&gt;
  &lt;/div&gt;
  &lt;!-- Lambda Functions --&gt;
  &lt;div class=&#34;list-group-item&#34;&gt;
    &lt;h3 class=&#34;list-group-item-heading&#34;&gt;Sparta Lambda Function&lt;/h3&gt;
    &lt;h5 class=&#34;list-group-item-text large&#34;&gt;A Sparta-compatible lambda is a &lt;b&gt;Go&lt;/b&gt; function with a specific signature. Sparta uses the results of the &lt;code&gt;http.ResponseWriter&lt;/code&gt; (both status and body) to determine the AWS Lambda response.&lt;/h5&gt;
    &lt;p /&gt;
    &lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func mySpartaLambdaFunction(event *json.RawMessage,
                      context *sparta.LambdaContext,
                      w http.ResponseWriter,
                      logger *logrus.Logger) {

  // Lambda code
}&lt;/code&gt;&lt;/pre&gt;

    &lt;/p&gt;
  &lt;/div&gt;
  &lt;!-- Privileges --&gt;
  &lt;div class=&#34;list-group-item&#34;&gt;
    &lt;h3 class=&#34;list-group-item-heading&#34;&gt;Privileges&lt;/h3&gt;
    &lt;h5 class=&#34;list-group-item-text&#34;&gt;To support accessing other AWS resources in your &lt;b&gt;Go&lt;/b&gt; function, Sparta users may define &lt;a href=&#34;http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html&#34;&gt;IAM Roles&lt;/a&gt; with tightly defined &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#IAMRolePrivilege&#34;&gt;&lt;code&gt;sparta.IAMRolePrivilege&lt;/code&gt;&lt;/a&gt; values. This allows you to define the &lt;i&gt;minimal&lt;/i&gt; set of privileges under which your &lt;b&gt;Go&lt;/b&gt; function will execute.  The &lt;code&gt;Privilege.Resource&lt;/code&gt; field value may also be a &lt;a href=&#34;https://godoc.org/github.com/crewjam/go-cloudformation#StringExpr&#34;&gt;StringExpression&lt;/a&gt; referencing a CloudFormation dynamically provisioned entity.&lt;/h5&gt;
    &lt;p /&gt;
    &lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn.RoleDefinition.Privileges = append(lambdaFn.RoleDefinition.Privileges,
  sparta.IAMRolePrivilege{
  	Actions:  []string{&amp;#34;s3:GetObject&amp;#34;, &amp;#34;s3:HeadObject&amp;#34;},
  	Resource: &amp;#34;arn:aws:s3:::MyS3Bucket&amp;#34;,
})&lt;/code&gt;&lt;/pre&gt;

    &lt;/p&gt;
  &lt;/div&gt;
  &lt;!-- Permissions --&gt;
  &lt;div class=&#34;list-group-item&#34;&gt;
    &lt;h3 class=&#34;list-group-item-heading&#34;&gt;Permissions&lt;/h3&gt;
    &lt;h5 class=&#34;list-group-item-text&#34;&gt;To configure AWS Lambda &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/intro-core-components.html&#34;&gt;Event Sources&lt;/a&gt;, Sparta provides both &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaPermission&#34;&gt;&lt;code&gt;sparta.LambdaPermission&lt;/code&gt;&lt;/a&gt; and service-specific &lt;i&gt;Permission&lt;/i&gt; types; eg: &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudWatchEventsPermission&#34;&gt;&lt;code&gt;sparta.CloudWatchEventsPermission&lt;/code&gt;&lt;/a&gt;. The service-specific &lt;i&gt;Permission&lt;/i&gt; types automatically register your lambda function with the remote AWS service, using each service&#39;s specific API.&lt;/h5&gt;
    &lt;p /&gt;
    &lt;pre&gt;&lt;code class=&#34;go&#34;&gt;cloudWatchEventsPermission := sparta.CloudWatchEventsPermission{}
cloudWatchEventsPermission.Rules = make(map[string]sparta.CloudWatchEventsRule, 0)
cloudWatchEventsPermission.Rules[&amp;#34;Rate5Mins&amp;#34;] = sparta.CloudWatchEventsRule{
  ScheduleExpression: &amp;#34;rate(5 minutes)&amp;#34;,
}
lambdaFn.Permissions = append(lambdaFn.Permissions, cloudWatchEventsPermission)&lt;/code&gt;&lt;/pre&gt;

    &lt;/p&gt;
  &lt;/div&gt;
  &lt;!-- Dynamic Resources --&gt;
  &lt;div class=&#34;list-group-item&#34;&gt;
    &lt;h3 class=&#34;list-group-item-heading&#34;&gt;Dynamic Resources&lt;/h3&gt;
    &lt;h5 class=&#34;list-group-item-text&#34;&gt;Sparta applications can specify other &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html&#34;&gt;AWS Resources&lt;/a&gt; (eg, &lt;i&gt;SNS Topics&lt;/i&gt;) as part of their application. The dynamic resource outputs can be referenced by Sparta lambda functions via &lt;code&gt;gocf.Ref&lt;/code&gt; and &lt;code&gt;gocf.GetAtt&lt;/code&gt; functions.&lt;/h5&gt;
    &lt;p /&gt;
    &lt;pre&gt;&lt;code class=&#34;go&#34;&gt;snsTopicName := sparta.CloudFormationResourceName(&amp;#34;SNSDynamicTopic&amp;#34;)
snsTopic := &amp;amp;gocf.SNSTopic{
  DisplayName: gocf.String(&amp;#34;Sparta Application SNS topic&amp;#34;),
})  
lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoDynamicSNSEvent, nil)
lambdaFn.Permissions = append(lambdaFn.Permissions, sparta.SNSPermission{
	BasePermission: sparta.BasePermission{
		SourceArn: gocf.Ref(snsTopicName),
	},
})&lt;/code&gt;&lt;/pre&gt;

    &lt;/p&gt;
  &lt;/div&gt;
  &lt;!-- Discovery --&gt;
  &lt;div class=&#34;list-group-item&#34;&gt;
    &lt;h3 class=&#34;list-group-item-heading&#34;&gt;Discovery&lt;/h3&gt;
    &lt;h5 class=&#34;list-group-item-text&#34;&gt;To support Sparta lambda functions discovering dynamically assigned AWS values (eg, &lt;i&gt;S3 Bucket Names&lt;/i&gt;), Sparta provides &lt;code&gt;sparta.Discover&lt;/code&gt;. &lt;/h5&gt;
    &lt;p /&gt;
    &lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func echoS3DynamicBucketEvent(event *json.RawMessage,
  context *sparta.LambdaContext,
  w http.ResponseWriter,
  logger *logrus.Logger) {

  config, _ := sparta.Discover()
  // Use config to determine the bucket name to which RawMessage should be stored
}&lt;/code&gt;&lt;/pre&gt;

    &lt;/p&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Given a set of Sparta lambda functions, during a &lt;code&gt;provision&lt;/code&gt; build Sparta follows this workflow:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;mermaid&#34;&gt;
graph TD
  iam[Verify Static IAM Roles]
  compile[Cross Compile for AWS Linux AMI]
  proxyShims[Create NodeJS-Go HTTP Proxies]
  package[ZIP archive]
  upload[Upload Archive to S3]
  packageAssets[Conditionally ZIP S3 Site Assets]
  uploadAssets[Upload S3 Assets]
  generate[Marshal to CloudFormation]
  decorate[Call User Template Decorators - Dynamic AWS Resources]
  uploadTemplate[Upload Template to S3]
  converge[Create/Update Stack]
  wait[Wait for Complete/Failure Result]

  iam--&gt;compile
  compile--&gt;proxyShims
  proxyShims--&gt;package
  proxyShims--&gt;packageAssets
  package--&gt;upload
  packageAssets--&gt;uploadAssets
  uploadAssets--&gt;generate
  upload--&gt;generate
  generate--&gt;decorate
  decorate--&gt;uploadTemplate
  uploadTemplate--&gt;converge
  converge--&gt;wait
&lt;/div&gt;
&lt;h6&gt;This diagram is rendered with &lt;a href=&#34;https://github.com/knsv/mermaid&#34; target=&#34;_blank&#34;&gt;Mermaid&lt;/a&gt;. Please open an &lt;a href=&#34;https://github.com/mweagle/Sparta/issues/new&#34; target=&#34;_blank&#34;&gt;issue&lt;/a&gt; if it doesn&#39;t render properly.&lt;/h6&gt;
&lt;hr /&gt;
&lt;/p&gt;

&lt;p&gt;During provisioning, Sparta uses &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources-lambda.html&#34;&gt;AWS Lambda-backed Custom Resources&lt;/a&gt; to support operations for which CloudFormation doesn&amp;rsquo;t yet support (eg, &lt;a href=&#34;https://aws.amazon.com/api-gateway/&#34;&gt;API Gateway&lt;/a&gt; creation).&lt;/p&gt;

&lt;p&gt;At runtime, Sparta uses &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/programming-model.html&#34;&gt;NodeJS&lt;/a&gt; shims to proxy the request to your &lt;strong&gt;Go&lt;/strong&gt; handler.&lt;/p&gt;

&lt;h1 id=&#34;next-steps:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Next Steps&lt;/h1&gt;

&lt;p&gt;Writing a simple &lt;a href=&#34;http://gosparta.io/docs/intro_example&#34;&gt;Sparta Application&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FAQ</title>
      <link>http://gosparta.io/docs/faq/</link>
      <pubDate>Wed, 20 Jan 2016 21:12:27 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/faq/</guid>
      <description>

&lt;h1 id=&#34;development:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Development&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;what-flags-are-defined-during-aws-ami-compilation:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;What flags are defined during AWS AMI compilation:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TAGS&lt;/strong&gt;:         &lt;code&gt;-tags lambdabinary&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ENVIRONMENT&lt;/strong&gt;:  &lt;code&gt;GOOS=linux GOARCH=amd64&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;how-can-i-test-locally:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;How can I test locally?&lt;/h2&gt;

&lt;p&gt;Local testing is available via the &lt;a href=&#34;http://gosparta.io/docs/local_testing/&#34;&gt;explore&lt;/a&gt; command.&lt;/p&gt;

&lt;h1 id=&#34;event-sources-ses:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Event Sources - SES&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;where-does-the-spartaruleset-come-from:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Where does the &lt;em&gt;SpartaRuleSet&lt;/em&gt; come from?&lt;/h2&gt;

&lt;p&gt;SES only permits a single &lt;a href=&#34;http://docs.aws.amazon.com/ses/latest/APIReference/API_SetActiveReceiptRuleSet.html&#34;&gt;active receipt rule&lt;/a&gt;.  Additionally, it&amp;rsquo;s possible that multiple Sparta-based services are handing different SES recipients.&lt;/p&gt;

&lt;p&gt;All Sparta-based services share the &lt;em&gt;SpartaRuleSet&lt;/em&gt; SES ruleset, and uniquely identify their Rules by including the current servicename as part of the SES &lt;a href=&#34;http://docs.aws.amazon.com/ses/latest/APIReference/API_CreateReceiptRule.html&#34;&gt;ReceiptRule&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;why-does-provision-not-always-enable-the-spartaruleset:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Why does &lt;code&gt;provision&lt;/code&gt; not always enable the &lt;em&gt;SpartaRuleSet&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;Initial &lt;em&gt;SpartaRuleSet&lt;/em&gt; will make it the active ruleset, but Sparta assumes that manual updates made outside of the context of the framework were done with good reason and doesn&amp;rsquo;t attempt to override the user setting.&lt;/p&gt;

&lt;h1 id=&#34;operations:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Operations&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;where-can-i-view-my-function-s-logger-output:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Where can I view my function&amp;rsquo;s &lt;code&gt;*logger&lt;/code&gt; output?&lt;/h2&gt;

&lt;p&gt;Each lambda function includes privileges to write to &lt;a href=&#34;https://console.aws.amazon.com/cloudwatch/home&#34;&gt;CloudWatch Logs&lt;/a&gt;.  The &lt;code&gt;*logrus.logger&lt;/code&gt; output is written (with a brief delay) to a lambda-specific log group.&lt;/p&gt;

&lt;p&gt;The CloudWatch log group name includes a sanitized version of your &lt;strong&gt;Go&lt;/strong&gt; function name &amp;amp; owning service name.&lt;/p&gt;

&lt;h2 id=&#34;where-can-i-view-sparta-s-golang-spawn-metrics:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Where can I view Sparta&amp;rsquo;s golang spawn metrics?&lt;/h2&gt;

&lt;p&gt;Visit the &lt;a href=&#34;https://aws.amazon.com/cloudwatch/&#34;&gt;CloudWatch Metrics&lt;/a&gt; AWS console page and select the &lt;code&gt;Sparta/{SERVICE_NAME}&lt;/code&gt; namespace:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/faq/CloudWatch_Management_Console.jpg&#34; alt=&#34;CloudWatch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Sparta publishes two counters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ProcessSpawned&lt;/code&gt;: A new &lt;strong&gt;Go&lt;/strong&gt; process was spawned to handle requests&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ProcessReused&lt;/code&gt;: An existing &lt;strong&gt;Go&lt;/strong&gt; process was used to handle requests.  See also the discussion on AWS Lambda &lt;a href=&#34;https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/&#34;&gt;container reuse&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;how-can-i-include-additional-aws-resources-as-part-of-my-sparta-application:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;How can I include additional AWS resources as part of my Sparta application?&lt;/h2&gt;

&lt;p&gt;Define a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#TemplateDecorator&#34;&gt;TemplateDecorator&lt;/a&gt; function and annotate the &lt;code&gt;*gocf.Template&lt;/code&gt; with additional AWS resources.&lt;/p&gt;

&lt;h2 id=&#34;how-do-i-forward-additional-metrics:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;How do I forward additional metrics?&lt;/h2&gt;

&lt;p&gt;Sparta-deployed AWS Lambda functions always operate with CloudWatch Metrics &lt;code&gt;putMetric&lt;/code&gt; privileges.  Your lambda code can call &lt;code&gt;putMetric&lt;/code&gt; with application-specific data.&lt;/p&gt;

&lt;h2 id=&#34;how-do-i-setup-alerts-on-additional-metrics:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;How do I setup alerts on additional metrics?&lt;/h2&gt;

&lt;p&gt;Define a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#TemplateDecorator&#34;&gt;TemplateDecorator&lt;/a&gt; function and annotate the &lt;code&gt;*gocf.Template&lt;/code&gt; with the needed &lt;a href=&#34;https://godoc.org/github.com/crewjam/go-cloudformation#CloudWatchAlarm&#34;&gt;AWS::CloudWatch::Alarm&lt;/a&gt; values.  Use &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudFormationResourceName&#34;&gt;CloudFormationResourceName(prefix, &amp;hellip;parts)&lt;/a&gt; to help generate unique resource names.&lt;/p&gt;

&lt;h2 id=&#34;how-can-i-determine-the-outputs-available-in-sparta-discover-for-dynamic-aws-resources:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;How can I determine the outputs available in sparta.Discover() for dynamic AWS resources?&lt;/h2&gt;

&lt;p&gt;The list of registered output provider types is defined by &lt;code&gt;cloudformationTypeMapDiscoveryOutputs&lt;/code&gt; in &lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/cloudformation_resources.go&#34;&gt;cloudformation_resources.go&lt;/a&gt;.  See the &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html&#34;&gt;CloudFormation Resource Types Reference&lt;/a&gt; for information on interpreting the values.&lt;/p&gt;

&lt;h1 id=&#34;future:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Future&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway</title>
      <link>http://gosparta.io/docs/apigateway/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/</guid>
      <description>

&lt;p&gt;One of the most powerful ways to use AWS Lambda is to make function publicly available over HTTPS.  This is accomplished by connecting the AWS Lambda function with the &lt;a href=&#34;https://aws.amazon.com/api-gateway/&#34;&gt;API Gateway&lt;/a&gt;.  In this section we&amp;rsquo;ll start with a simple &amp;ldquo;echo&amp;rdquo; example and move on to a lambda function that accepts user parameters and returns an expiring S3 URL.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/apigateway/example1&#34;&gt;Example 1 - Echo Event&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/apigateway/example2&#34;&gt;Example 2 - User Input &amp;amp; JSON Response&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/apigateway/example3&#34;&gt;Example 3 - Request Context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/apigateway/slack&#34;&gt;Example 4 - Slack SlashCommand&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/apigateway/cors&#34;&gt;Example 5 - CORS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;concepts:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Concepts&lt;/h1&gt;

&lt;p&gt;Before moving on to the examples, it&amp;rsquo;s suggested you familiarize yourself with the API Gateway concepts.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-intro.html&#34;&gt;Gettting Started with Amazon API Gateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The API Gateway presents a powerful and complex domain model.  In brief, to integrate with the API Gateway, a service must:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Define one or more AWS Lambda functions&lt;/li&gt;
&lt;li&gt;Create an API Gateway REST API instance&lt;/li&gt;
&lt;li&gt;Create one or more resources associated with the REST API&lt;/li&gt;
&lt;li&gt;Create one or more methods for each resource&lt;/li&gt;
&lt;li&gt;For each method:

&lt;ol&gt;
&lt;li&gt;Define the method request params&lt;/li&gt;
&lt;li&gt;Define the integration request mapping&lt;/li&gt;
&lt;li&gt;Define the integration response mapping&lt;/li&gt;
&lt;li&gt;Define the method response mapping&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Create a stage for a REST API&lt;/li&gt;
&lt;li&gt;Deploy the given stage&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With that overview, let&amp;rsquo;s start with a simple &lt;a href=&#34;http://gosparta.io/docs/apigateway/example1&#34;&gt;example&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;other-resources:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Other Resources&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started.html&#34;&gt;Walkthrough: API Gateway and Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway - CORS </title>
      <link>http://gosparta.io/docs/apigateway/cors/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/cors/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&#34;&gt;Cross Origin Resource Sharing&lt;/a&gt; defines a protocol by which resources on different domains may establish whether cross site operations are permissible.&lt;/p&gt;

&lt;p&gt;Sparta makes CORS support a single &lt;code&gt;CORSEnabled&lt;/code&gt; field of the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#API&#34;&gt;API&lt;/a&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// Register the function with the API Gateway
apiStage := sparta.NewStage(&amp;#34;v1&amp;#34;)
apiGateway := sparta.NewAPIGateway(&amp;#34;SpartaHTML&amp;#34;, apiStage)
// Enable CORS s.t. the S3 site can access the resources
apiGateway.CORSEnabled = true&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Setting the boolean to &lt;code&gt;true&lt;/code&gt; will add the necessary &lt;code&gt;OPTIONS&lt;/code&gt; and mock responses to &lt;em&gt;all&lt;/em&gt; resources exposed by your API.  See the &lt;a href=&#34;http://gosparta.io/docs/s3site&#34;&gt;SpartaHTML&lt;/a&gt; sample for a complete example.&lt;/p&gt;

&lt;h1 id=&#34;references:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;References&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-cors.html&#34;&gt;API Gateway Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway - Echo</title>
      <link>http://gosparta.io/docs/apigateway/example1/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/example1/</guid>
      <description>

&lt;p&gt;To start, we&amp;rsquo;ll create a HTTPS accessible lambda function that simply echoes back the contents of the Lambda event.  The source for this is the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication&#34;&gt;SpartaApplication&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For reference, the &lt;code&gt;echoS3Event&lt;/code&gt; function is below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func echoS3Event(event *json.RawMessage,
                  context *sparta.LambdaContext,
                  w http.ResponseWriter,
                  logger *logrus.Logger) {

  logger.WithFields(logrus.Fields{
    &amp;#34;RequestID&amp;#34;: context.AWSRequestID,
    &amp;#34;Event&amp;#34;:     string(*event),
  }).Info(&amp;#34;Request received&amp;#34;)

  fmt.Fprintf(w, string(*event))
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;create-the-api-gateway:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Create the API Gateway&lt;/h1&gt;

&lt;p&gt;The first requirement is to create a new &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#API&#34;&gt;API&lt;/a&gt; instance via &lt;code&gt;sparta.NewAPIGateway()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;stage := sparta.NewStage(&amp;#34;prod&amp;#34;)
apiGateway := sparta.NewAPIGateway(&amp;#34;MySpartaAPI&amp;#34;, stage)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;In the example above, we&amp;rsquo;re also including a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Stage&#34;&gt;Stage&lt;/a&gt; value.  A non-&lt;code&gt;nil&lt;/code&gt; Stage value will cause the registered API to be deployed.  If the Stage value is &lt;code&gt;nil&lt;/code&gt;, a REST API will be created, but it will not be &lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html&#34;&gt;deployed&lt;/a&gt; (and therefore not publicly accessible).&lt;/p&gt;

&lt;h1 id=&#34;create-a-resource:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Create a Resource&lt;/h1&gt;

&lt;p&gt;The next step is to associate a URL path with the &lt;code&gt;sparta.LambdaAWSInfo&lt;/code&gt; struct that represents the &lt;strong&gt;Go&lt;/strong&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;apiGatewayResource, _ := api.NewResource(&amp;#34;/hello/world/test&amp;#34;, lambdaFn)
apiGatewayResource.NewMethod(&amp;#34;GET&amp;#34;)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go#L34&#34;&gt;echoS3Event&lt;/a&gt; only supports &lt;code&gt;GET&lt;/code&gt;.  We&amp;rsquo;ll see how a single lambda function can support multiple HTTP methods shortly.&lt;/p&gt;

&lt;h1 id=&#34;provision:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Provision&lt;/h1&gt;

&lt;p&gt;The final step is to to provide the API instance to &lt;code&gt;Sparta.Main()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;stage := sparta.NewStage(&amp;#34;prod&amp;#34;)
apiGateway := sparta.NewAPIGateway(&amp;#34;MySpartaAPI&amp;#34;, stage)
stackName := &amp;#34;SpartaApplication&amp;#34;
sparta.Main(stackName,
  &amp;#34;Simple Sparta application&amp;#34;,
  spartaLambdaData(apiGateway),
  apiGateway,
  nil)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Once the service is successfully provisioned, the &lt;code&gt;Outputs&lt;/code&gt; key will include the API Gateway Deployed URL (sample):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;INFO[0113] Stack output   Description=API Gateway URL Key=APIGatewayURL Value=https://7ljn63rysd.execute-api.us-west-2.amazonaws.com/prod
INFO[0113] Stack output   Description=Sparta Home Key=SpartaHome Value=https://github.com/mweagle/Sparta
INFO[0113] Stack output   Description=Sparta Version Key=SpartaVersion Value=0.1.0&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Combining the &lt;em&gt;API Gateway URL&lt;/em&gt; &lt;code&gt;OutputValue&lt;/code&gt; with our resource path (&lt;em&gt;/hello/world/test&lt;/em&gt;), we get the absolute URL to our lambda function: &lt;em&gt;&lt;a href=&#34;https://7ljn63rysd.execute-api.us-west-2.amazonaws.com/prod/hello/world/test&#34;&gt;https://7ljn63rysd.execute-api.us-west-2.amazonaws.com/prod/hello/world/test&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;querying:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Querying&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s query the lambda function and see what the &lt;code&gt;event&lt;/code&gt; data is at execution time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;curl -vs https://7ljn63rysd.execute-api.us-west-2.amazonaws.com/prod/hello/world/test
*   Trying 54.240.188.223...
* Connected to 7ljn63rysd.execute-api.us-west-2.amazonaws.com (54.240.188.223) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate: *.execute-api.us-west-2.amazonaws.com
* Server certificate: Symantec Class 3 Secure Server CA - G4
* Server certificate: VeriSign Class 3 Public Primary Certification Authority - G5
&amp;gt; GET /prod/hello/world/test HTTP/1.1
&amp;gt; Host: 7ljn63rysd.execute-api.us-west-2.amazonaws.com
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Content-Length: 708
&amp;lt; Connection: keep-alive
&amp;lt; Date: Sat, 05 Dec 2015 21:24:44 GMT
&amp;lt; x-amzn-RequestId: 99dfd15d-9b96-11e5-9705-fdd3a4d9c8bf
&amp;lt; X-Cache: Miss from cloudfront
&amp;lt; Via: 1.1 7a0918c01bce16cc9b165fd895f7dc87.cloudfront.net (CloudFront)
&amp;lt; X-Amz-Cf-Id: rx1cVURKTlc3sla3v59Ekz1YMfVdcUWG1QwFKCFPjjLzHzmL_d6r_w==
&amp;lt;
* Connection #0 to host 7ljn63rysd.execute-api.us-west-2.amazonaws.com left intact
{&amp;#34;method&amp;#34;:&amp;#34;GET&amp;#34;,&amp;#34;body&amp;#34;:{},&amp;#34;headers&amp;#34;:{&amp;#34;Accept&amp;#34;:&amp;#34;*/*&amp;#34;,&amp;#34;CloudFront-Forwarded-Proto&amp;#34;:&amp;#34;https&amp;#34;,&amp;#34;CloudFront-Is-Desktop-Viewer&amp;#34;:&amp;#34;true&amp;#34;,&amp;#34;CloudFront-Is-Mobile-Viewer&amp;#34;:&amp;#34;false&amp;#34;,&amp;#34;CloudFront-Is-SmartTV-Viewer&amp;#34;:&amp;#34;false&amp;#34;,&amp;#34;CloudFront-Is-Tablet-Viewer&amp;#34;:&amp;#34;false&amp;#34;,&amp;#34;CloudFront-Viewer-Country&amp;#34;:&amp;#34;US&amp;#34;,&amp;#34;Via&amp;#34;:&amp;#34;1.1 5c98e8df8806ae26f9ae3c33615610d2.cloudfront.net (CloudFront)&amp;#34;,&amp;#34;X-Amz-Cf-Id&amp;#34;:&amp;#34;sRMCwKpH3jIPbwgIo4pPHv_YJXEo9KEojEFw8yrljFVP2krJbyewLg==&amp;#34;,&amp;#34;X-Forwarded-For&amp;#34;:&amp;#34;50.135.43.1, 54.240.158.211&amp;#34;,&amp;#34;X-Forwarded-Port&amp;#34;:&amp;#34;443&amp;#34;,&amp;#34;X-Forwarded-Proto&amp;#34;:&amp;#34;https&amp;#34;},&amp;#34;queryParams&amp;#34;:{},&amp;#34;pathParams&amp;#34;:{},&amp;#34;context&amp;#34;:{&amp;#34;apiId&amp;#34;:&amp;#34;bmik0opc3l&amp;#34;,&amp;#34;method&amp;#34;:&amp;#34;GET&amp;#34;,&amp;#34;requestId&amp;#34;:&amp;#34;c113fd3b-a76b-11e5-b5e6-4ff04e5da412&amp;#34;,&amp;#34;resourceId&amp;#34;:&amp;#34;mp2mrk&amp;#34;,&amp;#34;resourcePath&amp;#34;:&amp;#34;/hello/world/test&amp;#34;,&amp;#34;stage&amp;#34;:&amp;#34;prod&amp;#34;,&amp;#34;identity&amp;#34;:{&amp;#34;accountId&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;apiKey&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;caller&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;cognitoAuthenticationProvider&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;cognitoAuthenticationType&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;cognitoIdentityId&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;cognitoIdentityPoolId&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;sourceIp&amp;#34;:&amp;#34;50.135.43.1&amp;#34;,&amp;#34;user&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;userAgent&amp;#34;:&amp;#34;curl/7.43.0&amp;#34;,&amp;#34;userArn&amp;#34;:&amp;#34;&amp;#34;}}}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Pretty-printing the response body to make things more readable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;{
  &amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;,
  &amp;#34;body&amp;#34;: {},
  &amp;#34;headers&amp;#34;: {
    &amp;#34;Accept&amp;#34;: &amp;#34;*/*&amp;#34;,
    &amp;#34;CloudFront-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34;,
    &amp;#34;CloudFront-Is-Desktop-Viewer&amp;#34;: &amp;#34;true&amp;#34;,
    &amp;#34;CloudFront-Is-Mobile-Viewer&amp;#34;: &amp;#34;false&amp;#34;,
    &amp;#34;CloudFront-Is-SmartTV-Viewer&amp;#34;: &amp;#34;false&amp;#34;,
    &amp;#34;CloudFront-Is-Tablet-Viewer&amp;#34;: &amp;#34;false&amp;#34;,
    &amp;#34;CloudFront-Viewer-Country&amp;#34;: &amp;#34;US&amp;#34;,
    &amp;#34;Via&amp;#34;: &amp;#34;1.1 5c98e8df8806ae26f9ae3c33615610d2.cloudfront.net (CloudFront)&amp;#34;,
    &amp;#34;X-Amz-Cf-Id&amp;#34;: &amp;#34;sRMCwKpH3jIPbwgIo4pPHv_YJXEo9KEojEFw8yrljFVP2krJbyewLg==&amp;#34;,
    &amp;#34;X-Forwarded-For&amp;#34;: &amp;#34;50.135.43.1, 54.240.158.211&amp;#34;,
    &amp;#34;X-Forwarded-Port&amp;#34;: &amp;#34;443&amp;#34;,
    &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34;
  },
  &amp;#34;queryParams&amp;#34;: {},
  &amp;#34;pathParams&amp;#34;: {},
  &amp;#34;context&amp;#34;: {
    &amp;#34;apiId&amp;#34;: &amp;#34;bmik0opc3l&amp;#34;,
    &amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;,
    &amp;#34;requestId&amp;#34;: &amp;#34;c113fd3b-a76b-11e5-b5e6-4ff04e5da412&amp;#34;,
    &amp;#34;resourceId&amp;#34;: &amp;#34;mp2mrk&amp;#34;,
    &amp;#34;resourcePath&amp;#34;: &amp;#34;/hello/world/test&amp;#34;,
    &amp;#34;stage&amp;#34;: &amp;#34;prod&amp;#34;,
    &amp;#34;identity&amp;#34;: {
      &amp;#34;accountId&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;apiKey&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;caller&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;cognitoAuthenticationProvider&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;cognitoAuthenticationType&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;cognitoIdentityId&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;cognitoIdentityPoolId&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;sourceIp&amp;#34;: &amp;#34;50.135.43.1&amp;#34;,
      &amp;#34;user&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;userAgent&amp;#34;: &amp;#34;curl/7.43.0&amp;#34;,
      &amp;#34;userArn&amp;#34;: &amp;#34;&amp;#34;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;While this demonstrates that our lambda function is publicly accessible, it&amp;rsquo;s not immediately obvious where the &lt;code&gt;*event&lt;/code&gt; data is being populated.&lt;/p&gt;

&lt;h1 id=&#34;mapping-templates:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Mapping Templates&lt;/h1&gt;

&lt;p&gt;The event data that&amp;rsquo;s actually supplied to &lt;code&gt;echoS3Event&lt;/code&gt; is the complete HTTP response body.  This content is what the API Gateway sends to our lambda function, which is defined by  the integration mapping.  This event data also includes the values of any whitelisted parameters.  When the API Gateway Method is defined, it optionally includes any  whitelisted query params and header values that should be forwarded to the integration target.  For this example, we&amp;rsquo;re not whitelisting any params, so those fields (&lt;code&gt;queryParams&lt;/code&gt;, &lt;code&gt;pathParams&lt;/code&gt;) are empty.  Then for each integration target (which can be AWS Lambda, a mock, or a HTTP Proxy), it&amp;rsquo;s possible to transform the API Gateway request data and whitelisted arguments into a format that&amp;rsquo;s more amenable to the target.&lt;/p&gt;

&lt;p&gt;Sparta uses a pass-through template that passes all valid data, with minor &lt;strong&gt;Body&lt;/strong&gt; differences based on the inbound &lt;em&gt;Content-Type&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/resources/provision/apigateway/inputmapping_json.vtl&#34;&gt;application/json&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/resources/provision/apigateway/inputmapping_default.vtl&#34;&gt;*&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;application/json&lt;/code&gt; template is copied below:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;#*
Provide an automatic pass through template that transforms all inputs
into the JSON payload sent to a golang function

See
  https://forums.aws.amazon.com/thread.jspa?threadID=220274&amp;amp;tstart=0
  http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html
*#
{
  &amp;#34;method&amp;#34;: &amp;#34;$context.httpMethod&amp;#34;,
  &amp;#34;body&amp;#34; : $input.json(&amp;#39;$&amp;#39;),
  &amp;#34;headers&amp;#34;: {
    #foreach($param in $input.params().header.keySet())
    &amp;#34;$param&amp;#34;: &amp;#34;$util.escapeJavaScript($input.params().header.get($param))&amp;#34; #if($foreach.hasNext),#end

    #end
  },
  &amp;#34;queryParams&amp;#34;: {
    #foreach($param in $input.params().querystring.keySet())
    &amp;#34;$param&amp;#34;: &amp;#34;$util.escapeJavaScript($input.params().querystring.get($param))&amp;#34; #if($foreach.hasNext),#end

    #end
  },
  &amp;#34;pathParams&amp;#34;: {
    #foreach($param in $input.params().path.keySet())
    &amp;#34;$param&amp;#34;: &amp;#34;$util.escapeJavaScript($input.params().path.get($param))&amp;#34; #if($foreach.hasNext),#end

    #end
  },
  &amp;#34;context&amp;#34; : {
    &amp;#34;apiId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.apiId)&amp;#34;,
    &amp;#34;method&amp;#34; : &amp;#34;$util.escapeJavaScript($context.httpMethod)&amp;#34;,
    &amp;#34;requestId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.requestId)&amp;#34;,
    &amp;#34;resourceId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.resourceId)&amp;#34;,
    &amp;#34;resourcePath&amp;#34; : &amp;#34;$util.escapeJavaScript($context.resourcePath)&amp;#34;,
    &amp;#34;stage&amp;#34; : &amp;#34;$util.escapeJavaScript($context.stage)&amp;#34;,
    &amp;#34;identity&amp;#34; : {
      &amp;#34;accountId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.accountId)&amp;#34;,
      &amp;#34;apiKey&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.apiKey)&amp;#34;,
      &amp;#34;caller&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.caller)&amp;#34;,
      &amp;#34;cognitoAuthenticationProvider&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.cognitoAuthenticationProvider)&amp;#34;,
      &amp;#34;cognitoAuthenticationType&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.cognitoAuthenticationType)&amp;#34;,
      &amp;#34;cognitoIdentityId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.cognitoIdentityId)&amp;#34;,
      &amp;#34;cognitoIdentityPoolId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.cognitoIdentityPoolId)&amp;#34;,
      &amp;#34;sourceIp&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.sourceIp)&amp;#34;,
      &amp;#34;user&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.user)&amp;#34;,
      &amp;#34;userAgent&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.userAgent)&amp;#34;,
      &amp;#34;userArn&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.userArn)&amp;#34;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;This template forwards all whitelisted data &amp;amp; body to the lambda function.  You can see by switching on the &lt;code&gt;method&lt;/code&gt; field would permit a single function to service multiple HTTP method names.&lt;/p&gt;

&lt;p&gt;The next example will show how to unmarshal this data and perform request-specific actions.&lt;/p&gt;

&lt;h1 id=&#34;proxying-envelope:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Proxying Envelope&lt;/h1&gt;

&lt;p&gt;Because the integration request returned a successful response, the API Gateway response body contains only our lambda&amp;rsquo;s output.&lt;/p&gt;

&lt;p&gt;If there were an error, the response would include additional fields (&lt;code&gt;code&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt;, &lt;code&gt;headers&lt;/code&gt;).  Those fields are injected by the NodeJS proxying tier as part of translating the &lt;strong&gt;Go&lt;/strong&gt; HTTP response to a Lambda compatible result.&lt;/p&gt;

&lt;p&gt;A primary benefit of this envelope is to provide an automatic mapping from Integration Error Response Regular Expression mappings to Method Response codes.  If you look at the &lt;strong&gt;Integration Response&lt;/strong&gt; section of the &lt;em&gt;/hello/world/test&lt;/em&gt; resource in the Console, you&amp;rsquo;ll see a list of Regular Expression matches:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/IntegrationMapping.png&#34; alt=&#34;API Gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The regular expressions are used to translate the integration response, which is just a blob of text provided to &lt;code&gt;context.done()&lt;/code&gt;, into API Gateway Method responses.  Sparta annotates your lambda functions response with &lt;strong&gt;Go&lt;/strong&gt;&amp;rsquo;s &lt;a href=&#34;https://golang.org/src/net/http/status.go&#34;&gt;HTTP StatusText&lt;/a&gt; values based on the HTTP status code your lambda function produced.  Sparta also provides a corresponding Method Response entry for all valid HTTP codes:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/MethodResponse.png&#34; alt=&#34;API Gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;These mappings are defaults, and it&amp;rsquo;s possible to override either one by providing a non-zero length values to either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Integration&#34;&gt;Integration.Responses&lt;/a&gt;.  See the &lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/apigateway.go#L60&#34;&gt;DefaultIntegrationResponses&lt;/a&gt; for the default values.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Method&#34;&gt;Method.Responses&lt;/a&gt;.  See the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#DefaultMethodResponses&#34;&gt;DefaultMethodResponses&lt;/a&gt; for the default method response mappings.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;cleaning-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Cleaning Up&lt;/h1&gt;

&lt;p&gt;Before moving on, remember to decommission the service via:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;go run application.go delete&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h1 id=&#34;wrapping-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;Now that we know what data is actually being sent to our API Gateway-connected Lambda function, we&amp;rsquo;ll move on to performing a more complex operation, including returning a custom HTTP response body.&lt;/p&gt;

&lt;h1 id=&#34;other-resources:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Other Resources&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html&#34;&gt;Mapping Template Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway - Request Context</title>
      <link>http://gosparta.io/docs/apigateway/example3/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/example3/</guid>
      <description>

&lt;p&gt;This example demonstrates how to use the &lt;code&gt;Context&lt;/code&gt; struct provided as part of the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#APIGatewayLambdaJSONEvent&#34;&gt;APIGatewayLambdaJSONEvent&lt;/a&gt; event.  The &lt;a href=&#34;https://github.com/mweagle/SpartaGeoIP&#34;&gt;SpartaGeoIP&lt;/a&gt; service will return Geo information based on the inbound request&amp;rsquo;s IP address.&lt;/p&gt;

&lt;h1 id=&#34;define-the-lambda-function:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Define the Lambda Function&lt;/h1&gt;

&lt;p&gt;Our function will examine the inbound request, lookup the user&amp;rsquo;s IP address in the &lt;a href=&#34;http://dev.maxmind.com/geoip/geoip2/geolite2/&#34;&gt;GeoLite2 Database&lt;/a&gt; and return any information to the client.&lt;/p&gt;

&lt;p&gt;As this function is only expected to be invoked from the API Gateway, we&amp;rsquo;ll unmarshall the inbound event:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func ipGeoLambda(event *json.RawMessage,
                  context *sparta.LambdaContext,
                  w http.ResponseWriter,
                  logger *logrus.Logger) {
var lambdaEvent sparta.APIGatewayLambdaJSONEvent
err := json.Unmarshal([]byte(*event), &amp;amp;lambdaEvent)
if err != nil {
	logger.Error(&amp;#34;Failed to unmarshal event data: &amp;#34;, err.Error())
	http.Error(w, err.Error(), http.StatusInternalServerError)
	return
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;We&amp;rsquo;ll then parse the inbound IP address from the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#APIGatewayContext&#34;&gt;Context&lt;/a&gt; and perform a lookup against the database handle opened in the &lt;a href=&#34;https://github.com/mweagle/SpartaGeoIP/blob/master/main.go#L19&#34;&gt;init&lt;/a&gt; block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;parsedIP := net.ParseIP(lambdaEvent.Context.Identity.SourceIP)
record, err := dbHandle.City(parsedIP)
if err != nil {
  logger.Error(&amp;#34;Failed to find city: &amp;#34;, err.Error())
  http.Error(w, err.Error(), http.StatusInternalServerError)
  return
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Finally, marshal the data or error result and we&amp;rsquo;re done:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// Return the Info
httpResponse := map[string]interface{}{
  &amp;#34;info&amp;#34;: record,
}
responseBody, err := json.Marshal(httpResponse)
if err != nil {
  http.Error(w, err.Error(), http.StatusInternalServerError)
} else {
  w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/json&amp;#34;)
  fmt.Fprint(w, string(responseBody))
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;sparta-integration:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Sparta Integration&lt;/h1&gt;

&lt;p&gt;The next steps are to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;LambdaAWSInfo&lt;/a&gt; value&lt;/li&gt;
&lt;li&gt;Create an associated API Gateway&lt;/li&gt;
&lt;li&gt;Create an API Gateway resource that invokes our lambda function&lt;/li&gt;
&lt;li&gt;Add a Method name to the resource.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These four steps are managed in the service&amp;rsquo;s &lt;code&gt;main()&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;////////////////////////////////////////////////////////////////////////////////
// Main
func main() {
	stage := sparta.NewStage(&amp;#34;ipgeo&amp;#34;)
	apiGateway := sparta.NewAPIGateway(&amp;#34;SpartaGeoIPService&amp;#34;, stage)
	stackName := &amp;#34;SpartaGeoIP&amp;#34;

	var lambdaFunctions []*sparta.LambdaAWSInfo
	lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, ipGeoLambda, nil)
	apiGatewayResource, _ := apiGateway.NewResource(&amp;#34;/info&amp;#34;, lambdaFn)
	apiGatewayResource.NewMethod(&amp;#34;GET&amp;#34;)
	lambdaFunctions = append(lambdaFunctions, lambdaFn)

	sparta.Main(stackName,
		&amp;#34;Sparta app supporting ip-&amp;gt;geo mapping&amp;#34;,
		lambdaFunctions,
		apiGateway,
    nil)
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;provision:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Provision&lt;/h1&gt;

&lt;p&gt;The next step is to provision the stack:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;S3_BUCKET=&amp;lt;MY-S3-BUCKETNAME&amp;gt; make provision&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Assuming all goes well, the log output will include the API Gateway URL as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;INFO[0113] Stack output   Description=API Gateway URL Key=APIGatewayURL Value=https://qyslujefsf.execute-api.us-west-2.amazonaws.com/ipgeo
INFO[0113] Stack output   Description=Sparta Home Key=SpartaHome Value=https://github.com/mweagle/Sparta
INFO[0113] Stack output   Description=Sparta Version Key=SpartaVersion Value=0.1.0&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;query:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Query&lt;/h1&gt;

&lt;p&gt;With the API Gateway provisioned, let&amp;rsquo;s check the response:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;curl -vs https://qyslujefsf.execute-api.us-west-2.amazonaws.com/ipgeo/info

*   Trying 54.192.70.206...
* Connected to qyslujefsf.execute-api.us-west-2.amazonaws.com (54.192.70.206) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate: *.execute-api.us-west-2.amazonaws.com
* Server certificate: Symantec Class 3 Secure Server CA - G4
* Server certificate: VeriSign Class 3 Public Primary Certification Authority - G5
&amp;gt; GET /ipgeo/info HTTP/1.1
&amp;gt; Host: qyslujefsf.execute-api.us-west-2.amazonaws.com
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Content-Length: 1129
&amp;lt; Connection: keep-alive
&amp;lt; Date: Sun, 06 Dec 2015 21:50:18 GMT
&amp;lt; x-amzn-RequestId: 572adc18-9c63-11e5-b827-81d99c02192f
&amp;lt; X-Cache: Miss from cloudfront
&amp;lt; Via: 1.1 29bfa9b96f4ea66dc02526ee845ca6b0.cloudfront.net (CloudFront)
&amp;lt; X-Amz-Cf-Id: 5mXHuOlbDyk5CejDouAy7nUS3YUn4eXJdQWzU_1VqX9Yh5PE_BdlAw==
&amp;lt;
* Connection #0 to host qyslujefsf.execute-api.us-west-2.amazonaws.com left intact
{&amp;#34;code&amp;#34;:200,&amp;#34;status&amp;#34;:&amp;#34;OK&amp;#34;,&amp;#34;headers&amp;#34;:{&amp;#34;content-type&amp;#34;:&amp;#34;application/json&amp;#34;,&amp;#34;date&amp;#34;:&amp;#34;Sun, 06 Dec 2015 21:50:18 GMT&amp;#34;,&amp;#34;content-length&amp;#34;:&amp;#34;984&amp;#34;},&amp;#34;results&amp;#34;:{&amp;#34;info&amp;#34;:{&amp;#34;City&amp;#34;:{&amp;#34;GeoNameID&amp;#34;:0,&amp;#34;Names&amp;#34;:null},&amp;#34;Continent&amp;#34;:{&amp;#34;Code&amp;#34;:&amp;#34;NA&amp;#34;,&amp;#34;GeoNameID&amp;#34;:6255149,&amp;#34;Names&amp;#34;:{&amp;#34;de&amp;#34;:&amp;#34;Nordamerika&amp;#34;,&amp;#34;en&amp;#34;:&amp;#34;North America&amp;#34;,&amp;#34;es&amp;#34;:&amp;#34;Norteamrica&amp;#34;,&amp;#34;fr&amp;#34;:&amp;#34;Amrique du Nord&amp;#34;,&amp;#34;ja&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;pt-BR&amp;#34;:&amp;#34;Amrica do Norte&amp;#34;,&amp;#34;ru&amp;#34;:&amp;#34; &amp;#34;,&amp;#34;zh-CN&amp;#34;:&amp;#34;&amp;#34;}},&amp;#34;Country&amp;#34;:{&amp;#34;GeoNameID&amp;#34;:6252001,&amp;#34;IsoCode&amp;#34;:&amp;#34;US&amp;#34;,&amp;#34;Names&amp;#34;:{&amp;#34;de&amp;#34;:&amp;#34;USA&amp;#34;,&amp;#34;en&amp;#34;:&amp;#34;United States&amp;#34;,&amp;#34;es&amp;#34;:&amp;#34;Estados Unidos&amp;#34;,&amp;#34;fr&amp;#34;:&amp;#34;tats-Unis&amp;#34;,&amp;#34;ja&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;pt-BR&amp;#34;:&amp;#34;Estados Unidos&amp;#34;,&amp;#34;ru&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;zh-CN&amp;#34;:&amp;#34;&amp;#34;}},&amp;#34;Location&amp;#34;:{&amp;#34;Latitude&amp;#34;:0,&amp;#34;Longitude&amp;#34;:0,&amp;#34;MetroCode&amp;#34;:0,&amp;#34;TimeZone&amp;#34;:&amp;#34;&amp;#34;},&amp;#34;Postal&amp;#34;:{&amp;#34;Code&amp;#34;:&amp;#34;&amp;#34;},&amp;#34;RegisteredCountry&amp;#34;:{&amp;#34;GeoNameID&amp;#34;:6252001,&amp;#34;IsoCode&amp;#34;:&amp;#34;US&amp;#34;,&amp;#34;Names&amp;#34;:{&amp;#34;de&amp;#34;:&amp;#34;USA&amp;#34;,&amp;#34;en&amp;#34;:&amp;#34;United States&amp;#34;,&amp;#34;es&amp;#34;:&amp;#34;Estados Unidos&amp;#34;,&amp;#34;fr&amp;#34;:&amp;#34;tats-Unis&amp;#34;,&amp;#34;ja&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;pt-BR&amp;#34;:&amp;#34;Estados Unidos&amp;#34;,&amp;#34;ru&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;zh-CN&amp;#34;:&amp;#34;&amp;#34;}},&amp;#34;RepresentedCountry&amp;#34;:{&amp;#34;GeoNameID&amp;#34;:0,&amp;#34;IsoCode&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;Names&amp;#34;:null,&amp;#34;Type&amp;#34;:&amp;#34;&amp;#34;},&amp;#34;Subdivisions&amp;#34;:null,&amp;#34;Traits&amp;#34;:{&amp;#34;IsAnonymousProxy&amp;#34;:false,&amp;#34;IsSatelliteProvider&amp;#34;:false}}}}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Pretty-printing the response body:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;code&amp;quot;: 200,
  &amp;quot;status&amp;quot;: &amp;quot;OK&amp;quot;,
  &amp;quot;headers&amp;quot;: {
    &amp;quot;content-type&amp;quot;: &amp;quot;application/json&amp;quot;,
    &amp;quot;date&amp;quot;: &amp;quot;Sun, 06 Dec 2015 17:50:15 GMT&amp;quot;,
    &amp;quot;content-length&amp;quot;: &amp;quot;984&amp;quot;
  },
  &amp;quot;results&amp;quot;: {
    &amp;quot;info&amp;quot;: {
      &amp;quot;City&amp;quot;: {
        &amp;quot;GeoNameID&amp;quot;: 0,
        &amp;quot;Names&amp;quot;: null
      },
      &amp;quot;Continent&amp;quot;: {
        &amp;quot;Code&amp;quot;: &amp;quot;NA&amp;quot;,
        &amp;quot;GeoNameID&amp;quot;: 6255149,
        &amp;quot;Names&amp;quot;: {
          &amp;quot;de&amp;quot;: &amp;quot;Nordamerika&amp;quot;,
          &amp;quot;en&amp;quot;: &amp;quot;North America&amp;quot;,
          &amp;quot;es&amp;quot;: &amp;quot;Norteamrica&amp;quot;,
          &amp;quot;fr&amp;quot;: &amp;quot;Amrique du Nord&amp;quot;,
          &amp;quot;ja&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;pt-BR&amp;quot;: &amp;quot;Amrica do Norte&amp;quot;,
          &amp;quot;ru&amp;quot;: &amp;quot; &amp;quot;,
          &amp;quot;zh-CN&amp;quot;: &amp;quot;&amp;quot;
        }
      },
      &amp;quot;Country&amp;quot;: {
        &amp;quot;GeoNameID&amp;quot;: 6252001,
        &amp;quot;IsoCode&amp;quot;: &amp;quot;US&amp;quot;,
        &amp;quot;Names&amp;quot;: {
          &amp;quot;de&amp;quot;: &amp;quot;USA&amp;quot;,
          &amp;quot;en&amp;quot;: &amp;quot;United States&amp;quot;,
          &amp;quot;es&amp;quot;: &amp;quot;Estados Unidos&amp;quot;,
          &amp;quot;fr&amp;quot;: &amp;quot;tats-Unis&amp;quot;,
          &amp;quot;ja&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;pt-BR&amp;quot;: &amp;quot;Estados Unidos&amp;quot;,
          &amp;quot;ru&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;zh-CN&amp;quot;: &amp;quot;&amp;quot;
        }
      },
      &amp;quot;Location&amp;quot;: {
        &amp;quot;Latitude&amp;quot;: 0,
        &amp;quot;Longitude&amp;quot;: 0,
        &amp;quot;MetroCode&amp;quot;: 0,
        &amp;quot;TimeZone&amp;quot;: &amp;quot;&amp;quot;
      },
      &amp;quot;Postal&amp;quot;: {
        &amp;quot;Code&amp;quot;: &amp;quot;&amp;quot;
      },
      &amp;quot;RegisteredCountry&amp;quot;: {
        &amp;quot;GeoNameID&amp;quot;: 6252001,
        &amp;quot;IsoCode&amp;quot;: &amp;quot;US&amp;quot;,
        &amp;quot;Names&amp;quot;: {
          &amp;quot;de&amp;quot;: &amp;quot;USA&amp;quot;,
          &amp;quot;en&amp;quot;: &amp;quot;United States&amp;quot;,
          &amp;quot;es&amp;quot;: &amp;quot;Estados Unidos&amp;quot;,
          &amp;quot;fr&amp;quot;: &amp;quot;tats-Unis&amp;quot;,
          &amp;quot;ja&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;pt-BR&amp;quot;: &amp;quot;Estados Unidos&amp;quot;,
          &amp;quot;ru&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;zh-CN&amp;quot;: &amp;quot;&amp;quot;
        }
      },
      &amp;quot;RepresentedCountry&amp;quot;: {
        &amp;quot;GeoNameID&amp;quot;: 0,
        &amp;quot;IsoCode&amp;quot;: &amp;quot;&amp;quot;,
        &amp;quot;Names&amp;quot;: null,
        &amp;quot;Type&amp;quot;: &amp;quot;&amp;quot;
      },
      &amp;quot;Subdivisions&amp;quot;: null,
      &amp;quot;Traits&amp;quot;: {
        &amp;quot;IsAnonymousProxy&amp;quot;: false,
        &amp;quot;IsSatelliteProvider&amp;quot;: false
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Please see the &lt;a href=&#34;http://gosparta.io/docs/apigateway/example1&#34;&gt;first example&lt;/a&gt; for more information on the &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt;, and &lt;code&gt;headers&lt;/code&gt; keys.&lt;/p&gt;

&lt;h1 id=&#34;cleaning-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Cleaning Up&lt;/h1&gt;

&lt;p&gt;Before moving on, remember to decommission the service via:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;go run main.go delete&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h1 id=&#34;notes:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Notes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;GeoLite2-Country.mmdb&lt;/em&gt; content is embedded in the go binary via &lt;a href=&#34;https://github.com/mjibson/esc&#34;&gt;esc&lt;/a&gt; as part of the &lt;a href=&#34;https://github.com/mweagle/SpartaGeoIP/blob/master/main.go#L27&#34;&gt;go generate&lt;/a&gt; phase.&lt;/li&gt;
&lt;li&gt;This is a port of Tom Maiaroto&amp;rsquo;s &lt;a href=&#34;https://github.com/tmaiaroto/go-lambda-geoip&#34;&gt;https://github.com/tmaiaroto/go-lambda-geoip&lt;/a&gt; implementation.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway - Slack SlashCommand</title>
      <link>http://gosparta.io/docs/apigateway/slack/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/slack/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/slack_rgb.png&#34; alt=&#34;SlashLogo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this example, we&amp;rsquo;ll walk through creating a &lt;a href=&#34;https://api.slack.com/slash-commands&#34;&gt;Slack Slash Command&lt;/a&gt; service.  The source for this is the &lt;a href=&#34;https://github.com/mweagle/SpartaSlackbot&#34;&gt;SpartaSlackbot&lt;/a&gt; repo.&lt;/p&gt;

&lt;p&gt;Our initial command handler won&amp;rsquo;t be very sophisticated, but will show the steps necessary to provision and configure a Sparta AWS Gateway-enabled Lambda function.&lt;/p&gt;

&lt;h1 id=&#34;define-the-lambda-function:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Define the Lambda Function&lt;/h1&gt;

&lt;p&gt;This lambda handler is a bit more complicated than the other examples, primarily because of the &lt;a href=&#34;https://api.slack.com/slash-commands&#34;&gt;Slack Integration&lt;/a&gt; requirements.  The full source is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;////////////////////////////////////////////////////////////////////////////////
// Hello world event handler
//
func helloSlackbot(event *json.RawMessage,
	context *sparta.LambdaContext,
	w http.ResponseWriter,
	logger *logrus.Logger) {

	// 1. Unmarshal the primary event
	var lambdaEvent slackLambdaJSONEvent
	err := json.Unmarshal([]byte(*event), &amp;amp;lambdaEvent)
	if err != nil {
		logger.Error(&amp;#34;Failed to unmarshal event data: &amp;#34;, err.Error())
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}

	// 2. Conditionally unmarshal to get the Slack text.  See
	// https://api.slack.com/slash-commands
	// for the value name list
	requestParams := url.Values{}
	if bodyData, ok := lambdaEvent.Body.(string); ok {
		requestParams, err = url.ParseQuery(bodyData)
		if err != nil {
			logger.Error(&amp;#34;Failed to parse query: &amp;#34;, err.Error())
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
		logger.WithFields(logrus.Fields{
			&amp;#34;Values&amp;#34;: requestParams,
		}).Info(&amp;#34;Slack slashcommand values&amp;#34;)
	} else {
		logger.Info(&amp;#34;Event body empty&amp;#34;)
	}

	// 3. Create the response
	// Slack formatting:
	// https://api.slack.com/docs/formatting
	responseText := &amp;#34;You talkin to me?&amp;#34;
	for _, eachLine := range requestParams[&amp;#34;text&amp;#34;] {
		responseText &amp;#43;= fmt.Sprintf(&amp;#34;\n&amp;gt;&amp;gt;&amp;gt; %s&amp;#34;, eachLine)
	}

	// 4. Setup the response object:
	// https://api.slack.com/slash-commands, &amp;#34;Responding to a command&amp;#34;
	responseData := sparta.ArbitraryJSONObject{
		&amp;#34;response_type&amp;#34;: &amp;#34;in_channel&amp;#34;,
		&amp;#34;text&amp;#34;:          responseText,
	}
	// 5. Send it off
	responseBody, err := json.Marshal(responseData)
	if err != nil {
		logger.Error(&amp;#34;Failed to marshal response: &amp;#34;, err.Error())
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
	fmt.Fprint(w, string(responseBody))
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;There are a couple of things to note in this code:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Custom Event Type&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The inbound Slack &lt;code&gt;POST&lt;/code&gt; request is &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; data.  However, our &lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/resources/provision/apigateway/inputmapping_default.vtl&#34;&gt;integration mapping&lt;/a&gt; mediates the API Gateway HTTPS request, transforming the public request into an integration request.  The integration mapping wraps the raw &lt;code&gt;POST&lt;/code&gt; body with the mapping envelope (so that we can access &lt;a href=&#34;http://gosparta.io/docs/apigateway/example1&#34;&gt;identity information, HTTP headers, etc.&lt;/a&gt;), which produces an inbound JSON request that includes a &lt;strong&gt;Body&lt;/strong&gt; parameter.  The &lt;strong&gt;Body&lt;/strong&gt; string value is the raw inbound &lt;code&gt;POST&lt;/code&gt; data.  Since it&amp;rsquo;s &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, to get the actual parameters we need to parse it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if bodyData, ok := lambdaEvent.Body.(string); ok {
  requestParams, err = url.ParseQuery(bodyData)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The lambda function extracts all Slack parameters and if defined, sends the &lt;code&gt;text&lt;/code&gt; back with a bit of &lt;a href=&#34;https://api.slack.com/docs/formatting&#34;&gt;Slack Message Formatting&lt;/a&gt; (and some attitude, to be honest about it):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;responseText := &amp;quot;You talkin to me?&amp;quot;
for _, eachLine := range requestParams[&amp;quot;text&amp;quot;] {
  responseText += fmt.Sprintf(&amp;quot;\n&amp;gt;&amp;gt;&amp;gt; %s&amp;quot;, eachLine)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Custom Response&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The Slack API expects a &lt;a href=&#34;https://api.slack.com/slash-commands&#34;&gt;JSON formatted response&lt;/a&gt;, which is created in step 4:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;responseData := sparta.ArbitraryJSONObject{
    &amp;quot;response_type&amp;quot;: &amp;quot;in_channel&amp;quot;,
    &amp;quot;text&amp;quot;:          responseText,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;create-the-api-gateway:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Create the API Gateway&lt;/h1&gt;

&lt;p&gt;With our lambda function defined, we need to setup an API Gateway so that it&amp;rsquo;s publicly available:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;apiStage := sparta.NewStage(&amp;#34;v1&amp;#34;)
apiGateway := sparta.NewAPIGateway(&amp;#34;SpartaSlackbot&amp;#34;, apiStage)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;apiStage&lt;/code&gt; value implies that we want to deploy this API Gateway Rest API as part of Sparta&amp;rsquo;s &lt;code&gt;provision&lt;/code&gt; step.&lt;/p&gt;

&lt;h1 id=&#34;create-lambda-binding-resource:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Create Lambda Binding &amp;amp; Resource&lt;/h1&gt;

&lt;p&gt;Next we create an &lt;code&gt;sparta.LambdaAWSInfo&lt;/code&gt; struct that references the &lt;code&gt;s3ItemInfo&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func spartaLambdaFunctions(api *sparta.API) []*sparta.LambdaAWSInfo {
	var lambdaFunctions []*sparta.LambdaAWSInfo
	lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, helloSlackbot, nil)

	if nil != api {
		apiGatewayResource, _ := api.NewResource(&amp;#34;/slack&amp;#34;, lambdaFn)
		_, err := apiGatewayResource.NewMethod(&amp;#34;POST&amp;#34;)
		if nil != err {
			panic(&amp;#34;Failed to create /hello resource&amp;#34;)
		}
	}
	return append(lambdaFunctions, lambdaFn)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;A few items to note here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We&amp;rsquo;re using an empty &lt;code&gt;sparta.IAMRoleDefinition{}&lt;/code&gt; definition because our go lambda function doesn&amp;rsquo;t access any additional AWS services.&lt;/li&gt;
&lt;li&gt;Our lambda function will be accessible at the &lt;em&gt;/slack&lt;/em&gt; child path of the deployed API Gateway instance&lt;/li&gt;
&lt;li&gt;Slack supports both &lt;a href=&#34;https://api.slack.com/slash-commands&#34;&gt;GET and POST&lt;/a&gt; integration types, but we&amp;rsquo;re limiting our lambda function to &lt;code&gt;POST&lt;/code&gt; only&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;provision:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Provision&lt;/h1&gt;

&lt;p&gt;With everything configured, we then configure our &lt;code&gt;main()&lt;/code&gt; function to forward to Sparta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func main() {
	// Register the function with the API Gateway
	apiStage := sparta.NewStage(&amp;#34;v1&amp;#34;)
	apiGateway := sparta.NewAPIGateway(&amp;#34;SpartaSlackbot&amp;#34;, apiStage)

	// Deploy it
	sparta.Main(&amp;#34;SpartaSlackbot&amp;#34;,
		fmt.Sprintf(&amp;#34;Sparta app that responds to Slack commands&amp;#34;),
		spartaLambdaFunctions(apiGateway),
		apiGateway,
		nil)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;and provision the service:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;S3_BUCKET=&amp;lt;MY_S3_BUCKETNAME&amp;gt; go run slack.go --level info provision&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;Look for the &lt;em&gt;Stack output&lt;/em&gt; section of the log, you&amp;rsquo;ll need the &lt;strong&gt;APIGatewayURL&lt;/strong&gt; value to configure Slack in the next step.&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;INFO[0083] Stack output Description=API Gateway URL Key=APIGatewayURL Value=https://75mtsly44i.execute-api.us-west-2.amazonaws.com/v1
INFO[0083] Stack output Description=Sparta Home Key=SpartaHome Value=https://github.com/mweagle/Sparta
INFO[0083] Stack output Description=Sparta Version Key=SpartaVersion Value=0.1.3&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h1 id=&#34;configure-slack:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Configure Slack&lt;/h1&gt;

&lt;p&gt;At this point our lambda function is deployed and is available through the API Gateway (&lt;em&gt;&lt;a href=&#34;https://75mtsly44i.execute-api.us-west-2.amazonaws.com/v1/slack&#34;&gt;https://75mtsly44i.execute-api.us-west-2.amazonaws.com/v1/slack&lt;/a&gt;&lt;/em&gt; in the current example).&lt;/p&gt;

&lt;p&gt;The next step is to configure Slack with this custom integration:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Visit &lt;a href=&#34;https://slack.com/apps/build&#34;&gt;https://slack.com/apps/build&lt;/a&gt; and choose the &amp;ldquo;Custom Integration&amp;rdquo; option:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/customIntegration.jpg&#34; alt=&#34;Custom integration&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On the next page, choose &amp;ldquo;Slash Commands&amp;rdquo;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/slashCommandMenu.jpg&#34; alt=&#34;Slash Commands&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The next screen is where you input the command that will trigger your lambda function.  Enter &lt;code&gt;/sparta&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/chooseCommand.jpg&#34; alt=&#34;Slash Chose Command&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;and click the &amp;ldquo;Add Slash Command Integration&amp;rdquo; button.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, scroll down the next page to the &lt;strong&gt;Integration Settings&lt;/strong&gt; section and provide the API Gateway URL of your lambda function.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/integrationSettings.jpg&#34; alt=&#34;Slash URL&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Leave the &lt;em&gt;Method&lt;/em&gt; field unchanged (it should be &lt;code&gt;POST&lt;/code&gt;), to match how we configured the API Gateway entry above.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Save it&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/saveIntegration.jpg&#34; alt=&#34;Save it&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are additional Slash Command Integration options, but for this example the &lt;strong&gt;URL&lt;/strong&gt; option is sufficient to trigger our command.&lt;/p&gt;

&lt;h1 id=&#34;test:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Test&lt;/h1&gt;

&lt;p&gt;With everything configured, visit your team&amp;rsquo;s Slack room and verify the integration via &lt;code&gt;/sparta&lt;/code&gt; slash command:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/slackResponse.jpg&#34; alt=&#34;Sparta Response&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;cleaning-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Cleaning Up&lt;/h1&gt;

&lt;p&gt;Before moving on, remember to decommission the service via:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;go run slack.go delete&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h1 id=&#34;wrapping-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;This example provides a good overview of Sparta &amp;amp; Slack integration, including how to handle external requests that are not &lt;code&gt;application/json&lt;/code&gt; formatted.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway - User Input</title>
      <link>http://gosparta.io/docs/apigateway/example2/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/example2/</guid>
      <description>

&lt;p&gt;This example demonstrates how to accept user input (delivered as HTTP query params) and return an expiring S3 URL to fetch content.  The source for this is the &lt;a href=&#34;https://github.com/mweagle/SpartaImager/blob/master/application.go#L149&#34;&gt;s3ItemInfo&lt;/a&gt; function defined as part of the  &lt;a href=&#34;https://github.com/mweagle/SpartaApplication&#34;&gt;SpartaApplication&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;define-the-lambda-function:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Define the Lambda Function&lt;/h1&gt;

&lt;p&gt;Our function will accept two params:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bucketName&lt;/code&gt; : The S3 bucket name storing the asset&lt;/li&gt;
&lt;li&gt;&lt;code&gt;keyName&lt;/code&gt; : The S3 item key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Those params will be passed as part of the URL query string.  The function will fetch the item metadata, generate an expiring URL for public S3 access, and return a JSON response body with the item data.&lt;/p&gt;

&lt;p&gt;Because &lt;a href=&#34;https://github.com/mweagle/SpartaImager/blob/master/application.go#L149&#34;&gt;s3ItemInfo&lt;/a&gt; is expected to be invoked by the API Gateway, we&amp;rsquo;ll start by unmarshalling the event data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var lambdaEvent sparta.APIGatewayLambdaJSONEvent
err := json.Unmarshal([]byte(*event), &amp;amp;lambdaEvent)
if err != nil {
  logger.Error(&amp;#34;Failed to unmarshal event data: &amp;#34;, err.Error())
  http.Error(w, err.Error(), http.StatusInternalServerError)
  return
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#APIGatewayLambdaJSONEvent&#34;&gt;sparta.APIGatewayLambdaJSONEvent&lt;/a&gt; fields correspond to the Integration Response Mapping template discussed in the &lt;a href=&#34;http://gosparta.io/docs/apigateway/example1&#34;&gt;previous example&lt;/a&gt; (see the full mapping template &lt;a href=&#34;https://raw.githubusercontent.com/mweagle/Sparta/master/resources/gateway/inputmapping_json.vtl&#34;&gt;here&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Once the event is unmarshaled, we can use it to fetch the S3 item info:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;getObjectInput := &amp;amp;s3.GetObjectInput{
  Bucket: aws.String(lambdaEvent.QueryParams[&amp;#34;bucketName&amp;#34;]),
  Key:    aws.String(lambdaEvent.QueryParams[&amp;#34;keyName&amp;#34;]),
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Assuming there are no errors (including the case where the item does not exist), the remainder of the function fetches the data, generates a presigned URL, and returns a JSON response:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;awsSession := awsSession(logger)
svc := s3.New(awsSession)
result, err := svc.GetObject(getObjectInput)
if nil != err {
  logger.Error(&amp;#34;Failed to process event: &amp;#34;, err.Error())
  http.Error(w, err.Error(), http.StatusInternalServerError)
  return
}
presignedReq, _ := svc.GetObjectRequest(getObjectInput)
url, err := presignedReq.Presign(5 * time.Minute)
if nil != err {
  logger.Error(&amp;#34;Failed to process event: &amp;#34;, err.Error())
  http.Error(w, err.Error(), http.StatusInternalServerError)
  return
}
httpResponse := map[string]interface{}{
  &amp;#34;S3&amp;#34;:  result,
  &amp;#34;URL&amp;#34;: url,
}

responseBody, err := json.Marshal(httpResponse)
if err != nil {
  http.Error(w, err.Error(), http.StatusInternalServerError)
} else {
  w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/json&amp;#34;)
  fmt.Fprint(w, string(responseBody))
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;create-the-api-gateway:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Create the API Gateway&lt;/h1&gt;

&lt;p&gt;The next step is to create a new &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#API&#34;&gt;API&lt;/a&gt; instance via &lt;code&gt;sparta.NewAPIGateway()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;apiStage := sparta.NewStage(&amp;#34;v1&amp;#34;)
apiGateway := sparta.NewAPIGateway(&amp;#34;SpartaImagerAPI&amp;#34;, apiStage)&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;create-lambda-binding:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Create Lambda Binding&lt;/h1&gt;

&lt;p&gt;Next we create an &lt;code&gt;sparta.LambdaAWSInfo&lt;/code&gt; struct that references the &lt;code&gt;s3ItemInfo&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;s3ItemInfoOptions := &amp;amp;sparta.LambdaFunctionOptions{
  Description: &amp;#34;Get information about an item in S3 via querystring params&amp;#34;,
  MemorySize:  128,
  Timeout:     10,
}
var iamDynamicRole = sparta.IAMRoleDefinition{}
iamDynamicRole.Privileges = append(iamDynamicRole.Privileges, sparta.IAMRolePrivilege{
  Actions:  []string{&amp;#34;s3:GetObject&amp;#34;},
  Resource: resourceArn,
})
s3ItemInfoLambdaFn := sparta.NewLambda(iamDynamicRole, s3ItemInfo, s3ItemInfoOptions)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;A few items to note here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We&amp;rsquo;re providing a custom &lt;code&gt;LambdaFunctionOptions&lt;/code&gt; in case the request to S3 to get item metadata exceeds the default 3 second timeout.&lt;/li&gt;
&lt;li&gt;We also add a custom &lt;code&gt;iamDynamicRole.Privileges&lt;/code&gt; entry to the &lt;code&gt;Privileges&lt;/code&gt; slice that authorizes the lambda function to &lt;em&gt;only&lt;/em&gt; access objects in a single bucket (&lt;em&gt;resourceArn&lt;/em&gt;).

&lt;ul&gt;
&lt;li&gt;This bucket ARN is externally created and the ARN provided to this code.&lt;/li&gt;
&lt;li&gt;While the API will accept any &lt;em&gt;bucketName&lt;/em&gt; value, it is only authorized to access a single bucket.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;create-resources:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Create Resources&lt;/h1&gt;

&lt;p&gt;The next step is to associate a URL path with the &lt;code&gt;sparta.LambdaAWSInfo&lt;/code&gt; struct that represents the &lt;code&gt;s3ItemInfo&lt;/code&gt; function. This will be the relative path component used to reference our lambda function via the API Gateway.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;apiGatewayResource, _ := api.NewResource(&amp;#34;/info&amp;#34;, s3ItemInfoLambdaFn)
method, err := apiGatewayResource.NewMethod(&amp;#34;GET&amp;#34;)
if err != nil {
  return nil, err
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;whitelist-input:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Whitelist Input&lt;/h1&gt;

&lt;p&gt;The final step is to add the whitelisted parameters to the Method definition.&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// Whitelist query string params
method.Parameters[&amp;#34;method.request.querystring.keyName&amp;#34;] = true
method.Parameters[&amp;#34;method.request.querystring.bucketName&amp;#34;] = true&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;Note that the keynames in the &lt;code&gt;method.Parameters&lt;/code&gt; map must be of the form: &lt;strong&gt;method.request.{location}.{name}&lt;/strong&gt; where location is one of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;querystring&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;header&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;See the &lt;a href=&#34;http://docs.aws.amazon.com/apigateway/api-reference/resource/method/#requestParameters&#34;&gt;REST documentation&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h1 id=&#34;provision:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Provision&lt;/h1&gt;

&lt;p&gt;With everything configured, let&amp;rsquo;s provision the stack:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;go run application.go --level debug provision --s3Bucket $S3_BUCKET&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;and check the results.&lt;/p&gt;

&lt;h1 id=&#34;querying:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Querying&lt;/h1&gt;

&lt;p&gt;As this Sparta application includes an API Gateway definition, the stack &lt;code&gt;Outputs&lt;/code&gt; includes the API Gateway URL:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;INFO[0113] Stack output   Description=API Gateway URL Key=APIGatewayURL Value=https://0ux556ho77.execute-api.us-west-2.amazonaws.com/v1
INFO[0113] Stack output   Description=Sparta Home Key=SpartaHome Value=https://github.com/mweagle/Sparta
INFO[0113] Stack output   Description=Sparta Version Key=SpartaVersion Value=0.1.0&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s fetch an item we know exists:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;curl -vs &amp;#34;https://0ux556ho77.execute-api.us-west-2.amazonaws.com/v1/info?keyName=gopher.png&amp;amp;bucketName=somebucket-log&amp;#34;

*   Trying 54.192.70.158...
* Connected to 0ux556ho77.execute-api.us-west-2.amazonaws.com (54.192.70.158) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate: *.execute-api.us-west-2.amazonaws.com
* Server certificate: Symantec Class 3 Secure Server CA - G4
* Server certificate: VeriSign Class 3 Public Primary Certification Authority - G5
&amp;gt; GET /v1/info?keyName=gopher.png&amp;amp;bucketName=somebucket-log HTTP/1.1
&amp;gt; Host: 0ux556ho77.execute-api.us-west-2.amazonaws.com
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Content-Length: 1584
&amp;lt; Connection: keep-alive
&amp;lt; Date: Sun, 06 Dec 2015 02:35:03 GMT
&amp;lt; x-amzn-RequestId: f333f4bb-9bc1-11e5-afde-61a428c89049
&amp;lt; X-Cache: Miss from cloudfront
&amp;lt; Via: 1.1 2f31d4850470c56c3b326946dc542a6b.cloudfront.net (CloudFront)
&amp;lt; X-Amz-Cf-Id: 6rBpqjmi7DPax7XOHTbxDx8-FfFfvI04m2_K-PxLWfYFor7WtIcdxA==
&amp;lt;
* Connection #0 to host 0ux556ho77.execute-api.us-west-2.amazonaws.com left intact
{&amp;#34;code&amp;#34;:200,&amp;#34;status&amp;#34;:&amp;#34;OK&amp;#34;,&amp;#34;headers&amp;#34;:{&amp;#34;content-type&amp;#34;:&amp;#34;application/json&amp;#34;,&amp;#34;date&amp;#34;:&amp;#34;Sun, 06 Dec 2015 02:35:03 GMT&amp;#34;,&amp;#34;content-length&amp;#34;:&amp;#34;1468&amp;#34;},&amp;#34;results&amp;#34;:{&amp;#34;S3&amp;#34;:{&amp;#34;AcceptRanges&amp;#34;:&amp;#34;bytes&amp;#34;,&amp;#34;Body&amp;#34;:{},&amp;#34;CacheControl&amp;#34;:null,&amp;#34;ContentDisposition&amp;#34;:null,&amp;#34;ContentEncoding&amp;#34;:null,&amp;#34;ContentLanguage&amp;#34;:null,&amp;#34;ContentLength&amp;#34;:70372,&amp;#34;ContentRange&amp;#34;:null,&amp;#34;ContentType&amp;#34;:&amp;#34;image/png&amp;#34;,&amp;#34;DeleteMarker&amp;#34;:null,&amp;#34;ETag&amp;#34;:&amp;#34;\&amp;#34;ca1f746d6f232f87fca4e4d94ef6f3ab\&amp;#34;&amp;#34;,&amp;#34;Expiration&amp;#34;:null,&amp;#34;Expires&amp;#34;:null,&amp;#34;LastModified&amp;#34;:&amp;#34;2015-11-09T15:38:01Z&amp;#34;,&amp;#34;Metadata&amp;#34;:{},&amp;#34;MissingMeta&amp;#34;:null,&amp;#34;ReplicationStatus&amp;#34;:null,&amp;#34;RequestCharged&amp;#34;:null,&amp;#34;Restore&amp;#34;:null,&amp;#34;SSECustomerAlgorithm&amp;#34;:null,&amp;#34;SSECustomerKeyMD5&amp;#34;:null,&amp;#34;SSEKMSKeyId&amp;#34;:null,&amp;#34;ServerSideEncryption&amp;#34;:null,&amp;#34;StorageClass&amp;#34;:null,&amp;#34;VersionId&amp;#34;:null,&amp;#34;WebsiteRedirectLocation&amp;#34;:null},&amp;#34;URL&amp;#34;:&amp;#34;https://somebucket-log.s3-us-west-2.amazonaws.com/gopher.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Credential=ASIAJ5KB2P6SQ4E7IMMQ%2F20151206%2Fus-west-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20151206T023503Z&amp;amp;X-Amz-Expires=300&amp;amp;X-Amz-Security-Token=AQoDYXdzEFQawAK7vrGb%2BH9lw%2FhEHpR9Yg1KwPmmFcvyMzF7ewFBmxpOkfEM7gLZirMcFFexcxpWv%2F5CVAxpqjRf5FznOYJZHHoBqgmUcKPQZOpYKSbQG768zH5gMNdOANWin1COZU8DyuABrkJYL1bdFpwV7oHgrDmRz2G6oZqqOnfesRHW8WcehSXMV%2BcQFaAcO7IaIMAkRINMIDfxQaa%2FP8i8dbrcOfsEy6UABeaLKL3YgdZIouxcUUKzXQ6Pr4Cgrf0TAyRDAO1t6bVXzv6UFa6j00%2Fm0PYElni7xs5844UFAav%2B1weO2kX65ETzwUxBacAAnuzt%2BmTVPWeikhzgRnjBFn8mQjkZLCJklJJb6QHBO8dph2CSQsh47yw7%2BnexGjAu1y106AA2%2Bfa0WFYC552Q%2FrVVhKU7dejy%2B3jz%2F4LyWdnva9IvmCDVvY6zBQ%3D%3D&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Signature=7d0e6663e043317b5611ddf4ae9f7514aff8c484a31deba524906ba50cbc6a2f&amp;#34;}}&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;Pretty printing the response body:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;{
  &amp;#34;code&amp;#34;: 200,
  &amp;#34;status&amp;#34;: &amp;#34;OK&amp;#34;,
  &amp;#34;headers&amp;#34;: {
    &amp;#34;content-type&amp;#34;: &amp;#34;application/json&amp;#34;,
    &amp;#34;date&amp;#34;: &amp;#34;Sun, 06 Dec 2015 02:35:03 GMT&amp;#34;,
    &amp;#34;content-length&amp;#34;: &amp;#34;1468&amp;#34;
  },
  &amp;#34;results&amp;#34;: {
    &amp;#34;S3&amp;#34;: {
      &amp;#34;AcceptRanges&amp;#34;: &amp;#34;bytes&amp;#34;,
      &amp;#34;Body&amp;#34;: {},
      &amp;#34;CacheControl&amp;#34;: null,
      &amp;#34;ContentDisposition&amp;#34;: null,
      &amp;#34;ContentEncoding&amp;#34;: null,
      &amp;#34;ContentLanguage&amp;#34;: null,
      &amp;#34;ContentLength&amp;#34;: 70372,
      &amp;#34;ContentRange&amp;#34;: null,
      &amp;#34;ContentType&amp;#34;: &amp;#34;image/png&amp;#34;,
      &amp;#34;DeleteMarker&amp;#34;: null,
      &amp;#34;ETag&amp;#34;: &amp;#34;\&amp;#34;ca1f746d6f232f87fca4e4d94ef6f3ab\&amp;#34;&amp;#34;,
      &amp;#34;Expiration&amp;#34;: null,
      &amp;#34;Expires&amp;#34;: null,
      &amp;#34;LastModified&amp;#34;: &amp;#34;2015-11-09T15:38:01Z&amp;#34;,
      &amp;#34;Metadata&amp;#34;: {},
      &amp;#34;MissingMeta&amp;#34;: null,
      &amp;#34;ReplicationStatus&amp;#34;: null,
      &amp;#34;RequestCharged&amp;#34;: null,
      &amp;#34;Restore&amp;#34;: null,
      &amp;#34;SSECustomerAlgorithm&amp;#34;: null,
      &amp;#34;SSECustomerKeyMD5&amp;#34;: null,
      &amp;#34;SSEKMSKeyId&amp;#34;: null,
      &amp;#34;ServerSideEncryption&amp;#34;: null,
      &amp;#34;StorageClass&amp;#34;: null,
      &amp;#34;VersionId&amp;#34;: null,
      &amp;#34;WebsiteRedirectLocation&amp;#34;: null
    },
    &amp;#34;URL&amp;#34;: &amp;#34;https://somebucket-log.s3-us-west-2.amazonaws.com/gopher.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Credential=ASIAJ5KB2P6SQ4E7IMMQ%2F20151206%2Fus-west-2%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20151206T023503Z&amp;amp;X-Amz-Expires=300&amp;amp;X-Amz-Security-Token=AQoDYXdzEFQawAK7vrGb%2BH9lw%2FhEHpR9Yg1KwPmmFcvyMzF7ewFBmxpOkfEM7gLZirMcFFexcxpWv%2F5CVAxpqjRf5FznOYJZHHoBqgmUcKPQZOpYKSbQG768zH5gMNdOANWin1COZU8DyuABrkJYL1bdFpwV7oHgrDmRz2G6oZqqOnfesRHW8WcehSXMV%2BcQFaAcO7IaIMAkRINMIDfxQaa%2FP8i8dbrcOfsEy6UABeaLKL3YgdZIouxcUUKzXQ6Pr4Cgrf0TAyRDAO1t6bVXzv6UFa6j00%2Fm0PYElni7xs5844UFAav%2B1weO2kX65ETzwUxBacAAnuzt%2BmTVPWeikhzgRnjBFn8mQjkZLCJklJJb6QHBO8dph2CSQsh47yw7%2BnexGjAu1y106AA2%2Bfa0WFYC552Q%2FrVVhKU7dejy%2B3jz%2F4LyWdnva9IvmCDVvY6zBQ%3D%3D&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Signature=7d0e6663e043317b5611ddf4ae9f7514aff8c484a31deba524906ba50cbc6a2f&amp;#34;
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;Please see the &lt;a href=&#34;http://gosparta.io/docs/apigateway/example1&#34;&gt;first example&lt;/a&gt; for more information on the &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt;, and &lt;code&gt;headers&lt;/code&gt; keys.&lt;/p&gt;

&lt;p&gt;What about an item that we know doesn&amp;rsquo;t exist, but is in the bucket our lambda function has privileges to access:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;curl -vs &amp;#34;https://0ux556ho77.execute-api.us-west-2.amazonaws.com/v1/info?keyName=gopher42.png&amp;amp;bucketName=somebucket-log&amp;#34;

*   Trying 54.230.71.213...
* Connected to 0ux556ho77.execute-api.us-west-2.amazonaws.com (54.230.71.213) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate: *.execute-api.us-west-2.amazonaws.com
* Server certificate: Symantec Class 3 Secure Server CA - G4
* Server certificate: VeriSign Class 3 Public Primary Certification Authority - G5
&amp;gt; GET /v1/info?keyName=gopher42.png&amp;amp;bucketName=somebucket-log HTTP/1.1
&amp;gt; Host: 0ux556ho77.execute-api.us-west-2.amazonaws.com
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 500 Internal Server Error
&amp;lt; Content-Type: application/json
&amp;lt; Content-Length: 524
&amp;lt; Connection: keep-alive
&amp;lt; Date: Sun, 06 Dec 2015 02:40:14 GMT
&amp;lt; x-amzn-RequestId: ad5d94eb-9bc2-11e5-8fad-476a6cacabce
&amp;lt; X-Cache: Error from cloudfront
&amp;lt; Via: 1.1 29bfa9b96f4ea66dc02526ee845ca6b0.cloudfront.net (CloudFront)
&amp;lt; X-Amz-Cf-Id: XoVLBjm1dgozZsNAEGk8Vy_a5PXMYNWRD6eKJJBcVTXrtMgMhiLNyQ==
&amp;lt;
* Connection #0 to host 0ux556ho77.execute-api.us-west-2.amazonaws.com left intact
{&amp;#34;errorMessage&amp;#34;:&amp;#34;{\&amp;#34;code\&amp;#34;:500,\&amp;#34;status\&amp;#34;:\&amp;#34;Internal Server Error\&amp;#34;,\&amp;#34;headers\&amp;#34;:{\&amp;#34;content-type\&amp;#34;:\&amp;#34;text/plain; charset=utf-8\&amp;#34;,\&amp;#34;x-content-type-options\&amp;#34;:\&amp;#34;nosniff\&amp;#34;,\&amp;#34;date\&amp;#34;:\&amp;#34;Sun, 06 Dec 2015 02:40:14 GMT\&amp;#34;,\&amp;#34;content-length\&amp;#34;:\&amp;#34;60\&amp;#34;},\&amp;#34;error\&amp;#34;:\&amp;#34;AccessDenied: Access Denied\\n\\tstatus code: 403, request id: \\n\&amp;#34;}&amp;#34;,&amp;#34;errorType&amp;#34;:&amp;#34;Error&amp;#34;,&amp;#34;stackTrace&amp;#34;:[&amp;#34;IncomingMessage.&amp;lt;anonymous&amp;gt; (/var/task/index.js:68:53)&amp;#34;,&amp;#34;IncomingMessage.emit (events.js:117:20)&amp;#34;,&amp;#34;_stream_readable.js:944:16&amp;#34;,&amp;#34;process._tickCallback (node.js:442:13)&amp;#34;]}&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;p&gt;And finally, what if we try to access a bucket that our lambda function isn&amp;rsquo;t authorized to access:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;curl -vs &amp;#34;https://0ux556ho77.execute-api.us-west-2.amazonaws.com/v1/info?keyName=gopher.png&amp;amp;bucketName=weagle&amp;#34;

*   Trying 54.192.70.129...
* Connected to 0ux556ho77.execute-api.us-west-2.amazonaws.com (54.192.70.129) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate: *.execute-api.us-west-2.amazonaws.com
* Server certificate: Symantec Class 3 Secure Server CA - G4
* Server certificate: VeriSign Class 3 Public Primary Certification Authority - G5
&amp;gt; GET /v1/info?keyName=gopher.png&amp;amp;bucketName=weagle HTTP/1.1
&amp;gt; Host: 0ux556ho77.execute-api.us-west-2.amazonaws.com
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 500 Internal Server Error
&amp;lt; Content-Type: application/json
&amp;lt; Content-Length: 524
&amp;lt; Connection: keep-alive
&amp;lt; Date: Sun, 06 Dec 2015 02:42:52 GMT
&amp;lt; x-amzn-RequestId: 0be0fc4f-9bc3-11e5-b827-81d99c02192f
&amp;lt; X-Cache: Error from cloudfront
&amp;lt; Via: 1.1 400bdbea4e851ce61e7df8252da93d3f.cloudfront.net (CloudFront)
&amp;lt; X-Amz-Cf-Id: M_7pB1UsW63xzh_9g37-CqNYDXfXlec0B6DV4bdkq3tbCANCOrTY6Q==
&amp;lt;
* Connection #0 to host 0ux556ho77.execute-api.us-west-2.amazonaws.com left intact
{&amp;#34;errorMessage&amp;#34;:&amp;#34;{\&amp;#34;code\&amp;#34;:500,\&amp;#34;status\&amp;#34;:\&amp;#34;Internal Server Error\&amp;#34;,\&amp;#34;headers\&amp;#34;:{\&amp;#34;content-type\&amp;#34;:\&amp;#34;text/plain; charset=utf-8\&amp;#34;,\&amp;#34;x-content-type-options\&amp;#34;:\&amp;#34;nosniff\&amp;#34;,\&amp;#34;date\&amp;#34;:\&amp;#34;Sun, 06 Dec 2015 02:42:52 GMT\&amp;#34;,\&amp;#34;content-length\&amp;#34;:\&amp;#34;60\&amp;#34;},\&amp;#34;error\&amp;#34;:\&amp;#34;AccessDenied: Access Denied\\n\\tstatus code: 403, request id: \\n\&amp;#34;}&amp;#34;,&amp;#34;errorType&amp;#34;:&amp;#34;Error&amp;#34;,&amp;#34;stackTrace&amp;#34;:[&amp;#34;IncomingMessage.&amp;lt;anonymous&amp;gt; (/var/task/index.js:68:53)&amp;#34;,&amp;#34;IncomingMessage.emit (events.js:117:20)&amp;#34;,&amp;#34;_stream_readable.js:944:16&amp;#34;,&amp;#34;process._tickCallback (node.js:442:13)&amp;#34;]}&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h1 id=&#34;cleaning-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Cleaning Up&lt;/h1&gt;

&lt;p&gt;Before moving on, remember to decommission the service via:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;go run application.go delete&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h1 id=&#34;wrapping-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;With this example we&amp;rsquo;ve walked through a simple example that whitelists user input, uses IAM Roles to limit what S3 buckets a lambda function may access, and returns JSON data to the caller.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Command Line Options</title>
      <link>http://gosparta.io/docs/commandline/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/commandline/</guid>
      <description>

&lt;p&gt;Sparta provides a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Main&#34;&gt;Main&lt;/a&gt; function that transforms a set of &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;lambda functions&lt;/a&gt; into an application.  This function should be called from your application&amp;rsquo;s &lt;code&gt;package main&lt;/code&gt; as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;sparta.Main(&amp;#34;MyStack&amp;#34;,
  &amp;#34;Simple Sparta application&amp;#34;,
  myLambdaFunctions,
  nil,
  nil)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The application provides several command line options which are available by providing the &lt;code&gt;-h/--help&lt;/code&gt; option as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;go run application.go --help
Usage: application [global options] &amp;lt;verb&amp;gt; [verb options]

Global options:
        -n, --noop     Dry-run behavior only (do not provision stack)
        -l, --level    Log level [panic, fatal, error, warn, info, debug] (default: info)
        -h, --help     Show this help

Verbs:
    delete:
    describe:
        -o, --out      Output file for HTML description (*)
    execute:
        -p, --port     Alternative port for HTTP binding (default=9999)
        -s, --signal   Process ID to signal with SIGUSR2 once ready
    explore:
        -p, --port     Alternative port for HTTP binding (default=9999)
    provision:
        -b, --s3Bucket S3 Bucket to use for Lambda source (*)&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;delete:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Delete&lt;/h1&gt;

&lt;p&gt;This simply deletes the stack (if present). Attempting to delete a non-empty stack is not treated as an error.&lt;/p&gt;

&lt;h1 id=&#34;describe:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Describe&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;describe&lt;/code&gt; command line option produces an HTML summary (see &lt;a href=&#34;http://gosparta.io/images/overview/graph.html&#34;&gt;graph.html&lt;/a&gt; for an example) of your Sparta service.&lt;/p&gt;

&lt;p&gt;The report also includes the automatically generated CloudFormation template which can be helpful when diagnosing provisioning errors.&lt;/p&gt;

&lt;h1 id=&#34;execute:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Execute&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;execute&lt;/code&gt; option is typically used when the compiled application is launched in the AWS Lambda environment.  It starts up an HTTP listener to which the NodeJS proxing tier forwards requests.&lt;/p&gt;

&lt;h1 id=&#34;explore:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Explore&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;explore&lt;/code&gt; option creates a &lt;em&gt;localhost&lt;/em&gt; server to allow Sparta lambda functions to be tested locally.&lt;/p&gt;

&lt;p&gt;NOTE: API Gateway mapping templates are not currently supported.&lt;/p&gt;

&lt;h1 id=&#34;provision:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Provision&lt;/h1&gt;

&lt;p&gt;The &lt;code&gt;provision&lt;/code&gt; option is the verb most likely to be used during development.  It provisions the Sparta application to AWS Lambda.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom Resources</title>
      <link>http://gosparta.io/docs/custom_resources/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/custom_resources/</guid>
      <description>

&lt;h1 id=&#34;introduction:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;In some circumstances your service may need to provision or access resources that fall outside the standard workflow.  In this case you can use &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources-lambda.html&#34;&gt;CloudFormation Lambda-backed CustomResources&lt;/a&gt; to create or access resources during your CloudFormation stack&amp;rsquo;s lifecycle.&lt;/p&gt;

&lt;p&gt;Sparta provides unchecked access to the CloudFormation resource lifecycle via the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo.RequireCustomResource&#34;&gt;RequireCustomResource&lt;/a&gt; function.  This function registers a user-supplied &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CustomResourceFunction&#34;&gt;CustomResourceFunction&lt;/a&gt; with the larger CloudFormation resource &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-requesttypes.html&#34;&gt;lifecycle&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this section we&amp;rsquo;ll walk through a sample user-defined custom resource and discuss how a custom resource&amp;rsquo;s outputs can be propagated to an application-level Sparta lambda function.&lt;/p&gt;

&lt;h2 id=&#34;components:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Components&lt;/h2&gt;

&lt;p&gt;Defining a custom resource is a two stage process, depending on whether your application-level lambda function requires access to the custom resource outputs:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The user-defined &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CustomResourceFunction&#34;&gt;CustomResourceFunction&lt;/a&gt; instance

&lt;ul&gt;
&lt;li&gt;This function defines your resource&amp;rsquo;s logic.  The multiple return value is &lt;code&gt;map[string]interface{}, error&lt;/code&gt; which signify resource results and operation error, respectively.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;LambdaAWSInfo&lt;/code&gt; struct which declares a dependency on your custom resource via the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo.RequireCustomResource&#34;&gt;RequireCustomResource&lt;/a&gt; member function.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Optional&lt;/em&gt; - The template decorator that binds your CustomResource&amp;rsquo;s &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html&#34;&gt;data results&lt;/a&gt; to the owning &lt;code&gt;LambdaAWSInfo&lt;/code&gt; caller.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Optional&lt;/em&gt; - A call from your standard Lambda&amp;rsquo;s function body to discover the CustomResource outputs via &lt;code&gt;sparta.Discover()&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;customresourcefunction:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;CustomResourceFunction&lt;/h3&gt;

&lt;p&gt;This is the core of your custom resource&amp;rsquo;s logic and is executed in a manner similar to standard Sparta functions.  The primary difference is the function signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type CustomResourceFunction func(requestType string
                                 stackID string
                                 properties map[string]interface{}
                                 logger *logrus.Logger) (map[string]interface{}, error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;requestType&lt;/code&gt;: The CustomResource &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-requests.html&#34;&gt;operation type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stackID&lt;/code&gt; : The current stack being operated on.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;properties&lt;/code&gt;: User-defined properties provided to &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo.RequireCustomResource&#34;&gt;RequireCustomResource&lt;/a&gt; (see below).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logger&lt;/code&gt; : Preconfigured logger instance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The multiple return values denote success with non-empty results, or an error.&lt;/p&gt;

&lt;p&gt;As an example, we&amp;rsquo;ll use the following custom resource function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// User defined -backed CloudFormation CustomResource
func userDefinedCustomResource(requestType string,
	stackID string,
	properties map[string]interface{},
	logger *logrus.Logger) (map[string]interface{}, error) {

	var results = map[string]interface{}{
		&amp;quot;CustomResourceResult&amp;quot;: &amp;quot;Victory!&amp;quot;,
	}
	return results, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function always succeeds and returns a non-empty results map consisting of a single key (&lt;code&gt;CustomResourceResult&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;requirecustomresource:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;RequireCustomResource&lt;/h3&gt;

&lt;p&gt;The next step is to associate this custom resource function with a previously created Sparta &lt;code&gt;LambdaAWSInfo&lt;/code&gt; instance via &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo.RequireCustomResource&#34;&gt;RequireCustomResource&lt;/a&gt;.  This function accepts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;roleNameOrIAMRoleDefinition&lt;/code&gt;: The IAM role name or definition under which the custom resource function should be executed. Equivalent to the same argument in &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#NewLambda&#34;&gt;NewLambda&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;userFunc&lt;/code&gt;: Custom resource function pointer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lambdaOptions&lt;/code&gt;: Lambda execution options. Equivalent to the same argument in &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#NewLambda&#34;&gt;NewLambda&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resourceProps&lt;/code&gt;: Arbitrary, optional properties that will be provided to the &lt;code&gt;userFunc&lt;/code&gt; during execution.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The multiple return values denote the logical, stable CloudFormation resource ID of the new custom resource, or an error if one occurred.&lt;/p&gt;

&lt;p&gt;For example, our custom resource function above can be associated via:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Standard AWS  function
func helloWorld(event *json.RawMessage,
	context *LambdaContext,
	w http.ResponseWriter,
	logger *logrus.Logger) {

	configuration, _ := Discover()

	logger.WithFields(logrus.Fields{
		&amp;quot;Discovery&amp;quot;: configuration,
	}).Info(&amp;quot;Custom resource request&amp;quot;)

	fmt.Fprint(w, &amp;quot;Hello World&amp;quot;)
}

func ExampleLambdaAWSInfo_RequireCustomResource() {

	lambdaFn := NewLambda(IAMRoleDefinition{},
		helloWorld,
		nil)

	cfResName, _ := lambdaFn.RequireCustomResource(IAMRoleDefinition{},
		userDefinedCustomResource,
		nil,
		nil)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since our custom resource function doesn&amp;rsquo;t require any additional AWS resources, we provide an empty &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#IAMRoleDefinition&#34;&gt;IAMRoleDefinition&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;These two steps are sufficient to include your custom resource function in the CloudFormation stack lifecycle.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s possible to share state from the custom resource to a standard Sparta lambda function by annotating your Sparta lambda function&amp;rsquo;s metadata and then discovering it at execution time.&lt;/p&gt;

&lt;h3 id=&#34;optional-template-decorator:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Optional - Template Decorator&lt;/h3&gt;

&lt;p&gt;To link these resources together, the first step is to include a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#TemplateDecorator&#34;&gt;TemplateDecorator&lt;/a&gt; that annotates your Sparta lambda function&amp;rsquo;s CloudFormation resource metadata.  This function specifies which user defined output keys (&lt;code&gt;CustomResourceResult&lt;/code&gt; in this example) you wish to make available during your lambda function&amp;rsquo;s execution.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lambdaFn.Decorator = func(lambdaResourceName string,
  lambdaResource gocf.LambdaFunction,
  resourceMetadata map[string]interface{},
  template *gocf.Template,
  logger *logrus.Logger) error {

  // Pass CustomResource outputs to the  function
  resourceMetadata[&amp;quot;CustomResource&amp;quot;] = gocf.GetAtt(cfResName, &amp;quot;CustomResourceResult&amp;quot;)
  return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;cfResName&lt;/code&gt; value is the CloudFormation resource name returned by &lt;code&gt;RequireCustomResource&lt;/code&gt;.  The template decorator specifies which of your &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CustomResourceFunction&#34;&gt;CustomResourceFunction&lt;/a&gt; outputs should be discoverable during the paren&amp;rsquo;t lambda functions execution time through a &lt;a href=&#34;https://godoc.org/github.com/crewjam/go-cloudformation#GetAtt&#34;&gt;go-cloudformation&lt;/a&gt; version of &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-getatt.html&#34;&gt;Fn::GetAtt&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;optional-discovery:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Optional - Discovery&lt;/h3&gt;

&lt;p&gt;Discovery is handled by &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Discover&#34;&gt;sparta.Discover()&lt;/a&gt; which returns a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#DiscoveryInfo&#34;&gt;DiscoveryInfo&lt;/a&gt; instance pointer containing the linked Custom Resource outputs.  The calling Sparta lambda function can discover its own &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#DiscoveryResource&#34;&gt;DiscoveryResource&lt;/a&gt; keyname via the top-level &lt;code&gt;ResourceID&lt;/code&gt; field. Once found, the calling function then looks up the linked custom resource output via the &lt;code&gt;Properties&lt;/code&gt; field using the keyname  (&lt;code&gt;CustomResource&lt;/code&gt;) provided in the previous template decorator.&lt;/p&gt;

&lt;p&gt;In this example, the unmarshalled &lt;em&gt;DiscoveryInfo&lt;/em&gt; struct looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;Discovery&amp;quot;: {
    &amp;quot;ResourceID&amp;quot;: &amp;quot;mainhelloWorldLambda837e49c53be175a0f75018a148ab6cd22841cbfb&amp;quot;,
    &amp;quot;Region&amp;quot;: &amp;quot;us-west-2&amp;quot;,
    &amp;quot;StackID&amp;quot;: &amp;quot;arn:aws:cloudformation:us-west-2:123412341234:stack/SpartaHelloWorld/70b28170-13f9-11e6-b0c7-50d5ca11b8d2&amp;quot;,
    &amp;quot;StackName&amp;quot;: &amp;quot;SpartaHelloWorld&amp;quot;,
    &amp;quot;Resources&amp;quot;: {
      &amp;quot;mainhelloWorldLambda837e49c53be175a0f75018a148ab6cd22841cbfb&amp;quot;: {
          &amp;quot;ResourceID&amp;quot;: &amp;quot;mainhelloWorldLambda837e49c53be175a0f75018a148ab6cd22841cbfb&amp;quot;,
          &amp;quot;Properties&amp;quot;: {
            &amp;quot;CustomResource&amp;quot;: &amp;quot;Victory!&amp;quot;
          },
          &amp;quot;Tags&amp;quot;: {}
      }
    }
  },
  &amp;quot;level&amp;quot;: &amp;quot;info&amp;quot;,
  &amp;quot;msg&amp;quot;: &amp;quot;Custom resource request&amp;quot;,
  &amp;quot;time&amp;quot;: &amp;quot;2016-05-07T14:13:37Z&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To lookup the output, the calling function might do something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;configuration, _ := sparta.Discover()
customResult := configuration.Resources[configuration.ResourceID].Properties[&amp;quot;CustomResourceResult&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wrapping-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;CloudFormation Custom Resources are a powerful tool that can help pre-existing applications migrate to a Sparta application.&lt;/p&gt;

&lt;h1 id=&#34;notes:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Notes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Sparta uses &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources-lambda.html&#34;&gt;Lambda-backed CustomResource&lt;/a&gt; functions, so they are subject to the same &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/limits.html&#34;&gt;Lambda limits&lt;/a&gt; as application-level Sparta lambda functions.&lt;/li&gt;
&lt;li&gt;Returning an error from the CustomResourceFunction will result in a &lt;em&gt;FAILED&lt;/em&gt; reason being returned in the CloudFormation &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref-responses.html&#34;&gt;response object&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Discovery Service</title>
      <link>http://gosparta.io/docs/discovery/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/discovery/</guid>
      <description>

&lt;h1 id=&#34;introduction:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;The ability to provision &lt;a href=&#34;http://gosparta.io/docs/dynamic_infrastructure&#34;&gt;dynamic infrastructure&lt;/a&gt; (see also the &lt;a href=&#34;http://gosparta.io/docs/eventsources/ses/#dynamic-resources:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;SES Event Source Example&lt;/a&gt;) as part of a Sparta application creates a need to discover those resources at lambda execution time.&lt;/p&gt;

&lt;p&gt;Sparta exposes this functionality via &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Discover&#34;&gt;sparta.Discover&lt;/a&gt;.  This function returns information about the current stack (eg, name, region, ID) as well as metadata about the immediate dependencies of the calling &lt;strong&gt;Go&lt;/strong&gt; lambda function.&lt;/p&gt;

&lt;p&gt;The following sections walk through provisioning a S3 bucket, declaring an explicit dependency on that resource, and then discovering the resource at lambda execution time.  It is extracted from &lt;code&gt;appendDynamicS3BucketLambda&lt;/code&gt; in the  &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go&#34;&gt;SpartaApplication&lt;/a&gt; source.&lt;/p&gt;

&lt;p&gt;If you haven&amp;rsquo;t already done so, please review the &lt;a href=&#34;http://gosparta.io/docs/dynamic_infrastructure&#34;&gt;Dynamic Infrastructure&lt;/a&gt; section for background on dynamic infrastructure provisioning.&lt;/p&gt;

&lt;h1 id=&#34;discovery:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Discovery&lt;/h1&gt;

&lt;p&gt;For reference, we provision an S3 bucket and declare an explicit dependency with the code below.  Because our &lt;code&gt;gocf.S3Bucket{}&lt;/code&gt; struct uses a zero-length &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket.html#cfn-s3-bucket-name&#34;&gt;BucketName&lt;/a&gt; property, CloudFormation will dynamically assign one.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s3BucketResourceName := sparta.CloudFormationResourceName(&amp;quot;S3DynamicBucket&amp;quot;)

lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoS3DynamicBucketEvent, nil)
lambdaFn.Permissions = append(lambdaFn.Permissions, sparta.S3Permission{
  BasePermission: sparta.BasePermission{
    SourceArn: gocf.Ref(s3BucketResourceName),
  },
  Events: []string{&amp;quot;s3:ObjectCreated:*&amp;quot;,
                    &amp;quot;s3:ObjectRemoved:*&amp;quot;},
})

lambdaFn.DependsOn = append(lambdaFn.DependsOn, s3BucketResourceName)

// Add permission s.t. the lambda function could read from the S3 bucket
lambdaFn.RoleDefinition.Privileges = append(lambdaFn.RoleDefinition.Privileges,
  sparta.IAMRolePrivilege{
    Actions:  []string{&amp;quot;s3:GetObject&amp;quot;,
                       &amp;quot;s3:HeadObject&amp;quot;},
    Resource: spartaCF.S3AllKeysArnForBucket(gocf.Ref(s3BucketResourceName)),
  })

// Add the S3 resource to our template
lambdaFn.Decorator = func(lambdaResourceName string,
  lambdaResource gocf.LambdaFunction,
  template *gocf.Template,
  logger *logrus.Logger) error {
  cfResource := template.AddResource(s3BucketResourceName, &amp;amp;gocf.S3Bucket{
    AccessControl: gocf.String(&amp;quot;PublicRead&amp;quot;),
  })
  cfResource.DeletionPolicy = &amp;quot;Delete&amp;quot;
  return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The key to &lt;code&gt;sparta.Discovery&lt;/code&gt; is the &lt;code&gt;DependsOn&lt;/code&gt; slice value.&lt;/p&gt;

&lt;h1 id=&#34;template-marshaling-decoration:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Template Marshaling &amp;amp; Decoration&lt;/h1&gt;

&lt;p&gt;Sparta only uses CloudFormation to update service state.  Each CloudFormation resource may be annotated with a &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-metadata.html&#34;&gt;Metadata&lt;/a&gt; property.  This is unstructured, application-defined data.&lt;/p&gt;

&lt;p&gt;During template marshaling, Sparta scans for &lt;code&gt;DependsOn&lt;/code&gt; relationships and propagates information (immediate-children only) across CloudFormation resource definitions.  Most importantly, this information includes &lt;code&gt;Ref&lt;/code&gt; and any other &lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/cloudformation_resources.go#L24&#34;&gt;outputs&lt;/a&gt; of referred resources.  This information then becomes available as a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#DiscoveryInfo&#34;&gt;DisocveryInfo&lt;/a&gt; value returned by &lt;code&gt;sparta.Discovery()&lt;/code&gt;.&lt;/p&gt;

&lt;h1 id=&#34;sample-discoveryinfo:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Sample DiscoveryInfo&lt;/h1&gt;

&lt;p&gt;In our example, a &lt;code&gt;DiscoveryInfo&lt;/code&gt; from a sample stack might be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;Region&amp;quot;: &amp;quot;us-west-2&amp;quot;,
  &amp;quot;StackID&amp;quot;: &amp;quot;arn:aws:cloudformation:us-west-2:123412341234:stack/SpartaApplication/d87bb070-cce5-11e5-b6ca-503f20f2ad1e&amp;quot;,
  &amp;quot;StackName&amp;quot;: &amp;quot;SpartaApplication&amp;quot;,
  &amp;quot;Resources&amp;quot;: {
    &amp;quot;S3DynamicBucketa3c3daf5543fe6879721e6bb0bc129042459be6b&amp;quot;: {
      &amp;quot;ResourceID&amp;quot;: &amp;quot;S3DynamicBucketa3c3daf5543fe6879721e6bb0bc129042459be6b&amp;quot;,
      &amp;quot;Properties&amp;quot;: {
        &amp;quot;DomainName&amp;quot;: &amp;quot;spartaapplication-s3dynamicbucketa3c3daf5543fe687-1avr6h3lrprju.s3.amazonaws.com&amp;quot;,
        &amp;quot;Ref&amp;quot;: &amp;quot;spartaapplication-s3dynamicbucketa3c3daf5543fe687-1avr6h3lrprju&amp;quot;,
        &amp;quot;WebsiteURL&amp;quot;: &amp;quot;http://spartaapplication-s3dynamicbucketa3c3daf5543fe687-1avr6h3lrprju.s3-website-us-west-2.amazonaws.com&amp;quot;,
        &amp;quot;sparta:cloudformation:restype&amp;quot;: &amp;quot;AWS::S3::Bucket&amp;quot;
      },
      &amp;quot;Tags&amp;quot;: {}
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this, our lambda function can discover the dynamically assigned bucket name using non-production ready code similar to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;configuration, _ := sparta.Discover()
bucketName := &amp;quot;&amp;quot;
for _, eachResource := range configuration.Resources {
  if eachResource.Properties[sparta.TagResourceType] == &amp;quot;AWS::S3::Bucket&amp;quot; {
    bucketName = eachResource.Properties[&amp;quot;Ref&amp;quot;]
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Properties&lt;/code&gt; map includes the CloudFormation &lt;code&gt;Ref&lt;/code&gt; and other outputs (see each resource type&amp;rsquo;s &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html&#34;&gt;documentation&lt;/a&gt; for the complete set) as well as the actual resource type (keyed by &lt;code&gt;sparta.TagResourceType&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Multiple dependencies can be disambiguated by annotating the CloudFormation resource&amp;rsquo;s &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html&#34;&gt;Tags&lt;/a&gt; slice.  Tag key-values are published as a key-value map as part of each &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#DiscoveryResource&#34;&gt;DiscoveryResource&lt;/a&gt;.  For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;cfResource := template.AddResource(s3BucketResourceName, &amp;amp;gocf.S3Bucket{
  AccessControl: gocf.String(&amp;quot;PublicRead&amp;quot;),
  Tags: []gocf.ResourceTag{
    gocf.ResourceTag{
      Key:   gocf.String(&amp;quot;SomeUserKey&amp;quot;),
      Value: gocf.String(&amp;quot;MyMagicValue&amp;quot;),
    },
  },
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;special-considerations:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Special Considerations&lt;/h1&gt;

&lt;p&gt;You may have noticed that &lt;code&gt;sparta.Discover()&lt;/code&gt; doesn&amp;rsquo;t accept any parameters.  Sparta distinguishes different invocations by using the enclosing Sparta-compliant &lt;strong&gt;Go&lt;/strong&gt; function name.  This name is discovered by reflection, which creates a 1-to-1 mapping with &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;LambdaAWSInfo&lt;/a&gt; values and enables unique discovery.&lt;/p&gt;

&lt;h1 id=&#34;wrapping-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;Combined with &lt;a href=&#34;http://gosparta.io/docs/dynamic_infrastructure&#34;&gt;dynamic infrastructure&lt;/a&gt;, &lt;code&gt;sparta.Discover()&lt;/code&gt; enables a Sparta service to define its entire AWS infrastructure requirements.  Coupling application logic with infrastructure requirements moves a service towards being completely self-contained and in the direction of &lt;a href=&#34;https://fugue.co/oreilly/&#34;&gt;immutable infrastructure&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;notes:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Notes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sparta.Discovery()&lt;/code&gt; &lt;strong&gt;only&lt;/strong&gt; succeeds within a Sparta-compliant lambda function call block.

&lt;ul&gt;
&lt;li&gt;Call-site restrictions are validated in the &lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/discovery_test.go&#34;&gt;discovery_tests.go&lt;/a&gt; tests.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Infrastructure</title>
      <link>http://gosparta.io/docs/dynamic_infrastructure/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/dynamic_infrastructure/</guid>
      <description>

&lt;h1 id=&#34;introduction:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;In addition to provisioning AWS Lambda functions, Sparta supports the creation of other &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html&#34;&gt;CloudFormation Resources&lt;/a&gt;.  This enables a service to move towards &lt;a href=&#34;https://fugue.co/oreilly/&#34;&gt;immutable infrastructure&lt;/a&gt;, where the service and its infrastructure requirements are treated as a logical unit.&lt;/p&gt;

&lt;p&gt;For instance, consider the case where two developers are working in the same AWS account.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Developer 1 is working on analyzing text documents.&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Their lambda code is triggered in response to uploading sample text documents to S3.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Developer 2 is working on image recognition.&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;Their lambda code is triggered in response to uploading sample images to S3.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;mermaid&#34;&gt;
    
graph LR
  sharedBucket[S3 Bucket]

  dev1Lambda[Dev1 LambdaCode]
  dev2Lambda[Dev2 LambdaCode]

  sharedBucket --&gt; dev1Lambda
  sharedBucket --&gt; dev2Lambda

&lt;/div&gt;
&lt;i&gt;&lt;small&gt;This diagram is rendered with &lt;a href=&#34;https://github.com/knsv/mermaid&#34; target=&#34;_blank&#34;&gt;Mermaid&lt;/a&gt;.
  Please open an &lt;a href=&#34;https://github.com/mweagle/Sparta/issues/new&#34; target=&#34;_blank&#34;&gt;issue&lt;/a&gt;
  if it doesn&#39;t render properly.&lt;/small&gt;&lt;/i&gt;
&lt;hr /&gt;


&lt;p&gt;Using a shared, externally provisioned S3 bucket has several impacts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Adding conditionals in each lambda codebase to scope valid processing targets.&lt;/li&gt;
&lt;li&gt;Ambiguity regarding which codebase handled an event.&lt;/li&gt;
&lt;li&gt;Infrastructure ownership/lifespan management.  When a service is decommissioned, its infrastructure requirements may be automatically decommissioned as well.

&lt;ul&gt;
&lt;li&gt;Eg, &amp;ldquo;Is this S3 bucket in use by any service?&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Overly permissive IAM roles due to static Arns.

&lt;ul&gt;
&lt;li&gt;Eg, &amp;ldquo;Arn hugging&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Contention updating the shared bucket&amp;rsquo;s &lt;a href=&#34;http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/S3.html#putBucketNotificationConfiguration-property&#34;&gt;notification configuration&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Alternatively, each developer could provision and manage disjoint topologies:&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
    
graph LR
  dev1S3Bucket[Dev1 S3 Bucket]
  dev1Lambda[Dev1 LambdaCode]

  dev2S3Bucket[Dev2 S3 Bucket]
  dev2Lambda[Dev2 LambdaCode]

  dev1S3Bucket --&gt; dev1Lambda
  dev2S3Bucket --&gt; dev2Lambda

&lt;/div&gt;
&lt;i&gt;&lt;small&gt;This diagram is rendered with &lt;a href=&#34;https://github.com/knsv/mermaid&#34; target=&#34;_blank&#34;&gt;Mermaid&lt;/a&gt;.
  Please open an &lt;a href=&#34;https://github.com/mweagle/Sparta/issues/new&#34; target=&#34;_blank&#34;&gt;issue&lt;/a&gt;
  if it doesn&#39;t render properly.&lt;/small&gt;&lt;/i&gt;
&lt;hr /&gt;


&lt;p&gt;Enabling each developer to create other AWS resources also means more complex topologies can be expressed.  These topologies can benefit from CloudWatch monitoring (eg, &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/monitoring-functions-metrics.html&#34;&gt;per-Lambda Metrics&lt;/a&gt; ) without the need to add &lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/publishingMetrics.html&#34;&gt;custom metrics&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
    
graph LR
  dev1S3Bucket[Dev1 S3 Bucket]
  dev1Lambda[Dev1 LambdaCode]

  dev2S3Bucket[Dev2 S3 Images Bucket]
  dev2PNGLambda[Dev2 PNG LambdaCode]
  dev2JPGLambda[Dev2 JPEG LambdaCode]
  dev2TIFFLambda[Dev2 TIFF LambdaCode]
  dev2S3VideoBucket[Dev2 VideoBucket]
  dev2VideoLambda[Dev2 Video LambdaCode]

  dev1S3Bucket --&gt; dev1Lambda
  dev2S3Bucket --&gt;|SuffixFilter=*.PNG|dev2PNGLambda
  dev2S3Bucket --&gt;|SuffixFilter=*.JPEG,*.JPG|dev2JPGLambda
  dev2S3Bucket --&gt;|SuffixFilter=*.TIFF|dev2TIFFLambda
  dev2S3VideoBucket --&gt;dev2VideoLambda

&lt;/div&gt;
&lt;i&gt;&lt;small&gt;This diagram is rendered with &lt;a href=&#34;https://github.com/knsv/mermaid&#34; target=&#34;_blank&#34;&gt;Mermaid&lt;/a&gt;.
  Please open an &lt;a href=&#34;https://github.com/mweagle/Sparta/issues/new&#34; target=&#34;_blank&#34;&gt;issue&lt;/a&gt;
  if it doesn&#39;t render properly.&lt;/small&gt;&lt;/i&gt;
&lt;hr /&gt;


&lt;p&gt;Sparta supports Dynamic Resources via &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#TemplateDecorator&#34;&gt;TemplateDecorator&lt;/a&gt; functions.&lt;/p&gt;

&lt;h1 id=&#34;template-decorators:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Template Decorators&lt;/h1&gt;

&lt;p&gt;A template decorator is a &lt;strong&gt;Go&lt;/strong&gt; function with the following signature&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type TemplateDecorator func(lambdaResourceName string,
                            lambdaResource gocf.LambdaFunction,
                            template *gocf.Template,
                            logger *logrus.Logger) error {

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Clients use &lt;a href=&#34;https://godoc.org/github.com/crewjam/go-cloudformation&#34;&gt;go-cloudformation&lt;/a&gt; types for CloudFormation resources and  &lt;code&gt;template.AddResource&lt;/code&gt; to add them to the &lt;code&gt;*template&lt;/code&gt; parameter.  After a decorator is invoked, Sparta verifies that the user-supplied function has not produced entities that collide with the internally-generated ones.&lt;/p&gt;

&lt;h2 id=&#34;unique-resource-names:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Unique Resource Names&lt;/h2&gt;

&lt;p&gt;CloudFormation uses &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html&#34;&gt;Logical IDs&lt;/a&gt; as resource key names.&lt;/p&gt;

&lt;p&gt;To minimize collision likelihood, Sparta publishes &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudFormationResourceName&#34;&gt;CloudFormationResourceName(prefix, &amp;hellip;parts)&lt;/a&gt; to generate compliant identifiers.  To produce content-based hash values, callers can provide a non-empty set of values as the &lt;code&gt;...parts&lt;/code&gt; variadic argument.  This produces stable identifiers across Sparta execution (which may affect availability during updates).&lt;/p&gt;

&lt;p&gt;When called with only a single value (eg: &lt;code&gt;CloudFormationResourceName(&amp;quot;myResource&amp;quot;)&lt;/code&gt;), Sparta will return a random resource name that is &lt;strong&gt;NOT&lt;/strong&gt; stable across executions.&lt;/p&gt;

&lt;h1 id=&#34;example-s3-bucket:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Example - S3 Bucket&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s work through an example to make things a bit more concrete.  We have the following requirements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Our lambda function needs a immutable-infrastructure compliant S3 bucket&lt;/li&gt;
&lt;li&gt;Our lambda function should be notified when items are created or deleted from the bucket&lt;/li&gt;
&lt;li&gt;Our lambda function must be able to access the contents in the bucket (not shown below)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;lambda-function:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Lambda Function&lt;/h2&gt;

&lt;p&gt;To start with, we&amp;rsquo;ll need a Sparta lambda function to expose:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func echoS3DynamicBucketEvent(event *json.RawMessage,
  context *sparta.LambdaContext,
  w http.ResponseWriter,
  logger *logrus.Logger) {

  config, _ := sparta.Discover()
  logger.WithFields(logrus.Fields{
    &amp;quot;RequestID&amp;quot;:     context.AWSRequestID,
    &amp;quot;Event&amp;quot;:         string(*event),
    &amp;quot;Configuration&amp;quot;: config,
  }).Info(&amp;quot;Request received&amp;quot;)

  fmt.Fprintf(w, string(*event))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For brevity our demo function doesn&amp;rsquo;t access the S3 bucket objects.  To support that we&amp;rsquo;ll need to discuss the &lt;code&gt;sparta.Discover&lt;/code&gt; function in another &lt;a href=&#34;http://gosparta.io/docs/discovery/&#34;&gt;section&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;s3-resource-name:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;S3 Resource Name&lt;/h2&gt;

&lt;p&gt;The next thing we need is a &lt;em&gt;Logical ID&lt;/em&gt; for our bucket:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s3BucketResourceName := sparta.CloudFormationResourceName(&amp;quot;S3DynamicBucket&amp;quot;, &amp;quot;myServiceBucket&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sparta-integration:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Sparta Integration&lt;/h2&gt;

&lt;p&gt;With these two values we&amp;rsquo;re ready to get started building up the lambda function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoS3DynamicBucketEvent, nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The open issue is how to publish the CloudFormation-defined S3 Arn to the &lt;code&gt;compile&lt;/code&gt;-time application.  Our lambda function needs to provide both:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#IAMRolePrivilege&#34;&gt;IAMRolePrivilege&lt;/a&gt; values that reference the (as yet) undefined Arn.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#S3Permission&#34;&gt;S3Permission&lt;/a&gt; values to configure our lambda&amp;rsquo;s event triggers on the (as yet) undefined Arn.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The missing piece is &lt;a href=&#34;https://godoc.org/github.com/crewjam/go-cloudformation#Ref&#34;&gt;gocf.Ref()&lt;/a&gt;, whose single argument is the &lt;em&gt;Logical ID&lt;/em&gt; of the S3 resource we&amp;rsquo;ll be inserting in the decorator call.&lt;/p&gt;

&lt;h3 id=&#34;dynamic-iam-role-privilege:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Dynamic IAM Role Privilege&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;IAMRolePrivilege&lt;/code&gt; struct references the dynamically assigned S3 Arn as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lambdaFn.Permissions = append(lambdaFn.Permissions, sparta.S3Permission{
  BasePermission: sparta.BasePermission{
    SourceArn: gocf.Ref(s3BucketResourceName),
  },
  Events: []string{&amp;quot;s3:ObjectCreated:*&amp;quot;, &amp;quot;s3:ObjectRemoved:*&amp;quot;},
})
lambdaFn.DependsOn = append(lambdaFn.DependsOn, s3BucketResourceName)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dynamic-s3-permissions:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Dynamic S3 Permissions&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;S3Permission&lt;/code&gt; struct also requires the dynamic Arn, to which it will append &lt;code&gt;&amp;quot;/*&amp;quot;&lt;/code&gt; to enable object read access.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lambdaFn.RoleDefinition.Privileges = append(lambdaFn.RoleDefinition.Privileges,
  sparta.IAMRolePrivilege{
    Actions:  []string{&amp;quot;s3:GetObject&amp;quot;, &amp;quot;s3:HeadObject&amp;quot;},
    Resource: spartaCF.S3AllKeysArnForBucket(gocf.Ref(s3BucketResourceName)),
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;spartaCF.S3AllKeysArnForBucket&lt;/code&gt; call is a convenience wrapper around &lt;a href=&#34;https://godoc.org/github.com/crewjam/go-cloudformation#Join&#34;&gt;gocf.Join&lt;/a&gt; to generate the concatenated, dynamic Arn expression.&lt;/p&gt;

&lt;h2 id=&#34;s3-resource-insertion:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;S3 Resource Insertion&lt;/h2&gt;

&lt;p&gt;All that&amp;rsquo;s left to do is actually insert the S3 resource in our decorator:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lambdaFn.Decorator = func(lambdaResourceName string,
                          lambdaResource gocf.LambdaFunction,
                          template *gocf.Template,
                          logger *logrus.Logger) error {

  cfResource := template.AddResource(s3BucketResourceName, &amp;amp;gocf.S3Bucket{
    AccessControl: gocf.String(&amp;quot;PublicRead&amp;quot;),
  })
  cfResource.DeletionPolicy = &amp;quot;Delete&amp;quot;
  return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dependencies:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Dependencies&lt;/h3&gt;

&lt;p&gt;In reality, we shouldn&amp;rsquo;t even attempt to create the AWS Lambda function if the S3 bucket creation fails.  As application developers, we can help CloudFormation sequence infrastructure operations by stating this hard dependency on the S3 bucket via the &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-dependson.html&#34;&gt;DependsOn&lt;/a&gt; attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;lambdaFn.DependsOn = append(lambdaFn.DependsOn, s3BucketResourceName)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;code-listing:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Code Listing&lt;/h2&gt;

&lt;p&gt;Putting everything together, our Sparta lambda function with dynamic infrastructure is listed below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;s3BucketResourceName := sparta.CloudFormationResourceName(&amp;quot;S3DynamicBucket&amp;quot;)

lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoS3DynamicBucketEvent, nil)

// Our lambda function requires the S3 bucket
lambdaFn.DependsOn = append(lambdaFn.DependsOn, s3BucketResourceName)

// Add a permission s.t. the lambda function could read from the S3 bucket
lambdaFn.RoleDefinition.Privileges = append(lambdaFn.RoleDefinition.Privileges,
  sparta.IAMRolePrivilege{
    Actions:  []string{&amp;quot;s3:GetObject&amp;quot;,
                       &amp;quot;s3:HeadObject&amp;quot;},
    Resource: spartaCF.S3AllKeysArnForBucket(gocf.Ref(s3BucketResourceName)),
  })

// Configure the S3 event source
lambdaFn.Permissions = append(lambdaFn.Permissions, sparta.S3Permission{
  BasePermission: sparta.BasePermission{
    SourceArn: gocf.Ref(s3BucketResourceName),
  },
  Events: []string{&amp;quot;s3:ObjectCreated:*&amp;quot;,
                   &amp;quot;s3:ObjectRemoved:*&amp;quot;},
})

// Actually add the resource
lambdaFn.Decorator = func(lambdaResourceName string,
                          lambdaResource gocf.LambdaFunction,
                          template *gocf.Template,
                          logger *logrus.Logger) error {
  cfResource := template.AddResource(s3BucketResourceName, &amp;amp;gocf.S3Bucket{
    AccessControl: gocf.String(&amp;quot;PublicRead&amp;quot;),
  })
  cfResource.DeletionPolicy = &amp;quot;Delete&amp;quot;
  return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;wrapping-up:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Wrapping Up&lt;/h2&gt;

&lt;p&gt;Sparta provides an opportunity to bring infrastructure management into the application programming model.  It&amp;rsquo;s still possible to use literal Arn strings, but the ability to include other infrastructure requirements brings a service closer to being self-contained and more operationally sustainable.&lt;/p&gt;

&lt;h1 id=&#34;notes:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Notes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;echoS3DynamicBucketEvent&lt;/code&gt; function can also access the bucket Arn via &lt;a href=&#34;http://gosparta.io/docs/discovery&#34;&gt;sparta.Discover&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;See the &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-deletionpolicy.html&#34;&gt;DeletionPolicy&lt;/a&gt; documentation regarding S3 management.&lt;/li&gt;
&lt;li&gt;CloudFormation resources also publish &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-getatt.html&#34;&gt;other outputs&lt;/a&gt; that can be retrieved via &lt;a href=&#34;https://godoc.org/github.com/crewjam/go-cloudformation#GetAtt&#34;&gt;gocf.GetAtt&lt;/a&gt;.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go-cloudformation&lt;/code&gt; exposes &lt;a href=&#34;https://godoc.org/github.com/crewjam/go-cloudformation#Join&#34;&gt;gocf.Join&lt;/a&gt; to create compound, dynamic expressions.

&lt;ul&gt;
&lt;li&gt;See the CloudWatch docs on &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-join.html&#34;&gt;Fn::Join&lt;/a&gt; for more information.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Event Source - CloudFormation</title>
      <link>http://gosparta.io/docs/eventsources/cloudformation/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/cloudformation/</guid>
      <description>&lt;p&gt;&lt;span class=&#34;label label-warning&#34;&gt;NOT YET IMPLEMENTED&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;TODO: CloudFormation source documentation&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>