<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sparta on Sparta</title>
    <link>http://gosparta.io/tags/sparta/</link>
    <description>Recent content in Sparta on Sparta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>mweagle@gmail.com (Matt Weagle)</managingEditor>
    <webMaster>mweagle@gmail.com (Matt Weagle)</webMaster>
    <lastBuildDate>Mon, 22 Aug 2016 21:00:29 +0000</lastBuildDate>
    <atom:link href="http://gosparta.io/tags/sparta/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Managing Environments</title>
      <link>http://gosparta.io/docs/application/environments/</link>
      <pubDate>Mon, 22 Aug 2016 21:00:29 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/application/environments/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;It&amp;rsquo;s common for a single Sparta application to target multiple &lt;em&gt;environments&lt;/em&gt;. For example:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Development&lt;/li&gt;
&lt;li&gt;Staging&lt;/li&gt;
&lt;li&gt;Production&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each environment is largely similar, but the application may need slightly different configuration in each context.&lt;/p&gt;

&lt;p&gt;To support this, Sparta uses Go&amp;rsquo;s &lt;a href=&#34;http://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool&#34;&gt;conditional compliation&lt;/a&gt; support to ensure that configuration information is validate at build time.  Conditional compilation is supported via the &lt;code&gt;--tags/-t&lt;/code&gt; command line argument.&lt;/p&gt;

&lt;p&gt;This example will work through the &lt;a href=&#34;https://github.com/mweagle/SpartaConfig&#34;&gt;SpartaConfig&lt;/a&gt; sample. The requirement is that each environment declare it&amp;rsquo;s &lt;code&gt;Name&lt;/code&gt; and also add that value as a Stack &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/outputs-section-structure.html&#34;&gt;Output&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;default-configuration&#34;&gt;Default Configuration&lt;/h2&gt;

&lt;p&gt;To start with, create the &lt;em&gt;default&lt;/em&gt; configuration. This is the configuration that Sparta uses when provisioning your Stack and defines the environment configuration contract.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// +build !staging,!production
// file: environments/default.go

package environments

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;github.com/Sirupsen/logrus&amp;quot;
	&amp;quot;github.com/aws/aws-sdk-go/aws/session&amp;quot;
	gocf &amp;quot;github.com/crewjam/go-cloudformation&amp;quot;
	sparta &amp;quot;github.com/mweagle/Sparta&amp;quot;
)

// Name is the default configuration
const Name = &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The important part is the set of excluded tags at the top of the file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// +build !staging,!production
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This ensures that the configuration is only eligible for compilation when Sparta goes to &lt;code&gt;provision&lt;/code&gt; the service.&lt;/p&gt;

&lt;h2 id=&#34;environment-configuration&#34;&gt;Environment Configuration&lt;/h2&gt;

&lt;p&gt;The next steps are to define the environment-specific configuration files:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// +build staging
// file: environments/staging.go

package environments

import (
	&amp;quot;github.com/Sirupsen/logrus&amp;quot;
	&amp;quot;github.com/aws/aws-sdk-go/aws/session&amp;quot;
	gocf &amp;quot;github.com/crewjam/go-cloudformation&amp;quot;
	sparta &amp;quot;github.com/mweagle/Sparta&amp;quot;
)

// Name is the production configuration
const Name = &amp;quot;staging&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// +build production
// file: environments/production.go

package environments

import (
	&amp;quot;github.com/Sirupsen/logrus&amp;quot;
	&amp;quot;github.com/aws/aws-sdk-go/aws/session&amp;quot;
	gocf &amp;quot;github.com/crewjam/go-cloudformation&amp;quot;
	sparta &amp;quot;github.com/mweagle/Sparta&amp;quot;
)

// Name is the production configuration
const Name = &amp;quot;production&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These three files define the set of compile-time mutually-exclusive sources that represent environment targets.&lt;/p&gt;

&lt;h2 id=&#34;segregating-services&#34;&gt;Segregating Services&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;serviceName&lt;/code&gt; argument supplied to &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Main&#34;&gt;sparta.Main&lt;/a&gt; defines the AWS CloudFormation stack that supports your application.  While the previous files represent different environments, they will collide at &lt;code&gt;provision&lt;/code&gt; time since they share the same service name.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;serviceName&lt;/code&gt; can be specialized by using the &lt;code&gt;buildTags&lt;/code&gt; in the service name definition as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;fmt.Sprintf(&amp;quot;SpartaHelloWorld-%s&amp;quot;, sparta.OptionsGlobal.BuildTags),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each time you run &lt;code&gt;provision&lt;/code&gt; with a unique &lt;code&gt;--tags&lt;/code&gt; value, a new CloudFormation stack will be created.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE&lt;/em&gt;: This isn&amp;rsquo;t something suitable for production use as there could be multiple &lt;code&gt;BuildTags&lt;/code&gt; values.&lt;/p&gt;

&lt;h2 id=&#34;enforcing-environments&#34;&gt;Enforcing Environments&lt;/h2&gt;

&lt;p&gt;The final requirement is to add the environment name as a Stack Output. To annotate the stack with the output value, we&amp;rsquo;ll register a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#ServiceDecoratorHook&#34;&gt;ServiceDecorator&lt;/a&gt; and use the same conditional compilation support to compile the environment-specific version.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;main.go&lt;/em&gt; source file registers the workflow hook via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;hooks := &amp;amp;sparta.WorkflowHooks{
	Context:          map[string]interface{}{},
	ServiceDecorator: environments.ServiceDecoratorHook(sparta.OptionsGlobal.BuildTags),
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both &lt;em&gt;environments/staging.go&lt;/em&gt; and &lt;em&gt;environments/production.go&lt;/em&gt; define the same hook function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func ServiceDecoratorHook(buildTags string) sparta.ServiceDecoratorHook {
	return func(context map[string]interface{},
		serviceName string,
		template *gocf.Template,
		S3Bucket string,
		buildID string,
		awsSession *session.Session,
		noop bool,
		logger *logrus.Logger) error {
		template.Outputs[&amp;quot;Environment&amp;quot;] = &amp;amp;gocf.Output{
			Description: &amp;quot;Sparta Config target environment&amp;quot;,
			Value:       Name,
		}
		return nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;em&gt;environments/default.go&lt;/em&gt; definition is slightly different. The &amp;ldquo;default&amp;rdquo; environment isn&amp;rsquo;t one that our service should actually deploy to. It simply exists to make the initial Sparta build (the one that cross compiles the AWS Lambda binary) compile.  Build tags are applied to the &lt;em&gt;AWS Lambda&lt;/em&gt; compiled binary that Sparta generates.&lt;/p&gt;

&lt;p&gt;To prevent users from accidentally deploying to the &amp;ldquo;default&amp;rdquo; environment, the &lt;code&gt;BuildTags&lt;/code&gt; are valdiated in the hook definition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;func ServiceDecoratorHook(buildTags string) sparta.ServiceDecoratorHook {
	return func(context map[string]interface{},
		serviceName string,
		template *gocf.Template,
		S3Bucket string,
		buildID string,
		awsSession *session.Session,
		noop bool,
		logger *logrus.Logger) error {
		if len(buildTags) &amp;lt;= 0 {
			return fmt.Errorf(&amp;quot;Please provide a --tags value for environment target&amp;quot;)
		}
		return nil
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;provisioning&#34;&gt;Provisioning&lt;/h2&gt;

&lt;p&gt;Putting everything together, the &lt;code&gt;SpartaConfig&lt;/code&gt; service can deploy to either environment:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;staging&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    go run main.go provision --level info --s3Bucket $(S3_BUCKET) --noop --tags staging
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;production&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    go run main.go provision --level info --s3Bucket $(S3_BUCKET) --noop --tags production
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Attempting to deploy to &amp;ldquo;default&amp;rdquo; generates an error:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;INFO[0000] Welcome to SpartaConfig-                      Go=go1.7.1 Option=provision SpartaVersion=0.9.2 UTC=2016-10-12T04:07:35Z
INFO[0000] Provisioning service                          BuildID=550c9e360426f48201c885c0abeb078dfc000a0a NOOP=true Tags=
INFO[0000] Verifying IAM Lambda execution roles
INFO[0000] IAM roles verified                            Count=1
INFO[0000] Running `go generate`
INFO[0000] Compiling binary                              Name=SpartaConfig_.lambda.amd64
INFO[0008] Executable binary size                        KB=15309 MB=14
INFO[0008] Creating ZIP archive for upload               TempName=/Users/mweagle/Documents/gopath/src/github.com/mweagle/SpartaConfig/SpartaConfig_104207098
INFO[0009] Registering Sparta function                   FunctionName=main.helloWorld
INFO[0009] Lambda function deployment package size       KB=4262 MB=4
INFO[0009] Bypassing bucket expiration policy check due to -n/-noop command line argument  BucketName=weagle
INFO[0009] Bypassing S3 upload due to -n/-noop command line argument  Bucket=weagle Key=SpartaConfig-/SpartaConfig_104207098
INFO[0009] Calling WorkflowHook                          WorkflowHook=github.com/mweagle/SpartaConfig/environments.ServiceDecoratorHook.func1 WorkflowHookContext=map[]
INFO[0009] Invoking rollback functions                   RollbackCount=0
ERRO[0009] Please provide a --tags value for environment target
Error: Please provide a --tags value for environment target
Usage:
  main provision [flags]

Flags:
  -i, --buildID string    Optional BuildID to use
  -s, --s3Bucket string   S3 Bucket to use for Lambda source
  -t, --tags string       Optional build tags to use for compilation

Global Flags:
  -l, --level string   Log level [panic, fatal, error, warn, info, debug] (default &amp;quot;info&amp;quot;)
  -n, --noop           Dry-run behavior only (do not perform mutations)

ERRO[0009] Please provide a --tags value for environment target
exit status 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Call &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#ParseOptions&#34;&gt;ParseOptions&lt;/a&gt; to initialize  &lt;code&gt;sparta.OptionsGlobal.BuildTags&lt;/code&gt; field for use in a service name definition.&lt;/li&gt;
&lt;li&gt;An alternative approach is to define a custom &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#ArchiveHook&#34;&gt;ArchiveHook&lt;/a&gt; and inject custom configuration into the ZIP archive. This data is available at &lt;code&gt;Path.Join(env.LAMBDA_TASK_ROOT, ZIP_ARCHIVE_PATH)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;See &lt;a href=&#34;https://github.com/tmaiaroto/discfg&#34;&gt;discfg&lt;/a&gt;, &lt;a href=&#34;https://github.com/coreos/etcd&#34;&gt;etcd&lt;/a&gt;, &lt;a href=&#34;https://www.consul.io/&#34;&gt;Consul&lt;/a&gt; (among others) for alternative, more dynamic discovery services.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Workflow Hooks</title>
      <link>http://gosparta.io/docs/application/workflow_hooks/</link>
      <pubDate>Mon, 22 Aug 2016 21:00:29 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/application/workflow_hooks/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;While Sparta tries to provide workflows common across service lifecycles, it may be the case that an application requires additional functionality or runtime resources.&lt;/p&gt;

&lt;p&gt;To support this, Sparta allows you to customize the build pipeline via &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#WorkflowHooks&#34;&gt;WorkflowHooks&lt;/a&gt; structure.  These hooks are called at specific points in the &lt;em&gt;provision&lt;/em&gt; lifecycle and support augmenting the standard pipeline:&lt;/p&gt;

&lt;div class=&#34;mermaid&#34;&gt;
graph TD
  iam[Verify Static IAM Roles]
  preBuild[WorkflowHook - PreBuild]
  style preBuild fill:#1A98E7,stroke:#000,stroke-width:4px;

  compile[Cross Compile for AWS Linux AMI]
  postBuild[WorkflowHook - PostBuild]
  style postBuild fill:#1A98E7,stroke:#000,stroke-width:4px;

  proxyShims[Create NodeJS-Go HTTP Proxies]
  package[ZIP archive]
  userArchive[WorkflowHook - Archive]
  style userArchive fill:#1A98E7,stroke:#000,stroke-width:4px;

  upload[Upload Archive to S3]
  packageAssets[Conditionally ZIP S3 Site Assets]
  uploadAssets[Upload S3 Assets]
  preMarshall[WorkflowHook - PreMarshall]
  style preMarshall fill:#1A98E7,stroke:#000,stroke-width:4px;

  generate[Marshal to CloudFormation]
  decorate[Call Lambda Decorators - Dynamic AWS Resources]

  serviceDecorator[Service Decorator]
  style serviceDecorator fill:#1A98E7,stroke:#000,stroke-width:4px;

  postMarshall[WorkflowHook - PostMarshall]
  style postMarshall fill:#1A98E7,stroke:#000,stroke-width:4px;

  uploadTemplate[Upload Template to S3]
  converge[Create/Update Stack]
  wait[Wait for Complete/Failure Result]

  iam--&gt;preBuild
  preBuild--&gt;compile
  compile--&gt;postBuild
  postBuild--&gt;proxyShims
  proxyShims--&gt;package
  proxyShims--&gt;packageAssets
  package--&gt;userArchive
  userArchive--&gt;upload
  packageAssets--&gt;uploadAssets
  uploadAssets--&gt;generate
  upload--&gt;generate

  generate--&gt;preMarshall
  preMarshall--&gt;decorate
  decorate--&gt;serviceDecorator
  serviceDecorator--&gt;postMarshall
  postMarshall--&gt;uploadTemplate
  uploadTemplate--&gt;converge
  converge--&gt;wait
&lt;/div&gt;
&lt;h6&gt;This diagram is rendered with &lt;a href=&#34;https://github.com/knsv/mermaid&#34; target=&#34;_blank&#34;&gt;Mermaid&lt;/a&gt;. Please open an &lt;a href=&#34;https://github.com/mweagle/Sparta/issues/new&#34; target=&#34;_blank&#34;&gt;issue&lt;/a&gt; if it doesn&#39;t render properly.&lt;/h6&gt;
&lt;hr /&gt;


&lt;p&gt;The following sections describe the three types of WorkflowHooks available.  All hooks accept a &lt;code&gt;context map[string]interface{}&lt;/code&gt; as their first parameter.  Sparta treats this as an opaque property bag that enables hooks to communicate state.&lt;/p&gt;

&lt;h1 id=&#34;workflowhook-types&#34;&gt;WorkflowHook Types&lt;/h1&gt;

&lt;h2 id=&#34;builder-hooks&#34;&gt;Builder Hooks&lt;/h2&gt;

&lt;p&gt;BuilderHooks share the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#WorkflowHook&#34;&gt;WorkflowHook&lt;/a&gt; signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type WorkflowHook func(context map[string]interface{},
    serviceName string,
    S3Bucket string,
    buildID string,
    awsSession *session.Session,
    noop bool,
    logger *logrus.Logger) error

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These functions include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PreBuild&lt;/li&gt;
&lt;li&gt;PostBuild&lt;/li&gt;
&lt;li&gt;PreMarshall&lt;/li&gt;
&lt;li&gt;PostMarshall&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;archive-hook&#34;&gt;Archive Hook&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;ArchiveHook&lt;/code&gt; allows a service to add custom resources to the ZIP archive and have the signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type ArchiveHook func(context map[string]interface{},
    serviceName string,
    zipWriter *zip.Writer,
    awsSession *session.Session,
    noop bool,
    logger *logrus.Logger) error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function is called &lt;em&gt;after&lt;/em&gt; Sparta has written the standard resources to the &lt;code&gt;*zip.Writer&lt;/code&gt; stream.&lt;/p&gt;

&lt;h2 id=&#34;rollback-hook&#34;&gt;Rollback Hook&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;RollbackHook&lt;/code&gt; is called &lt;em&gt;iff&lt;/em&gt; the &lt;em&gt;provision&lt;/em&gt; operation fails and has the signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type RollbackHook func(context map[string]interface{},
    serviceName string,
    awsSession *session.Session,
    noop bool,
    logger *logrus.Logger)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;using-workflowhooks&#34;&gt;Using WorkflowHooks&lt;/h1&gt;

&lt;p&gt;To use the Workflow Hooks feature, initialize a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#WorkflowHooks&#34;&gt;WorkflowHooks&lt;/a&gt; structure with 1 or more hook functions and call &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#MainEx&#34;&gt;sparta.MainEx&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;notes&#34;&gt;Notes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Workflow hooks can be used to support &lt;a href=&#34;https://github.com/mweagle/SpartaDocker&#34;&gt;Dockerizing&lt;/a&gt; your application

&lt;ul&gt;
&lt;li&gt;You may need to add &lt;a href=&#34;http://gosparta.io/docs/application/custom_commands&#34;&gt;custom CLI commands&lt;/a&gt; to fully support Docker&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Enable &lt;code&gt;--level debug&lt;/code&gt; for detailed workflow hook debugging information&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>http://gosparta.io/docs/docker/</link>
      <pubDate>Mon, 22 Aug 2016 21:00:12 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/docker/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;TODO&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Application Customization</title>
      <link>http://gosparta.io/docs/application/</link>
      <pubDate>Thu, 09 Jun 2016 17:46:33 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/application/</guid>
      <description>&lt;p&gt;Sparta-based applications use the &lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt; package to expose a rich set of command line options.  This section describes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/application/commandline&#34;&gt;Default options&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/application/custom_flags&#34;&gt;Adding flags&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/application/custom_commands&#34;&gt;Adding commands&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Adding custom flags or commands is typically a prerequisite to supporting &lt;a href=&#34;http://gosparta.io/docs/alternative_topologies&#34;&gt;alternative topologies&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Command Line Options</title>
      <link>http://gosparta.io/docs/application/commandline/</link>
      <pubDate>Thu, 09 Jun 2016 17:46:33 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/application/commandline/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Sparta provides a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Main&#34;&gt;Main&lt;/a&gt; function that transforms a set of &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;lambda functions&lt;/a&gt; into an application.  This function should be called from your application&amp;rsquo;s &lt;code&gt;package main&lt;/code&gt; as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var lambdaFunctions []*sparta.LambdaAWSInfo
lambdaFunctions = append(lambdaFunctions, lambdaFn)
err := sparta.Main(&amp;#34;SpartaHelloWorld&amp;#34;,
  fmt.Sprintf(&amp;#34;Test HelloWorld resource command&amp;#34;),
  lambdaFunctions,
  nil,
  nil)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;A compiled application provides several command line options which are available by providing the &lt;code&gt;-h/--help&lt;/code&gt; option as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;$ ./SpartaHelloWorld --help

Test HelloWorld resource command

Usage:
  SpartaHelloWorld [command]

Available Commands:
  version     Sparta framework version
  provision   Provision service
  delete      Delete service
  execute     Execute
  describe    Describe service
  explore     Interactively explore service

Flags:
  -l, --level string   Log level [panic, fatal, error, warn, info, debug]&amp;#39; (default &amp;#34;info&amp;#34;)
  -n, --noop           Dry-run behavior only (do not perform mutations)

Use &amp;#34;SpartaHelloWorld [command] --help&amp;#34; for more information about a command.&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;It&amp;rsquo;s also possible to add &lt;a href=&#34;http://gosparta.io/docs/application/custom_flags&#34;&gt;custom flags&lt;/a&gt; and/or &lt;a href=&#34;http://gosparta.io/docs/application/custom_commands&#34;&gt;custom commands&lt;/a&gt; to extend your application&amp;rsquo;s behavior.&lt;/p&gt;

&lt;h1 id=&#34;standard-commands&#34;&gt;Standard Commands&lt;/h1&gt;

&lt;h2 id=&#34;provision&#34;&gt;Provision&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;provision&lt;/code&gt; option is the verb most likely to be used during development.  It provisions the Sparta application to AWS Lambda.&lt;/p&gt;

&lt;h2 id=&#34;delete&#34;&gt;Delete&lt;/h2&gt;

&lt;p&gt;This simply deletes the stack (if present). Attempting to delete a non-empty stack is not treated as an error.&lt;/p&gt;

&lt;h2 id=&#34;describe&#34;&gt;Describe&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;describe&lt;/code&gt; command line option produces an HTML summary (see &lt;a href=&#34;http://gosparta.io/images/overview/graph.html&#34;&gt;graph.html&lt;/a&gt; for an example) of your Sparta service.&lt;/p&gt;

&lt;p&gt;The report also includes the automatically generated CloudFormation template which can be helpful when diagnosing provisioning errors.&lt;/p&gt;

&lt;h2 id=&#34;execute&#34;&gt;Execute&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;execute&lt;/code&gt; option is typically used when the compiled application is launched in the AWS Lambda environment.  It starts up an HTTP listener to which the NodeJS proxing tier forwards requests.&lt;/p&gt;

&lt;h2 id=&#34;explore&#34;&gt;Explore&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;explore&lt;/code&gt; option creates a &lt;em&gt;localhost&lt;/em&gt; server to allow Sparta lambda functions to be tested locally.&lt;/p&gt;

&lt;p&gt;NOTE: API Gateway mapping templates are not currently supported.&lt;/p&gt;

&lt;h2 id=&#34;version&#34;&gt;Version&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;version&lt;/code&gt; option is a diagnostic command that prints the version of the Sparta framework embedded in the application.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Custom Application Commands</title>
      <link>http://gosparta.io/docs/application/custom_commands/</link>
      <pubDate>Thu, 09 Jun 2016 17:46:33 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/application/custom_commands/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;In addition to &lt;a href=&#34;http://gosparta.io/docs/application/custom_flags&#34;&gt;custom flags&lt;/a&gt;, an application may register completely new commands. For example, to support &lt;a href=&#34;http://gosparta.io/docs/application/custom_flags&#34;&gt;alternative topologies&lt;/a&gt; or integrated automated acceptance tests as part of a CI/CD pipeline.&lt;/p&gt;

&lt;p&gt;To register a custom command, define a new &lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;cobra.Command&lt;/a&gt; and add it to the &lt;code&gt;sparta.CommandLineOptions.Root&lt;/code&gt; command value.  Ensure you use the &lt;code&gt;xxxxE&lt;/code&gt; Cobra functions so that errors can be properly propagated.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;httpServerCommand := &amp;amp;cobra.Command{
  Use:   &amp;#34;httpServer&amp;#34;,
  Short: &amp;#34;Sample HelloWorld HTTP server&amp;#34;,
  Long:  `Sample HelloWorld HTTP server that binds to port: ` &amp;#43; HTTPServerPort,
  RunE: func(cmd *cobra.Command, args []string) error {
    http.HandleFunc(&amp;#34;/&amp;#34;, helloWorldResource)
    return http.ListenAndServe(fmt.Sprintf(&amp;#34;:%d&amp;#34;, HTTPServerPort), nil)
  },
}
sparta.CommandLineOptions.Root.AddCommand(httpServerCommand)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Registering a user-defined command makes that command&amp;rsquo;s usage information seamlessly integrate with the standard commands:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ ./SpartaOmega --help
Provision AWS Lambda and EC2 instance with same code

Usage:
  SpartaOmega [command]

Available Commands:
  httpServer  Sample HelloWorld HTTP server
  version     Sparta framework version
  provision   Provision service
  delete      Delete service
  execute     Execute
  describe    Describe service
  explore     Interactively explore service

Flags:
  -l, --level string   Log level [panic, fatal, error, warn, info, debug] (default &amp;#34;info&amp;#34;)
  -n, --noop           Dry-run behavior only (do not perform mutations)

Use &amp;#34;SpartaOmega [command] --help&amp;#34; for more information about a command.&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;And you can query for user-command specific usage as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;bash&#34;&gt;$ ./SpartaOmega httpServer --help
Custom command

Usage:
  SpartaOmega httpServer [flags]

Global Flags:
  -l, --level string   Log level [panic, fatal, error, warn, info, debug] (default &amp;#34;info&amp;#34;)
  -n, --noop           Dry-run behavior only (do not perform mutations)&lt;/code&gt;&lt;/pre&gt;

</description>
    </item>
    
    <item>
      <title>Custom Flags</title>
      <link>http://gosparta.io/docs/application/custom_flags/</link>
      <pubDate>Thu, 09 Jun 2016 17:46:33 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/application/custom_flags/</guid>
      <description>

&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;

&lt;p&gt;Some commands (eg: &lt;code&gt;provision&lt;/code&gt;) may require additional options.  For instance, your application&amp;rsquo;s provision logic may require VPC &lt;a href=&#34;https://aws.amazon.com/blogs/aws/new-access-resources-in-a-vpc-from-your-lambda-functions/&#34;&gt;subnets&lt;/a&gt; or EC2 &lt;a href=&#34;http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html&#34;&gt;SSH Key Names&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The default Sparta command line option flags may be extended and validated by building on the exposed &lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt; command objects.&lt;/p&gt;

&lt;h2 id=&#34;adding-flags&#34;&gt;Adding Flags&lt;/h2&gt;

&lt;p&gt;To add a flag, use one of the &lt;a href=&#34;https://github.com/spf13/pflag&#34;&gt;pflag&lt;/a&gt; functions to register your custom flag with one of the standard &lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/sparta_main.go#L17&#34;&gt;CommandLineOption&lt;/a&gt; values.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// SSHKeyName is the SSH KeyName to use when provisioning new EC2 instance
var SSHKeyName string

func main() {
  // And add the SSHKeyName option to the provision step
  sparta.CommandLineOptions.Provision.Flags().StringVarP(&amp;amp;SSHKeyName,
    &amp;#34;key&amp;#34;,
    &amp;#34;k&amp;#34;,
    &amp;#34;&amp;#34;,
    &amp;#34;SSH Key Name to use for EC2 instances&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;


&lt;h2 id=&#34;validating-input&#34;&gt;Validating Input&lt;/h2&gt;

&lt;p&gt;Flags may be used to conditionalize which Sparta lambda functions are provided and/or their content.  In this case, your application may first need to parse and validate the command line input before calling &lt;code&gt;sparta.Main()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To validate user input, define a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CommandLineOptionsHook&#34;&gt;CommandLineOptionsHook&lt;/a&gt; function and provide it to &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#ParseOptions&#34;&gt;sparta.ParseOptions&lt;/a&gt;.  This function is called after the &lt;em&gt;pflag&lt;/em&gt; bindings are invoked so that your application can validate user input.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;ParseOptions&lt;/code&gt; result is the optional error returned from your &lt;em&gt;CommandLineOptionsHook&lt;/em&gt; function. If there is an error, your application can then exit with an application specific exit code.  For instance:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// Define a validation hook s.t. we can verify the SSHKey is valid
validationHook := func(command *cobra.Command) error {
  if command.Name() == &amp;#34;provision&amp;#34; &amp;amp;&amp;amp; len(SSHKeyName) &amp;lt;= 0 {
    return fmt.Errorf(&amp;#34;SSHKeyName option is required&amp;#34;)
  }
  return nil
  }
}
// Extract &amp;amp; validate the SSH Key
parseErr := sparta.ParseOptions(validationHook)
if nil != parseErr {
  os.Exit(3)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Sparta itself uses the &lt;a href=&#34;https://github.com/asaskevich/govalidator/&#34;&gt;govalidator&lt;/a&gt; package to simplify validating command line arguments.  See &lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/sparta_main.go&#34;&gt;sparta_main.go&lt;/a&gt; for an example.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Event Source - CloudWatch Logs</title>
      <link>http://gosparta.io/docs/eventsources/cloudwatchlogs/</link>
      <pubDate>Tue, 16 Feb 2016 06:40:36 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/cloudwatchlogs/</guid>
      <description>

&lt;p&gt;In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to  &lt;a href=&#34;https://aws.amazon.com/blogs/aws/new-cloudwatch-events-track-and-respond-to-changes-to-your-aws-resources/&#34;&gt;CloudWatch Logs&lt;/a&gt;.  This overview is based on the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication&#34;&gt;SpartaApplication&lt;/a&gt; sample code if you&amp;rsquo;d rather jump to the end result.&lt;/p&gt;

&lt;h1 id=&#34;goal&#34;&gt;Goal&lt;/h1&gt;

&lt;p&gt;Assume that we&amp;rsquo;re supposed to write a simple &amp;ldquo;HelloWorld&amp;rdquo; CloudWatch Logs function that should be triggered in response to any log message issued to a specific Log Group.&lt;/p&gt;

&lt;h1 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h1&gt;

&lt;p&gt;Our lambda function is relatively short:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func echoCloudWatchLogsEvent(event *json.RawMessage,
                        context *sparta.LambdaContext,
                        w http.ResponseWriter,
                        logger *logrus.Logger) {

  // Note that we&amp;#39;re not going to log in this lambda function, as
  // we don&amp;#39;t want to self DDOS
  fmt.Fprintf(w, &amp;#34;Hello World!&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our lambda function doesn&amp;rsquo;t need to do much with the log message other than log it.&lt;/p&gt;

&lt;h1 id=&#34;sparta-integration&#34;&gt;Sparta Integration&lt;/h1&gt;

&lt;p&gt;With &lt;code&gt;echoCloudWatchLogsEvent()&lt;/code&gt; implemented, the next step is to integrate the &lt;strong&gt;Go&lt;/strong&gt; function with Sparta.  This is done by the &lt;code&gt;appendCloudWatchLogsLambda&lt;/code&gt; in the SpartaApplication &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go&#34;&gt;application.go&lt;/a&gt; source.&lt;/p&gt;

&lt;p&gt;Our lambda function only needs logfile write privileges, and since these are enabled by default, we can use an empty &lt;code&gt;sparta.IAMRoleDefinition&lt;/code&gt; value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func appendCloudWatchLogsLambda(api *sparta.API,
	lambdaFunctions []*sparta.LambdaAWSInfo) []*sparta.LambdaAWSInfo {
	lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoCloudWatchLogsEvent, nil)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The next step is to add a &lt;code&gt;CloudWatchLogsSubscriptionFilter&lt;/code&gt; value that represents the &lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/Subscriptions.html#LambdaFunctionExample&#34;&gt;CloudWatch Lambda&lt;/a&gt; subscription &lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CreateSubscriptionFilter.html&#34;&gt;filter information&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;cloudWatchLogsPermission := sparta.CloudWatchLogsPermission{}
cloudWatchLogsPermission.Filters = make(map[string]sparta.CloudWatchLogsSubscriptionFilter, 1)
cloudWatchLogsPermission.Filters[&amp;#34;MyFilter&amp;#34;] = sparta.CloudWatchLogsSubscriptionFilter{
  LogGroupName: &amp;#34;/aws/lambda/versions&amp;#34;,
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;sparta.CloudWatchLogsPermission&lt;/code&gt; struct provides fields for both the LogGroupName and optional Filter expression (not shown here) to use when calling &lt;a href=&#34;http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CloudWatchLogs.html#putSubscriptionFilter-property&#34;&gt;putSubscriptionFilter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;# Add Permission&lt;/p&gt;

&lt;p&gt;With the subscription information configured, the final step is to add the &lt;code&gt;sparta.CloudWatchLogsPermission&lt;/code&gt; to our &lt;code&gt;sparta.LambdaAWSInfo&lt;/code&gt; value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn.Permissions = append(lambdaFn.Permissions, cloudWatchLogsPermission)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our entire function is therefore:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func appendCloudWatchLogsLambda(api *sparta.API,
	lambdaFunctions []*sparta.LambdaAWSInfo) []*sparta.LambdaAWSInfo {

	lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoCloudWatchLogsEvent, nil)

	cloudWatchLogsPermission := sparta.CloudWatchLogsPermission{}
	cloudWatchLogsPermission.Filters = make(map[string]sparta.CloudWatchLogsSubscriptionFilter, 1)
	cloudWatchLogsPermission.Filters[&amp;#34;MyFilter&amp;#34;] = sparta.CloudWatchLogsSubscriptionFilter{
		LogGroupName: &amp;#34;/aws/lambda/versions&amp;#34;,
	}
	lambdaFn.Permissions = append(lambdaFn.Permissions, cloudWatchLogsPermission)
	return append(lambdaFunctions, lambdaFn)
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;With the &lt;code&gt;lambdaFn&lt;/code&gt; fully defined, we can provide it to &lt;code&gt;sparta.Main()&lt;/code&gt; and deploy our service.  The workflow below is shared by all CloudWatch Logs-triggered lambda functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define the lambda function (&lt;code&gt;echoCloudWatchLogsEvent&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If needed, create the required &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta*IAMRoleDefinition&#34;&gt;IAMRoleDefinition&lt;/a&gt; with appropriate privileges.&lt;/li&gt;
&lt;li&gt;Provide the lambda function &amp;amp; IAMRoleDefinition to &lt;code&gt;sparta.NewLambda()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Create a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudWatchLogsPermission&#34;&gt;CloudWatchLogsPermission&lt;/a&gt; value.&lt;/li&gt;
&lt;li&gt;Add one or more &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudWatchLogsSubscriptionFilter&#34;&gt;CloudWatchLogsSubscriptionFilter&lt;/a&gt; to the &lt;code&gt;CloudWatchLogsPermission.Filters&lt;/code&gt; map that defines your lambda function&amp;rsquo;s logfile subscription information.&lt;/li&gt;
&lt;li&gt;Append the &lt;code&gt;CloudWatchLogsPermission&lt;/code&gt; value to the lambda function&amp;rsquo;s &lt;code&gt;Permissions&lt;/code&gt; slice.&lt;/li&gt;
&lt;li&gt;Include the reference in the call to &lt;code&gt;sparta.Main()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;other-resources&#34;&gt;Other Resources&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Event Sources - Overview</title>
      <link>http://gosparta.io/docs/eventsources/</link>
      <pubDate>Tue, 16 Feb 2016 05:36:20 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/</guid>
      <description>&lt;p&gt;The true power of the AWS Lambda architecture is the ability to integrate Lambda execution with other AWS service state transitions.  Depending on the service type, state change events are either pushed or transparently polled and used as the input to a Lambda execution.&lt;/p&gt;

&lt;p&gt;There are several &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/intro-core-components.html&#34;&gt;event sources&lt;/a&gt; available.  They are grouped into Pull and Push types.  Pull based models use &lt;code&gt;sparta.EventSourceMapping&lt;/code&gt; values, as the trigger configuration is stored in the AWS Lambda service.  Push based types use service specific &lt;code&gt;sparta.*Permission&lt;/code&gt; types to denote the fact that the trigger logic is configured in the remote service.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pull Based

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/dynamodb&#34;&gt;DynamoDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/kinesis&#34;&gt;Kinesis&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Pushed Based

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/cloudformation&#34;&gt;CloudFormation&lt;/a&gt; &lt;span class=&#34;label label-warning&#34;&gt;NOT YET IMPLEMENTED&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/cloudwatchevents&#34;&gt;CloudWatch Events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/cloudwatchlogs&#34;&gt;CloudWatch Logs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/cognito&#34;&gt;Cognito&lt;/a&gt; &lt;span class=&#34;label label-warning&#34;&gt;NOT YET IMPLEMENTED&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/s3&#34;&gt;S3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/ses&#34;&gt;SES&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/eventsources/sns&#34;&gt;SNS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>FAQ</title>
      <link>http://gosparta.io/docs/faq/</link>
      <pubDate>Wed, 20 Jan 2016 21:12:27 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/faq/</guid>
      <description>

&lt;h1 id=&#34;development&#34;&gt;Development&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;what-flags-are-defined-during-aws-ami-compilation&#34;&gt;What flags are defined during AWS AMI compilation:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;TAGS&lt;/strong&gt;:         &lt;code&gt;-tags lambdabinary&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ENVIRONMENT&lt;/strong&gt;:  &lt;code&gt;GOOS=linux GOARCH=amd64&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;how-can-i-test-locally&#34;&gt;How can I test locally?&lt;/h2&gt;

&lt;p&gt;Local testing is available via the &lt;a href=&#34;http://gosparta.io/docs/local_testing/&#34;&gt;explore&lt;/a&gt; command.&lt;/p&gt;

&lt;h1 id=&#34;event-sources-ses&#34;&gt;Event Sources - SES&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;where-does-the-spartaruleset-come-from&#34;&gt;Where does the &lt;em&gt;SpartaRuleSet&lt;/em&gt; come from?&lt;/h2&gt;

&lt;p&gt;SES only permits a single &lt;a href=&#34;http://docs.aws.amazon.com/ses/latest/APIReference/API_SetActiveReceiptRuleSet.html&#34;&gt;active receipt rule&lt;/a&gt;.  Additionally, it&amp;rsquo;s possible that multiple Sparta-based services are handing different SES recipients.&lt;/p&gt;

&lt;p&gt;All Sparta-based services share the &lt;em&gt;SpartaRuleSet&lt;/em&gt; SES ruleset, and uniquely identify their Rules by including the current servicename as part of the SES &lt;a href=&#34;http://docs.aws.amazon.com/ses/latest/APIReference/API_CreateReceiptRule.html&#34;&gt;ReceiptRule&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;why-does-provision-not-always-enable-the-spartaruleset&#34;&gt;Why does &lt;code&gt;provision&lt;/code&gt; not always enable the &lt;em&gt;SpartaRuleSet&lt;/em&gt;?&lt;/h2&gt;

&lt;p&gt;Initial &lt;em&gt;SpartaRuleSet&lt;/em&gt; will make it the active ruleset, but Sparta assumes that manual updates made outside of the context of the framework were done with good reason and doesn&amp;rsquo;t attempt to override the user setting.&lt;/p&gt;

&lt;h1 id=&#34;operations&#34;&gt;Operations&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;where-can-i-view-my-function-s-logger-output&#34;&gt;Where can I view my function&amp;rsquo;s &lt;code&gt;*logger&lt;/code&gt; output?&lt;/h2&gt;

&lt;p&gt;Each lambda function includes privileges to write to &lt;a href=&#34;https://console.aws.amazon.com/cloudwatch/home&#34;&gt;CloudWatch Logs&lt;/a&gt;.  The &lt;code&gt;*logrus.logger&lt;/code&gt; output is written (with a brief delay) to a lambda-specific log group.&lt;/p&gt;

&lt;p&gt;The CloudWatch log group name includes a sanitized version of your &lt;strong&gt;Go&lt;/strong&gt; function name &amp;amp; owning service name.&lt;/p&gt;

&lt;h2 id=&#34;where-can-i-view-sparta-s-golang-spawn-metrics&#34;&gt;Where can I view Sparta&amp;rsquo;s golang spawn metrics?&lt;/h2&gt;

&lt;p&gt;Visit the &lt;a href=&#34;https://aws.amazon.com/cloudwatch/&#34;&gt;CloudWatch Metrics&lt;/a&gt; AWS console page and select the &lt;code&gt;Sparta/{SERVICE_NAME}&lt;/code&gt; namespace:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/faq/CloudWatch_Management_Console.jpg&#34; alt=&#34;CloudWatch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Sparta publishes two counters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ProcessSpawned&lt;/code&gt;: A new &lt;strong&gt;Go&lt;/strong&gt; process was spawned to handle requests&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ProcessReused&lt;/code&gt;: An existing &lt;strong&gt;Go&lt;/strong&gt; process was used to handle requests.  See also the discussion on AWS Lambda &lt;a href=&#34;https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/&#34;&gt;container reuse&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;how-can-i-include-additional-aws-resources-as-part-of-my-sparta-application&#34;&gt;How can I include additional AWS resources as part of my Sparta application?&lt;/h2&gt;

&lt;p&gt;Define a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#TemplateDecorator&#34;&gt;TemplateDecorator&lt;/a&gt; function and annotate the &lt;code&gt;*gocf.Template&lt;/code&gt; with additional AWS resources.&lt;/p&gt;

&lt;h2 id=&#34;does-sparta-support-versioning-aliasing&#34;&gt;Does Sparta support Versioning &amp;amp; Aliasing?&lt;/h2&gt;

&lt;p&gt;Yes.&lt;/p&gt;

&lt;p&gt;Define a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#TemplateDecorator&#34;&gt;TemplateDecorator&lt;/a&gt; function and annotate the &lt;code&gt;*gocf.Template&lt;/code&gt; with an &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta/aws/cloudformation#AutoIncrementingLambdaVersionInfo&#34;&gt;AutoIncrementingLambdaVersionInfo&lt;/a&gt; resource. During each &lt;code&gt;provision&lt;/code&gt; operation, the &lt;code&gt;AutoIncrementingLambdaVersionInfo&lt;/code&gt; resource will dynamically update the CloudFormation template with a new version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;autoIncrementingInfo, autoIncrementingInfoErr := spartaCF.AddAutoIncrementingLambdaVersionResource(serviceName,
  lambdaResourceName,
  cfTemplate,
  logger)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also move the &amp;ldquo;alias pointer&amp;rdquo; by referencing one or more of the versions available in the returned struct. For example, to set the alias pointer to the most recent version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Add an alias to the version we&#39;re publishing as part of this `provision` operation
aliasResourceName := sparta.CloudFormationResourceName(&amp;quot;Alias&amp;quot;, lambdaResourceName)
aliasResource := &amp;amp;gocf.LambdaAlias{
    Name:            gocf.String(&amp;quot;MostRecentVersion&amp;quot;),
    FunctionName:    gocf.Ref(lambdaResourceName).String(),
    FunctionVersion: gocf.GetAtt(autoIncrementingInfo.CurrentVersionResourceName, &amp;quot;Version&amp;quot;).String(),
}
cfTemplate.AddResource(aliasResourceName, aliasResource)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;how-do-i-forward-additional-metrics&#34;&gt;How do I forward additional metrics?&lt;/h2&gt;

&lt;p&gt;Sparta-deployed AWS Lambda functions always operate with CloudWatch Metrics &lt;code&gt;putMetric&lt;/code&gt; privileges.  Your lambda code can call &lt;code&gt;putMetric&lt;/code&gt; with application-specific data.&lt;/p&gt;

&lt;h2 id=&#34;how-do-i-setup-alerts-on-additional-metrics&#34;&gt;How do I setup alerts on additional metrics?&lt;/h2&gt;

&lt;p&gt;Define a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#TemplateDecorator&#34;&gt;TemplateDecorator&lt;/a&gt; function and annotate the &lt;code&gt;*gocf.Template&lt;/code&gt; with the needed &lt;a href=&#34;https://godoc.org/github.com/crewjam/go-cloudformation#CloudWatchAlarm&#34;&gt;AWS::CloudWatch::Alarm&lt;/a&gt; values.  Use &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudFormationResourceName&#34;&gt;CloudFormationResourceName(prefix, &amp;hellip;parts)&lt;/a&gt; to help generate unique resource names.&lt;/p&gt;

&lt;h2 id=&#34;how-can-i-determine-the-outputs-available-in-sparta-discover-for-dynamic-aws-resources&#34;&gt;How can I determine the outputs available in sparta.Discover() for dynamic AWS resources?&lt;/h2&gt;

&lt;p&gt;The list of registered output provider types is defined by &lt;code&gt;cloudformationTypeMapDiscoveryOutputs&lt;/code&gt; in &lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/cloudformation_resources.go&#34;&gt;cloudformation_resources.go&lt;/a&gt;.  See the &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html&#34;&gt;CloudFormation Resource Types Reference&lt;/a&gt; for information on interpreting the values.&lt;/p&gt;

&lt;h1 id=&#34;future&#34;&gt;Future&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway</title>
      <link>http://gosparta.io/docs/apigateway/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/</guid>
      <description>

&lt;p&gt;One of the most powerful ways to use AWS Lambda is to make function publicly available over HTTPS.  This is accomplished by connecting the AWS Lambda function with the &lt;a href=&#34;https://aws.amazon.com/api-gateway/&#34;&gt;API Gateway&lt;/a&gt;.  In this section we&amp;rsquo;ll start with a simple &amp;ldquo;echo&amp;rdquo; example and move on to a lambda function that accepts user parameters and returns an expiring S3 URL.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/apigateway/example1&#34;&gt;Example 1 - Echo Event&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/apigateway/example2&#34;&gt;Example 2 - User Input &amp;amp; JSON Response&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/apigateway/example3&#34;&gt;Example 3 - Request Context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/apigateway/slack&#34;&gt;Example 4 - Slack SlashCommand&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gosparta.io/docs/apigateway/cors&#34;&gt;Example 5 - CORS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;concepts&#34;&gt;Concepts&lt;/h1&gt;

&lt;p&gt;Before moving on to the examples, it&amp;rsquo;s suggested you familiarize yourself with the API Gateway concepts.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started-intro.html&#34;&gt;Gettting Started with Amazon API Gateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The API Gateway presents a powerful and complex domain model.  In brief, to integrate with the API Gateway, a service must:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Define one or more AWS Lambda functions&lt;/li&gt;
&lt;li&gt;Create an API Gateway REST API instance&lt;/li&gt;
&lt;li&gt;Create one or more resources associated with the REST API&lt;/li&gt;
&lt;li&gt;Create one or more methods for each resource&lt;/li&gt;
&lt;li&gt;For each method:

&lt;ol&gt;
&lt;li&gt;Define the method request params&lt;/li&gt;
&lt;li&gt;Define the integration request mapping&lt;/li&gt;
&lt;li&gt;Define the integration response mapping&lt;/li&gt;
&lt;li&gt;Define the method response mapping&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Create a stage for a REST API&lt;/li&gt;
&lt;li&gt;Deploy the given stage&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With that overview, let&amp;rsquo;s start with a simple &lt;a href=&#34;http://gosparta.io/docs/apigateway/example1&#34;&gt;example&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;custom-http-headers&#34;&gt;Custom HTTP Headers&lt;/h1&gt;

&lt;p&gt;API Gateway supports returning custom HTTP headers whose values are extracted from your response payload.&lt;/p&gt;

&lt;p&gt;Assume your Sparta lambda function returns a JSON struct as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;// API response struct
type helloWorldResponse struct {
  Location string `json:&amp;quot;location&amp;quot;`
  Body     string `json:&amp;quot;body&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To extract the &lt;code&gt;location&lt;/code&gt; field and promote it to the HTTP &lt;code&gt;Location&lt;/code&gt; header, you must configure the &lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/request-response-data-mappings.html&#34;&gt;response data mappings&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-golang&#34;&gt;//
// Promote the location key value to an HTTP header
//
lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, helloWorldResponseFunc, nil)
	apiGatewayResource, _ := api.NewResource(&amp;quot;/hello&amp;quot;, lambdaFn)

apiGWMethod, _ := apiGatewayResource.NewMethod(&amp;quot;GET&amp;quot;, http.StatusOK)
apiGWMethod.Responses[http.StatusOK].Parameters = map[string]bool{
  &amp;quot;method.response.header.Location&amp;quot;: true,
}
apiGWMethod.Integration.Responses[http.StatusOK].Parameters[&amp;quot;method.response.header.Location&amp;quot;] = &amp;quot;integration.response.body.location&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See the related &lt;a href=&#34;https://forums.aws.amazon.com/thread.jspa?threadID=199443&#34;&gt;AWS Forum thread&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;other-resources&#34;&gt;Other Resources&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/getting-started.html&#34;&gt;Walkthrough: API Gateway and Lambda Functions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway - CORS </title>
      <link>http://gosparta.io/docs/apigateway/cors/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/cors/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&#34;&gt;Cross Origin Resource Sharing&lt;/a&gt; defines a protocol by which resources on different domains may establish whether cross site operations are permissible.&lt;/p&gt;

&lt;p&gt;Sparta makes CORS support a single &lt;code&gt;CORSEnabled&lt;/code&gt; field of the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#API&#34;&gt;API&lt;/a&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// Register the function with the API Gateway
apiStage := sparta.NewStage(&amp;#34;v1&amp;#34;)
apiGateway := sparta.NewAPIGateway(&amp;#34;SpartaHTML&amp;#34;, apiStage)
// Enable CORS s.t. the S3 site can access the resources
apiGateway.CORSEnabled = true&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Setting the boolean to &lt;code&gt;true&lt;/code&gt; will add the necessary &lt;code&gt;OPTIONS&lt;/code&gt; and mock responses to &lt;em&gt;all&lt;/em&gt; resources exposed by your API.  See the &lt;a href=&#34;http://gosparta.io/docs/s3site&#34;&gt;SpartaHTML&lt;/a&gt; sample for a complete example.&lt;/p&gt;

&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-cors.html&#34;&gt;API Gateway Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway - Echo</title>
      <link>http://gosparta.io/docs/apigateway/example1/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/example1/</guid>
      <description>

&lt;p&gt;To start, we&amp;rsquo;ll create a HTTPS accessible lambda function that simply echoes back the contents of the Lambda event.  The source for this is the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication&#34;&gt;SpartaApplication&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For reference, the &lt;code&gt;echoS3Event&lt;/code&gt; function is below.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func echoS3Event(event *json.RawMessage,
                  context *sparta.LambdaContext,
                  w http.ResponseWriter,
                  logger *logrus.Logger) {

  logger.WithFields(logrus.Fields{
    &amp;#34;RequestID&amp;#34;: context.AWSRequestID,
    &amp;#34;Event&amp;#34;:     string(*event),
  }).Info(&amp;#34;Request received&amp;#34;)

  fmt.Fprintf(w, string(*event))
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;create-the-api-gateway&#34;&gt;Create the API Gateway&lt;/h1&gt;

&lt;p&gt;The first requirement is to create a new &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#API&#34;&gt;API&lt;/a&gt; instance via &lt;code&gt;sparta.NewAPIGateway()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;stage := sparta.NewStage(&amp;#34;prod&amp;#34;)
apiGateway := sparta.NewAPIGateway(&amp;#34;MySpartaAPI&amp;#34;, stage)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;In the example above, we&amp;rsquo;re also including a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Stage&#34;&gt;Stage&lt;/a&gt; value.  A non-&lt;code&gt;nil&lt;/code&gt; Stage value will cause the registered API to be deployed.  If the Stage value is &lt;code&gt;nil&lt;/code&gt;, a REST API will be created, but it will not be &lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-deploy-api.html&#34;&gt;deployed&lt;/a&gt; (and therefore not publicly accessible).&lt;/p&gt;

&lt;h1 id=&#34;create-a-resource&#34;&gt;Create a Resource&lt;/h1&gt;

&lt;p&gt;The next step is to associate a URL path with the &lt;code&gt;sparta.LambdaAWSInfo&lt;/code&gt; struct that represents the &lt;strong&gt;Go&lt;/strong&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;apiGatewayResource, _ := api.NewResource(&amp;#34;/hello/world/test&amp;#34;, lambdaFn)
apiGatewayResource.NewMethod(&amp;#34;GET&amp;#34;)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go#L34&#34;&gt;echoS3Event&lt;/a&gt; only supports &lt;code&gt;GET&lt;/code&gt;.  We&amp;rsquo;ll see how a single lambda function can support multiple HTTP methods shortly.&lt;/p&gt;

&lt;h1 id=&#34;provision&#34;&gt;Provision&lt;/h1&gt;

&lt;p&gt;The final step is to to provide the API instance to &lt;code&gt;Sparta.Main()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;stage := sparta.NewStage(&amp;#34;prod&amp;#34;)
apiGateway := sparta.NewAPIGateway(&amp;#34;MySpartaAPI&amp;#34;, stage)
stackName := &amp;#34;SpartaApplication&amp;#34;
sparta.Main(stackName,
  &amp;#34;Simple Sparta application&amp;#34;,
  spartaLambdaData(apiGateway),
  apiGateway,
  nil)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Once the service is successfully provisioned, the &lt;code&gt;Outputs&lt;/code&gt; key will include the API Gateway Deployed URL (sample):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;INFO[0113] Stack output   Description=API Gateway URL Key=APIGatewayURL Value=https://7ljn63rysd.execute-api.us-west-2.amazonaws.com/prod
INFO[0113] Stack output   Description=Sparta Home Key=SpartaHome Value=https://github.com/mweagle/Sparta
INFO[0113] Stack output   Description=Sparta Version Key=SpartaVersion Value=0.1.0&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Combining the &lt;em&gt;API Gateway URL&lt;/em&gt; &lt;code&gt;OutputValue&lt;/code&gt; with our resource path (&lt;em&gt;/hello/world/test&lt;/em&gt;), we get the absolute URL to our lambda function: &lt;em&gt;&lt;a href=&#34;https://7ljn63rysd.execute-api.us-west-2.amazonaws.com/prod/hello/world/test&#34;&gt;https://7ljn63rysd.execute-api.us-west-2.amazonaws.com/prod/hello/world/test&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;querying&#34;&gt;Querying&lt;/h1&gt;

&lt;p&gt;Let&amp;rsquo;s query the lambda function and see what the &lt;code&gt;event&lt;/code&gt; data is at execution time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;curl -vs https://7ljn63rysd.execute-api.us-west-2.amazonaws.com/prod/hello/world/test
*   Trying 54.240.188.223...
* Connected to 7ljn63rysd.execute-api.us-west-2.amazonaws.com (54.240.188.223) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate: *.execute-api.us-west-2.amazonaws.com
* Server certificate: Symantec Class 3 Secure Server CA - G4
* Server certificate: VeriSign Class 3 Public Primary Certification Authority - G5
&amp;gt; GET /prod/hello/world/test HTTP/1.1
&amp;gt; Host: 7ljn63rysd.execute-api.us-west-2.amazonaws.com
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Content-Length: 708
&amp;lt; Connection: keep-alive
&amp;lt; Date: Sat, 05 Dec 2015 21:24:44 GMT
&amp;lt; x-amzn-RequestId: 99dfd15d-9b96-11e5-9705-fdd3a4d9c8bf
&amp;lt; X-Cache: Miss from cloudfront
&amp;lt; Via: 1.1 7a0918c01bce16cc9b165fd895f7dc87.cloudfront.net (CloudFront)
&amp;lt; X-Amz-Cf-Id: rx1cVURKTlc3sla3v59Ekz1YMfVdcUWG1QwFKCFPjjLzHzmL_d6r_w==
&amp;lt;
* Connection #0 to host 7ljn63rysd.execute-api.us-west-2.amazonaws.com left intact
{&amp;#34;method&amp;#34;:&amp;#34;GET&amp;#34;,&amp;#34;body&amp;#34;:{},&amp;#34;headers&amp;#34;:{&amp;#34;Accept&amp;#34;:&amp;#34;*/*&amp;#34;,&amp;#34;CloudFront-Forwarded-Proto&amp;#34;:&amp;#34;https&amp;#34;,&amp;#34;CloudFront-Is-Desktop-Viewer&amp;#34;:&amp;#34;true&amp;#34;,&amp;#34;CloudFront-Is-Mobile-Viewer&amp;#34;:&amp;#34;false&amp;#34;,&amp;#34;CloudFront-Is-SmartTV-Viewer&amp;#34;:&amp;#34;false&amp;#34;,&amp;#34;CloudFront-Is-Tablet-Viewer&amp;#34;:&amp;#34;false&amp;#34;,&amp;#34;CloudFront-Viewer-Country&amp;#34;:&amp;#34;US&amp;#34;,&amp;#34;Via&amp;#34;:&amp;#34;1.1 5c98e8df8806ae26f9ae3c33615610d2.cloudfront.net (CloudFront)&amp;#34;,&amp;#34;X-Amz-Cf-Id&amp;#34;:&amp;#34;sRMCwKpH3jIPbwgIo4pPHv_YJXEo9KEojEFw8yrljFVP2krJbyewLg==&amp;#34;,&amp;#34;X-Forwarded-For&amp;#34;:&amp;#34;50.135.43.1, 54.240.158.211&amp;#34;,&amp;#34;X-Forwarded-Port&amp;#34;:&amp;#34;443&amp;#34;,&amp;#34;X-Forwarded-Proto&amp;#34;:&amp;#34;https&amp;#34;},&amp;#34;queryParams&amp;#34;:{},&amp;#34;pathParams&amp;#34;:{},&amp;#34;context&amp;#34;:{&amp;#34;apiId&amp;#34;:&amp;#34;bmik0opc3l&amp;#34;,&amp;#34;method&amp;#34;:&amp;#34;GET&amp;#34;,&amp;#34;requestId&amp;#34;:&amp;#34;c113fd3b-a76b-11e5-b5e6-4ff04e5da412&amp;#34;,&amp;#34;resourceId&amp;#34;:&amp;#34;mp2mrk&amp;#34;,&amp;#34;resourcePath&amp;#34;:&amp;#34;/hello/world/test&amp;#34;,&amp;#34;stage&amp;#34;:&amp;#34;prod&amp;#34;,&amp;#34;identity&amp;#34;:{&amp;#34;accountId&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;apiKey&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;caller&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;cognitoAuthenticationProvider&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;cognitoAuthenticationType&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;cognitoIdentityId&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;cognitoIdentityPoolId&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;sourceIp&amp;#34;:&amp;#34;50.135.43.1&amp;#34;,&amp;#34;user&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;userAgent&amp;#34;:&amp;#34;curl/7.43.0&amp;#34;,&amp;#34;userArn&amp;#34;:&amp;#34;&amp;#34;}}}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Pretty-printing the response body to make things more readable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;json&#34;&gt;{
  &amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;,
  &amp;#34;body&amp;#34;: {},
  &amp;#34;headers&amp;#34;: {
    &amp;#34;Accept&amp;#34;: &amp;#34;*/*&amp;#34;,
    &amp;#34;CloudFront-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34;,
    &amp;#34;CloudFront-Is-Desktop-Viewer&amp;#34;: &amp;#34;true&amp;#34;,
    &amp;#34;CloudFront-Is-Mobile-Viewer&amp;#34;: &amp;#34;false&amp;#34;,
    &amp;#34;CloudFront-Is-SmartTV-Viewer&amp;#34;: &amp;#34;false&amp;#34;,
    &amp;#34;CloudFront-Is-Tablet-Viewer&amp;#34;: &amp;#34;false&amp;#34;,
    &amp;#34;CloudFront-Viewer-Country&amp;#34;: &amp;#34;US&amp;#34;,
    &amp;#34;Via&amp;#34;: &amp;#34;1.1 5c98e8df8806ae26f9ae3c33615610d2.cloudfront.net (CloudFront)&amp;#34;,
    &amp;#34;X-Amz-Cf-Id&amp;#34;: &amp;#34;sRMCwKpH3jIPbwgIo4pPHv_YJXEo9KEojEFw8yrljFVP2krJbyewLg==&amp;#34;,
    &amp;#34;X-Forwarded-For&amp;#34;: &amp;#34;50.135.43.1, 54.240.158.211&amp;#34;,
    &amp;#34;X-Forwarded-Port&amp;#34;: &amp;#34;443&amp;#34;,
    &amp;#34;X-Forwarded-Proto&amp;#34;: &amp;#34;https&amp;#34;
  },
  &amp;#34;queryParams&amp;#34;: {},
  &amp;#34;pathParams&amp;#34;: {},
  &amp;#34;context&amp;#34;: {
    &amp;#34;apiId&amp;#34;: &amp;#34;bmik0opc3l&amp;#34;,
    &amp;#34;method&amp;#34;: &amp;#34;GET&amp;#34;,
    &amp;#34;requestId&amp;#34;: &amp;#34;c113fd3b-a76b-11e5-b5e6-4ff04e5da412&amp;#34;,
    &amp;#34;resourceId&amp;#34;: &amp;#34;mp2mrk&amp;#34;,
    &amp;#34;resourcePath&amp;#34;: &amp;#34;/hello/world/test&amp;#34;,
    &amp;#34;stage&amp;#34;: &amp;#34;prod&amp;#34;,
    &amp;#34;identity&amp;#34;: {
      &amp;#34;accountId&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;apiKey&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;caller&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;cognitoAuthenticationProvider&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;cognitoAuthenticationType&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;cognitoIdentityId&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;cognitoIdentityPoolId&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;sourceIp&amp;#34;: &amp;#34;50.135.43.1&amp;#34;,
      &amp;#34;user&amp;#34;: &amp;#34;&amp;#34;,
      &amp;#34;userAgent&amp;#34;: &amp;#34;curl/7.43.0&amp;#34;,
      &amp;#34;userArn&amp;#34;: &amp;#34;&amp;#34;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;While this demonstrates that our lambda function is publicly accessible, it&amp;rsquo;s not immediately obvious where the &lt;code&gt;*event&lt;/code&gt; data is being populated.&lt;/p&gt;

&lt;h1 id=&#34;mapping-templates&#34;&gt;Mapping Templates&lt;/h1&gt;

&lt;p&gt;The event data that&amp;rsquo;s actually supplied to &lt;code&gt;echoS3Event&lt;/code&gt; is the complete HTTP response body.  This content is what the API Gateway sends to our lambda function, which is defined by  the integration mapping.  This event data also includes the values of any whitelisted parameters.  When the API Gateway Method is defined, it optionally includes any  whitelisted query params and header values that should be forwarded to the integration target.  For this example, we&amp;rsquo;re not whitelisting any params, so those fields (&lt;code&gt;queryParams&lt;/code&gt;, &lt;code&gt;pathParams&lt;/code&gt;) are empty.  Then for each integration target (which can be AWS Lambda, a mock, or a HTTP Proxy), it&amp;rsquo;s possible to transform the API Gateway request data and whitelisted arguments into a format that&amp;rsquo;s more amenable to the target.&lt;/p&gt;

&lt;p&gt;Sparta uses a pass-through template that passes all valid data, with minor &lt;strong&gt;Body&lt;/strong&gt; differences based on the inbound &lt;em&gt;Content-Type&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/resources/provision/apigateway/inputmapping_json.vtl&#34;&gt;application/json&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/resources/provision/apigateway/inputmapping_default.vtl&#34;&gt;*&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;application/json&lt;/code&gt; template is copied below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;#*
Provide an automatic pass through template that transforms all inputs
into the JSON payload sent to a golang function

See
  https://forums.aws.amazon.com/thread.jspa?threadID=220274&amp;amp;tstart=0
  http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html
*#
{
  &amp;#34;method&amp;#34;: &amp;#34;$context.httpMethod&amp;#34;,
  &amp;#34;body&amp;#34; : $input.json(&amp;#39;$&amp;#39;),
  &amp;#34;headers&amp;#34;: {
    #foreach($param in $input.params().header.keySet())
    &amp;#34;$param&amp;#34;: &amp;#34;$util.escapeJavaScript($input.params().header.get($param))&amp;#34; #if($foreach.hasNext),#end

    #end
  },
  &amp;#34;queryParams&amp;#34;: {
    #foreach($param in $input.params().querystring.keySet())
    &amp;#34;$param&amp;#34;: &amp;#34;$util.escapeJavaScript($input.params().querystring.get($param))&amp;#34; #if($foreach.hasNext),#end

    #end
  },
  &amp;#34;pathParams&amp;#34;: {
    #foreach($param in $input.params().path.keySet())
    &amp;#34;$param&amp;#34;: &amp;#34;$util.escapeJavaScript($input.params().path.get($param))&amp;#34; #if($foreach.hasNext),#end

    #end
  },
  &amp;#34;context&amp;#34; : {
    &amp;#34;apiId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.apiId)&amp;#34;,
    &amp;#34;method&amp;#34; : &amp;#34;$util.escapeJavaScript($context.httpMethod)&amp;#34;,
    &amp;#34;requestId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.requestId)&amp;#34;,
    &amp;#34;resourceId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.resourceId)&amp;#34;,
    &amp;#34;resourcePath&amp;#34; : &amp;#34;$util.escapeJavaScript($context.resourcePath)&amp;#34;,
    &amp;#34;stage&amp;#34; : &amp;#34;$util.escapeJavaScript($context.stage)&amp;#34;,
    &amp;#34;identity&amp;#34; : {
      &amp;#34;accountId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.accountId)&amp;#34;,
      &amp;#34;apiKey&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.apiKey)&amp;#34;,
      &amp;#34;caller&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.caller)&amp;#34;,
      &amp;#34;cognitoAuthenticationProvider&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.cognitoAuthenticationProvider)&amp;#34;,
      &amp;#34;cognitoAuthenticationType&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.cognitoAuthenticationType)&amp;#34;,
      &amp;#34;cognitoIdentityId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.cognitoIdentityId)&amp;#34;,
      &amp;#34;cognitoIdentityPoolId&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.cognitoIdentityPoolId)&amp;#34;,
      &amp;#34;sourceIp&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.sourceIp)&amp;#34;,
      &amp;#34;user&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.user)&amp;#34;,
      &amp;#34;userAgent&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.userAgent)&amp;#34;,
      &amp;#34;userArn&amp;#34; : &amp;#34;$util.escapeJavaScript($context.identity.userArn)&amp;#34;
    }
  }
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;This template forwards all whitelisted data &amp;amp; body to the lambda function.  You can see by switching on the &lt;code&gt;method&lt;/code&gt; field would permit a single function to service multiple HTTP method names.&lt;/p&gt;

&lt;p&gt;The next example will show how to unmarshal this data and perform request-specific actions.&lt;/p&gt;

&lt;h1 id=&#34;proxying-envelope&#34;&gt;Proxying Envelope&lt;/h1&gt;

&lt;p&gt;Because the integration request returned a successful response, the API Gateway response body contains only our lambda&amp;rsquo;s output.&lt;/p&gt;

&lt;p&gt;If there were an error, the response would include additional fields (&lt;code&gt;code&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt;, &lt;code&gt;headers&lt;/code&gt;).  Those fields are injected by the NodeJS proxying tier as part of translating the &lt;strong&gt;Go&lt;/strong&gt; HTTP response to a Lambda compatible result.&lt;/p&gt;

&lt;p&gt;A primary benefit of this envelope is to provide an automatic mapping from Integration Error Response Regular Expression mappings to Method Response codes.  If you look at the &lt;strong&gt;Integration Response&lt;/strong&gt; section of the &lt;em&gt;/hello/world/test&lt;/em&gt; resource in the Console, you&amp;rsquo;ll see a list of Regular Expression matches:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/IntegrationMapping.png&#34; alt=&#34;API Gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The regular expressions are used to translate the integration response, which is just a blob of text provided to &lt;code&gt;context.done()&lt;/code&gt;, into API Gateway Method responses.  Sparta annotates your lambda functions response with &lt;strong&gt;Go&lt;/strong&gt;&amp;rsquo;s &lt;a href=&#34;https://golang.org/src/net/http/status.go&#34;&gt;HTTP StatusText&lt;/a&gt; values based on the HTTP status code your lambda function produced.  Sparta also provides a corresponding Method Response entry for all valid HTTP codes:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/MethodResponse.png&#34; alt=&#34;API Gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;These mappings are defaults, and it&amp;rsquo;s possible to override either one by providing a non-zero length values to either:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Integration&#34;&gt;Integration.Responses&lt;/a&gt;.  See the &lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/apigateway.go#L60&#34;&gt;DefaultIntegrationResponses&lt;/a&gt; for the default values.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#Method&#34;&gt;Method.Responses&lt;/a&gt;.  See the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#DefaultMethodResponses&#34;&gt;DefaultMethodResponses&lt;/a&gt; for the default method response mappings.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;cleaning-up&#34;&gt;Cleaning Up&lt;/h1&gt;

&lt;p&gt;Before moving on, remember to decommission the service via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;go run application.go delete&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;Now that we know what data is actually being sent to our API Gateway-connected Lambda function, we&amp;rsquo;ll move on to performing a more complex operation, including returning a custom HTTP response body.&lt;/p&gt;

&lt;h1 id=&#34;other-resources&#34;&gt;Other Resources&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-mapping-template-reference.html&#34;&gt;Mapping Template Reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway - Request Context</title>
      <link>http://gosparta.io/docs/apigateway/example3/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/example3/</guid>
      <description>

&lt;p&gt;This example demonstrates how to use the &lt;code&gt;Context&lt;/code&gt; struct provided as part of the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#APIGatewayLambdaJSONEvent&#34;&gt;APIGatewayLambdaJSONEvent&lt;/a&gt; event.  The &lt;a href=&#34;https://github.com/mweagle/SpartaGeoIP&#34;&gt;SpartaGeoIP&lt;/a&gt; service will return Geo information based on the inbound request&amp;rsquo;s IP address.&lt;/p&gt;

&lt;h1 id=&#34;define-the-lambda-function&#34;&gt;Define the Lambda Function&lt;/h1&gt;

&lt;p&gt;Our function will examine the inbound request, lookup the user&amp;rsquo;s IP address in the &lt;a href=&#34;http://dev.maxmind.com/geoip/geoip2/geolite2/&#34;&gt;GeoLite2 Database&lt;/a&gt; and return any information to the client.&lt;/p&gt;

&lt;p&gt;As this function is only expected to be invoked from the API Gateway, we&amp;rsquo;ll unmarshall the inbound event:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func ipGeoLambda(event *json.RawMessage,
                  context *sparta.LambdaContext,
                  w http.ResponseWriter,
                  logger *logrus.Logger) {
var lambdaEvent sparta.APIGatewayLambdaJSONEvent
err := json.Unmarshal([]byte(*event), &amp;amp;lambdaEvent)
if err != nil {
	logger.Error(&amp;#34;Failed to unmarshal event data: &amp;#34;, err.Error())
	http.Error(w, err.Error(), http.StatusInternalServerError)
	return
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;We&amp;rsquo;ll then parse the inbound IP address from the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#APIGatewayContext&#34;&gt;Context&lt;/a&gt; and perform a lookup against the database handle opened in the &lt;a href=&#34;https://github.com/mweagle/SpartaGeoIP/blob/master/main.go#L19&#34;&gt;init&lt;/a&gt; block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;parsedIP := net.ParseIP(lambdaEvent.Context.Identity.SourceIP)
record, err := dbHandle.City(parsedIP)
if err != nil {
  logger.Error(&amp;#34;Failed to find city: &amp;#34;, err.Error())
  http.Error(w, err.Error(), http.StatusInternalServerError)
  return
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Finally, marshal the data or error result and we&amp;rsquo;re done:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// Return the Info
httpResponse := map[string]interface{}{
  &amp;#34;info&amp;#34;: record,
}
responseBody, err := json.Marshal(httpResponse)
if err != nil {
  http.Error(w, err.Error(), http.StatusInternalServerError)
} else {
  w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/json&amp;#34;)
  fmt.Fprint(w, string(responseBody))
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;sparta-integration&#34;&gt;Sparta Integration&lt;/h1&gt;

&lt;p&gt;The next steps are to:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Create the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;LambdaAWSInfo&lt;/a&gt; value&lt;/li&gt;
&lt;li&gt;Create an associated API Gateway&lt;/li&gt;
&lt;li&gt;Create an API Gateway resource that invokes our lambda function&lt;/li&gt;
&lt;li&gt;Add a Method name to the resource.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These four steps are managed in the service&amp;rsquo;s &lt;code&gt;main()&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;////////////////////////////////////////////////////////////////////////////////
// Main
func main() {
	stage := sparta.NewStage(&amp;#34;ipgeo&amp;#34;)
	apiGateway := sparta.NewAPIGateway(&amp;#34;SpartaGeoIPService&amp;#34;, stage)
	stackName := &amp;#34;SpartaGeoIP&amp;#34;

	var lambdaFunctions []*sparta.LambdaAWSInfo
	lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, ipGeoLambda, nil)
	apiGatewayResource, _ := apiGateway.NewResource(&amp;#34;/info&amp;#34;, lambdaFn)
	apiGatewayResource.NewMethod(&amp;#34;GET&amp;#34;)
	lambdaFunctions = append(lambdaFunctions, lambdaFn)

	sparta.Main(stackName,
		&amp;#34;Sparta app supporting ip-&amp;gt;geo mapping&amp;#34;,
		lambdaFunctions,
		apiGateway,
    nil)
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;provision&#34;&gt;Provision&lt;/h1&gt;

&lt;p&gt;The next step is to provision the stack:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;S3_BUCKET=&amp;lt;MY-S3-BUCKETNAME&amp;gt; make provision&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Assuming all goes well, the log output will include the API Gateway URL as in:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;INFO[0113] Stack output   Description=API Gateway URL Key=APIGatewayURL Value=https://qyslujefsf.execute-api.us-west-2.amazonaws.com/ipgeo
INFO[0113] Stack output   Description=Sparta Home Key=SpartaHome Value=https://github.com/mweagle/Sparta
INFO[0113] Stack output   Description=Sparta Version Key=SpartaVersion Value=0.1.0&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;query&#34;&gt;Query&lt;/h1&gt;

&lt;p&gt;With the API Gateway provisioned, let&amp;rsquo;s check the response:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;curl -vs https://qyslujefsf.execute-api.us-west-2.amazonaws.com/ipgeo/info

*   Trying 54.192.70.206...
* Connected to qyslujefsf.execute-api.us-west-2.amazonaws.com (54.192.70.206) port 443 (#0)
* TLS 1.2 connection using TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
* Server certificate: *.execute-api.us-west-2.amazonaws.com
* Server certificate: Symantec Class 3 Secure Server CA - G4
* Server certificate: VeriSign Class 3 Public Primary Certification Authority - G5
&amp;gt; GET /ipgeo/info HTTP/1.1
&amp;gt; Host: qyslujefsf.execute-api.us-west-2.amazonaws.com
&amp;gt; User-Agent: curl/7.43.0
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Content-Type: application/json
&amp;lt; Content-Length: 1129
&amp;lt; Connection: keep-alive
&amp;lt; Date: Sun, 06 Dec 2015 21:50:18 GMT
&amp;lt; x-amzn-RequestId: 572adc18-9c63-11e5-b827-81d99c02192f
&amp;lt; X-Cache: Miss from cloudfront
&amp;lt; Via: 1.1 29bfa9b96f4ea66dc02526ee845ca6b0.cloudfront.net (CloudFront)
&amp;lt; X-Amz-Cf-Id: 5mXHuOlbDyk5CejDouAy7nUS3YUn4eXJdQWzU_1VqX9Yh5PE_BdlAw==
&amp;lt;
* Connection #0 to host qyslujefsf.execute-api.us-west-2.amazonaws.com left intact
{&amp;#34;code&amp;#34;:200,&amp;#34;status&amp;#34;:&amp;#34;OK&amp;#34;,&amp;#34;headers&amp;#34;:{&amp;#34;content-type&amp;#34;:&amp;#34;application/json&amp;#34;,&amp;#34;date&amp;#34;:&amp;#34;Sun, 06 Dec 2015 21:50:18 GMT&amp;#34;,&amp;#34;content-length&amp;#34;:&amp;#34;984&amp;#34;},&amp;#34;results&amp;#34;:{&amp;#34;info&amp;#34;:{&amp;#34;City&amp;#34;:{&amp;#34;GeoNameID&amp;#34;:0,&amp;#34;Names&amp;#34;:null},&amp;#34;Continent&amp;#34;:{&amp;#34;Code&amp;#34;:&amp;#34;NA&amp;#34;,&amp;#34;GeoNameID&amp;#34;:6255149,&amp;#34;Names&amp;#34;:{&amp;#34;de&amp;#34;:&amp;#34;Nordamerika&amp;#34;,&amp;#34;en&amp;#34;:&amp;#34;North America&amp;#34;,&amp;#34;es&amp;#34;:&amp;#34;Norteamrica&amp;#34;,&amp;#34;fr&amp;#34;:&amp;#34;Amrique du Nord&amp;#34;,&amp;#34;ja&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;pt-BR&amp;#34;:&amp;#34;Amrica do Norte&amp;#34;,&amp;#34;ru&amp;#34;:&amp;#34; &amp;#34;,&amp;#34;zh-CN&amp;#34;:&amp;#34;&amp;#34;}},&amp;#34;Country&amp;#34;:{&amp;#34;GeoNameID&amp;#34;:6252001,&amp;#34;IsoCode&amp;#34;:&amp;#34;US&amp;#34;,&amp;#34;Names&amp;#34;:{&amp;#34;de&amp;#34;:&amp;#34;USA&amp;#34;,&amp;#34;en&amp;#34;:&amp;#34;United States&amp;#34;,&amp;#34;es&amp;#34;:&amp;#34;Estados Unidos&amp;#34;,&amp;#34;fr&amp;#34;:&amp;#34;tats-Unis&amp;#34;,&amp;#34;ja&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;pt-BR&amp;#34;:&amp;#34;Estados Unidos&amp;#34;,&amp;#34;ru&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;zh-CN&amp;#34;:&amp;#34;&amp;#34;}},&amp;#34;Location&amp;#34;:{&amp;#34;Latitude&amp;#34;:0,&amp;#34;Longitude&amp;#34;:0,&amp;#34;MetroCode&amp;#34;:0,&amp;#34;TimeZone&amp;#34;:&amp;#34;&amp;#34;},&amp;#34;Postal&amp;#34;:{&amp;#34;Code&amp;#34;:&amp;#34;&amp;#34;},&amp;#34;RegisteredCountry&amp;#34;:{&amp;#34;GeoNameID&amp;#34;:6252001,&amp;#34;IsoCode&amp;#34;:&amp;#34;US&amp;#34;,&amp;#34;Names&amp;#34;:{&amp;#34;de&amp;#34;:&amp;#34;USA&amp;#34;,&amp;#34;en&amp;#34;:&amp;#34;United States&amp;#34;,&amp;#34;es&amp;#34;:&amp;#34;Estados Unidos&amp;#34;,&amp;#34;fr&amp;#34;:&amp;#34;tats-Unis&amp;#34;,&amp;#34;ja&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;pt-BR&amp;#34;:&amp;#34;Estados Unidos&amp;#34;,&amp;#34;ru&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;zh-CN&amp;#34;:&amp;#34;&amp;#34;}},&amp;#34;RepresentedCountry&amp;#34;:{&amp;#34;GeoNameID&amp;#34;:0,&amp;#34;IsoCode&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;Names&amp;#34;:null,&amp;#34;Type&amp;#34;:&amp;#34;&amp;#34;},&amp;#34;Subdivisions&amp;#34;:null,&amp;#34;Traits&amp;#34;:{&amp;#34;IsAnonymousProxy&amp;#34;:false,&amp;#34;IsSatelliteProvider&amp;#34;:false}}}}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Pretty-printing the response body:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;code&amp;quot;: 200,
  &amp;quot;status&amp;quot;: &amp;quot;OK&amp;quot;,
  &amp;quot;headers&amp;quot;: {
    &amp;quot;content-type&amp;quot;: &amp;quot;application/json&amp;quot;,
    &amp;quot;date&amp;quot;: &amp;quot;Sun, 06 Dec 2015 17:50:15 GMT&amp;quot;,
    &amp;quot;content-length&amp;quot;: &amp;quot;984&amp;quot;
  },
  &amp;quot;results&amp;quot;: {
    &amp;quot;info&amp;quot;: {
      &amp;quot;City&amp;quot;: {
        &amp;quot;GeoNameID&amp;quot;: 0,
        &amp;quot;Names&amp;quot;: null
      },
      &amp;quot;Continent&amp;quot;: {
        &amp;quot;Code&amp;quot;: &amp;quot;NA&amp;quot;,
        &amp;quot;GeoNameID&amp;quot;: 6255149,
        &amp;quot;Names&amp;quot;: {
          &amp;quot;de&amp;quot;: &amp;quot;Nordamerika&amp;quot;,
          &amp;quot;en&amp;quot;: &amp;quot;North America&amp;quot;,
          &amp;quot;es&amp;quot;: &amp;quot;Norteamrica&amp;quot;,
          &amp;quot;fr&amp;quot;: &amp;quot;Amrique du Nord&amp;quot;,
          &amp;quot;ja&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;pt-BR&amp;quot;: &amp;quot;Amrica do Norte&amp;quot;,
          &amp;quot;ru&amp;quot;: &amp;quot; &amp;quot;,
          &amp;quot;zh-CN&amp;quot;: &amp;quot;&amp;quot;
        }
      },
      &amp;quot;Country&amp;quot;: {
        &amp;quot;GeoNameID&amp;quot;: 6252001,
        &amp;quot;IsoCode&amp;quot;: &amp;quot;US&amp;quot;,
        &amp;quot;Names&amp;quot;: {
          &amp;quot;de&amp;quot;: &amp;quot;USA&amp;quot;,
          &amp;quot;en&amp;quot;: &amp;quot;United States&amp;quot;,
          &amp;quot;es&amp;quot;: &amp;quot;Estados Unidos&amp;quot;,
          &amp;quot;fr&amp;quot;: &amp;quot;tats-Unis&amp;quot;,
          &amp;quot;ja&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;pt-BR&amp;quot;: &amp;quot;Estados Unidos&amp;quot;,
          &amp;quot;ru&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;zh-CN&amp;quot;: &amp;quot;&amp;quot;
        }
      },
      &amp;quot;Location&amp;quot;: {
        &amp;quot;Latitude&amp;quot;: 0,
        &amp;quot;Longitude&amp;quot;: 0,
        &amp;quot;MetroCode&amp;quot;: 0,
        &amp;quot;TimeZone&amp;quot;: &amp;quot;&amp;quot;
      },
      &amp;quot;Postal&amp;quot;: {
        &amp;quot;Code&amp;quot;: &amp;quot;&amp;quot;
      },
      &amp;quot;RegisteredCountry&amp;quot;: {
        &amp;quot;GeoNameID&amp;quot;: 6252001,
        &amp;quot;IsoCode&amp;quot;: &amp;quot;US&amp;quot;,
        &amp;quot;Names&amp;quot;: {
          &amp;quot;de&amp;quot;: &amp;quot;USA&amp;quot;,
          &amp;quot;en&amp;quot;: &amp;quot;United States&amp;quot;,
          &amp;quot;es&amp;quot;: &amp;quot;Estados Unidos&amp;quot;,
          &amp;quot;fr&amp;quot;: &amp;quot;tats-Unis&amp;quot;,
          &amp;quot;ja&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;pt-BR&amp;quot;: &amp;quot;Estados Unidos&amp;quot;,
          &amp;quot;ru&amp;quot;: &amp;quot;&amp;quot;,
          &amp;quot;zh-CN&amp;quot;: &amp;quot;&amp;quot;
        }
      },
      &amp;quot;RepresentedCountry&amp;quot;: {
        &amp;quot;GeoNameID&amp;quot;: 0,
        &amp;quot;IsoCode&amp;quot;: &amp;quot;&amp;quot;,
        &amp;quot;Names&amp;quot;: null,
        &amp;quot;Type&amp;quot;: &amp;quot;&amp;quot;
      },
      &amp;quot;Subdivisions&amp;quot;: null,
      &amp;quot;Traits&amp;quot;: {
        &amp;quot;IsAnonymousProxy&amp;quot;: false,
        &amp;quot;IsSatelliteProvider&amp;quot;: false
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Please see the &lt;a href=&#34;http://gosparta.io/docs/apigateway/example1&#34;&gt;first example&lt;/a&gt; for more information on the &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;status&lt;/code&gt;, and &lt;code&gt;headers&lt;/code&gt; keys.&lt;/p&gt;

&lt;h1 id=&#34;cleaning-up&#34;&gt;Cleaning Up&lt;/h1&gt;

&lt;p&gt;Before moving on, remember to decommission the service via:&lt;/p&gt;

&lt;p&gt;&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;go run main.go delete&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h1 id=&#34;notes&#34;&gt;Notes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;em&gt;GeoLite2-Country.mmdb&lt;/em&gt; content is embedded in the go binary via &lt;a href=&#34;https://github.com/mjibson/esc&#34;&gt;esc&lt;/a&gt; as part of the &lt;a href=&#34;https://github.com/mweagle/SpartaGeoIP/blob/master/main.go#L27&#34;&gt;go generate&lt;/a&gt; phase.&lt;/li&gt;
&lt;li&gt;This is a port of Tom Maiaroto&amp;rsquo;s &lt;a href=&#34;https://github.com/tmaiaroto/go-lambda-geoip&#34;&gt;https://github.com/tmaiaroto/go-lambda-geoip&lt;/a&gt; implementation.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway - Slack SlashCommand</title>
      <link>http://gosparta.io/docs/apigateway/slack/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/apigateway/slack/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/slack_rgb.png&#34; alt=&#34;SlashLogo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this example, we&amp;rsquo;ll walk through creating a &lt;a href=&#34;https://api.slack.com/slash-commands&#34;&gt;Slack Slash Command&lt;/a&gt; service.  The source for this is the &lt;a href=&#34;https://github.com/mweagle/SpartaSlackbot&#34;&gt;SpartaSlackbot&lt;/a&gt; repo.&lt;/p&gt;

&lt;p&gt;Our initial command handler won&amp;rsquo;t be very sophisticated, but will show the steps necessary to provision and configure a Sparta AWS Gateway-enabled Lambda function.&lt;/p&gt;

&lt;h1 id=&#34;define-the-lambda-function&#34;&gt;Define the Lambda Function&lt;/h1&gt;

&lt;p&gt;This lambda handler is a bit more complicated than the other examples, primarily because of the &lt;a href=&#34;https://api.slack.com/slash-commands&#34;&gt;Slack Integration&lt;/a&gt; requirements.  The full source is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;////////////////////////////////////////////////////////////////////////////////
// Hello world event handler
//
func helloSlackbot(event *json.RawMessage,
	context *sparta.LambdaContext,
	w http.ResponseWriter,
	logger *logrus.Logger) {

	// 1. Unmarshal the primary event
	var lambdaEvent slackLambdaJSONEvent
	err := json.Unmarshal([]byte(*event), &amp;amp;lambdaEvent)
	if err != nil {
		logger.Error(&amp;#34;Failed to unmarshal event data: &amp;#34;, err.Error())
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}

	// 2. Conditionally unmarshal to get the Slack text.  See
	// https://api.slack.com/slash-commands
	// for the value name list
	requestParams := url.Values{}
	if bodyData, ok := lambdaEvent.Body.(string); ok {
		requestParams, err = url.ParseQuery(bodyData)
		if err != nil {
			logger.Error(&amp;#34;Failed to parse query: &amp;#34;, err.Error())
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
		logger.WithFields(logrus.Fields{
			&amp;#34;Values&amp;#34;: requestParams,
		}).Info(&amp;#34;Slack slashcommand values&amp;#34;)
	} else {
		logger.Info(&amp;#34;Event body empty&amp;#34;)
	}

	// 3. Create the response
	// Slack formatting:
	// https://api.slack.com/docs/formatting
	responseText := &amp;#34;You talkin to me?&amp;#34;
	for _, eachLine := range requestParams[&amp;#34;text&amp;#34;] {
		responseText &amp;#43;= fmt.Sprintf(&amp;#34;\n&amp;gt;&amp;gt;&amp;gt; %s&amp;#34;, eachLine)
	}

	// 4. Setup the response object:
	// https://api.slack.com/slash-commands, &amp;#34;Responding to a command&amp;#34;
	responseData := sparta.ArbitraryJSONObject{
		&amp;#34;response_type&amp;#34;: &amp;#34;in_channel&amp;#34;,
		&amp;#34;text&amp;#34;:          responseText,
	}
	// 5. Send it off
	responseBody, err := json.Marshal(responseData)
	if err != nil {
		logger.Error(&amp;#34;Failed to marshal response: &amp;#34;, err.Error())
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}
	fmt.Fprint(w, string(responseBody))
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;There are a couple of things to note in this code:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Custom Event Type&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The inbound Slack &lt;code&gt;POST&lt;/code&gt; request is &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; data.  However, our &lt;a href=&#34;https://github.com/mweagle/Sparta/blob/master/resources/provision/apigateway/inputmapping_default.vtl&#34;&gt;integration mapping&lt;/a&gt; mediates the API Gateway HTTPS request, transforming the public request into an integration request.  The integration mapping wraps the raw &lt;code&gt;POST&lt;/code&gt; body with the mapping envelope (so that we can access &lt;a href=&#34;http://gosparta.io/docs/apigateway/example1&#34;&gt;identity information, HTTP headers, etc.&lt;/a&gt;), which produces an inbound JSON request that includes a &lt;strong&gt;Body&lt;/strong&gt; parameter.  The &lt;strong&gt;Body&lt;/strong&gt; string value is the raw inbound &lt;code&gt;POST&lt;/code&gt; data.  Since it&amp;rsquo;s &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, to get the actual parameters we need to parse it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;if bodyData, ok := lambdaEvent.Body.(string); ok {
  requestParams, err = url.ParseQuery(bodyData)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The lambda function extracts all Slack parameters and if defined, sends the &lt;code&gt;text&lt;/code&gt; back with a bit of &lt;a href=&#34;https://api.slack.com/docs/formatting&#34;&gt;Slack Message Formatting&lt;/a&gt; (and some attitude, to be honest about it):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;responseText := &amp;quot;You talkin to me?&amp;quot;
for _, eachLine := range requestParams[&amp;quot;text&amp;quot;] {
  responseText += fmt.Sprintf(&amp;quot;\n&amp;gt;&amp;gt;&amp;gt; %s&amp;quot;, eachLine)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;Custom Response&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The Slack API expects a &lt;a href=&#34;https://api.slack.com/slash-commands&#34;&gt;JSON formatted response&lt;/a&gt;, which is created in step 4:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;responseData := sparta.ArbitraryJSONObject{
    &amp;quot;response_type&amp;quot;: &amp;quot;in_channel&amp;quot;,
    &amp;quot;text&amp;quot;:          responseText,
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;create-the-api-gateway&#34;&gt;Create the API Gateway&lt;/h1&gt;

&lt;p&gt;With our lambda function defined, we need to setup an API Gateway so that it&amp;rsquo;s publicly available:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;apiStage := sparta.NewStage(&amp;#34;v1&amp;#34;)
apiGateway := sparta.NewAPIGateway(&amp;#34;SpartaSlackbot&amp;#34;, apiStage)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;apiStage&lt;/code&gt; value implies that we want to deploy this API Gateway Rest API as part of Sparta&amp;rsquo;s &lt;code&gt;provision&lt;/code&gt; step.&lt;/p&gt;

&lt;h1 id=&#34;create-lambda-binding-resource&#34;&gt;Create Lambda Binding &amp;amp; Resource&lt;/h1&gt;

&lt;p&gt;Next we create an &lt;code&gt;sparta.LambdaAWSInfo&lt;/code&gt; struct that references the &lt;code&gt;s3ItemInfo&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func spartaLambdaFunctions(api *sparta.API) []*sparta.LambdaAWSInfo {
	var lambdaFunctions []*sparta.LambdaAWSInfo
	lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, helloSlackbot, nil)

	if nil != api {
		apiGatewayResource, _ := api.NewResource(&amp;#34;/slack&amp;#34;, lambdaFn)
		_, err := apiGatewayResource.NewMethod(&amp;#34;POST&amp;#34;)
		if nil != err {
			panic(&amp;#34;Failed to create /hello resource&amp;#34;)
		}
	}
	return append(lambdaFunctions, lambdaFn)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;A few items to note here:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;We&amp;rsquo;re using an empty &lt;code&gt;sparta.IAMRoleDefinition{}&lt;/code&gt; definition because our go lambda function doesn&amp;rsquo;t access any additional AWS services.&lt;/li&gt;
&lt;li&gt;Our lambda function will be accessible at the &lt;em&gt;/slack&lt;/em&gt; child path of the deployed API Gateway instance&lt;/li&gt;
&lt;li&gt;Slack supports both &lt;a href=&#34;https://api.slack.com/slash-commands&#34;&gt;GET and POST&lt;/a&gt; integration types, but we&amp;rsquo;re limiting our lambda function to &lt;code&gt;POST&lt;/code&gt; only&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;provision&#34;&gt;Provision&lt;/h1&gt;

&lt;p&gt;With everything configured, we then configure our &lt;code&gt;main()&lt;/code&gt; function to forward to Sparta:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func main() {
	// Register the function with the API Gateway
	apiStage := sparta.NewStage(&amp;#34;v1&amp;#34;)
	apiGateway := sparta.NewAPIGateway(&amp;#34;SpartaSlackbot&amp;#34;, apiStage)

	// Deploy it
	sparta.Main(&amp;#34;SpartaSlackbot&amp;#34;,
		fmt.Sprintf(&amp;#34;Sparta app that responds to Slack commands&amp;#34;),
		spartaLambdaFunctions(apiGateway),
		apiGateway,
		nil)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;and provision the service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;S3_BUCKET=&amp;lt;MY_S3_BUCKETNAME&amp;gt; go run slack.go --level info provision&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Look for the &lt;em&gt;Stack output&lt;/em&gt; section of the log, you&amp;rsquo;ll need the &lt;strong&gt;APIGatewayURL&lt;/strong&gt; value to configure Slack in the next step.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;INFO[0083] Stack output Description=API Gateway URL Key=APIGatewayURL Value=https://75mtsly44i.execute-api.us-west-2.amazonaws.com/v1
INFO[0083] Stack output Description=Sparta Home Key=SpartaHome Value=https://github.com/mweagle/Sparta
INFO[0083] Stack output Description=Sparta Version Key=SpartaVersion Value=0.1.3&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;configure-slack&#34;&gt;Configure Slack&lt;/h1&gt;

&lt;p&gt;At this point our lambda function is deployed and is available through the API Gateway (&lt;em&gt;&lt;a href=&#34;https://75mtsly44i.execute-api.us-west-2.amazonaws.com/v1/slack&#34;&gt;https://75mtsly44i.execute-api.us-west-2.amazonaws.com/v1/slack&lt;/a&gt;&lt;/em&gt; in the current example).&lt;/p&gt;

&lt;p&gt;The next step is to configure Slack with this custom integration:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Visit &lt;a href=&#34;https://slack.com/apps/build&#34;&gt;https://slack.com/apps/build&lt;/a&gt; and choose the &amp;ldquo;Custom Integration&amp;rdquo; option:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/customIntegration.jpg&#34; alt=&#34;Custom integration&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;On the next page, choose &amp;ldquo;Slash Commands&amp;rdquo;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/slashCommandMenu.jpg&#34; alt=&#34;Slash Commands&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The next screen is where you input the command that will trigger your lambda function.  Enter &lt;code&gt;/sparta&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/chooseCommand.jpg&#34; alt=&#34;Slash Chose Command&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;and click the &amp;ldquo;Add Slash Command Integration&amp;rdquo; button.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, scroll down the next page to the &lt;strong&gt;Integration Settings&lt;/strong&gt; section and provide the API Gateway URL of your lambda function.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/integrationSettings.jpg&#34; alt=&#34;Slash URL&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Leave the &lt;em&gt;Method&lt;/em&gt; field unchanged (it should be &lt;code&gt;POST&lt;/code&gt;), to match how we configured the API Gateway entry above.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Save it&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/saveIntegration.jpg&#34; alt=&#34;Save it&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are additional Slash Command Integration options, but for this example the &lt;strong&gt;URL&lt;/strong&gt; option is sufficient to trigger our command.&lt;/p&gt;

&lt;h1 id=&#34;test&#34;&gt;Test&lt;/h1&gt;

&lt;p&gt;With everything configured, visit your team&amp;rsquo;s Slack room and verify the integration via &lt;code&gt;/sparta&lt;/code&gt; slash command:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/apigateway/slack/slackResponse.jpg&#34; alt=&#34;Sparta Response&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;cleaning-up&#34;&gt;Cleaning Up&lt;/h1&gt;

&lt;p&gt;Before moving on, remember to decommission the service via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;nohighlight&#34;&gt;go run slack.go delete&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;This example provides a good overview of Sparta &amp;amp; Slack integration, including how to handle external requests that are not &lt;code&gt;application/json&lt;/code&gt; formatted.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>