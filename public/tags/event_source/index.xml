<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Event_source on Sparta</title>
    <link>http://gosparta.io/tags/event_source/</link>
    <description>Recent content in Event_source on Sparta</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>mweagle@gmail.com (Matt Weagle)</managingEditor>
    <webMaster>mweagle@gmail.com (Matt Weagle)</webMaster>
    <lastBuildDate>Tue, 16 Feb 2016 06:40:36 +0000</lastBuildDate>
    <atom:link href="http://gosparta.io/tags/event_source/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Event Source - CloudWatch Logs</title>
      <link>http://gosparta.io/docs/eventsources/cloudwatchlogs/</link>
      <pubDate>Tue, 16 Feb 2016 06:40:36 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/cloudwatchlogs/</guid>
      <description>

&lt;p&gt;In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to  &lt;a href=&#34;https://aws.amazon.com/blogs/aws/new-cloudwatch-events-track-and-respond-to-changes-to-your-aws-resources/&#34;&gt;CloudWatch Logs&lt;/a&gt;.  This overview is based on the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication&#34;&gt;SpartaApplication&lt;/a&gt; sample code if you&amp;rsquo;d rather jump to the end result.&lt;/p&gt;

&lt;h1 id=&#34;goal&#34;&gt;Goal&lt;/h1&gt;

&lt;p&gt;Assume that we&amp;rsquo;re supposed to write a simple &amp;ldquo;HelloWorld&amp;rdquo; CloudWatch Logs function that should be triggered in response to any log message issued to a specific Log Group.&lt;/p&gt;

&lt;h1 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h1&gt;

&lt;p&gt;Our lambda function is relatively short:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func echoCloudWatchLogsEvent(event *json.RawMessage,
                        context *sparta.LambdaContext,
                        w http.ResponseWriter,
                        logger *logrus.Logger) {

  // Note that we&amp;#39;re not going to log in this lambda function, as
  // we don&amp;#39;t want to self DDOS
  fmt.Fprintf(w, &amp;#34;Hello World!&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our lambda function doesn&amp;rsquo;t need to do much with the log message other than log it.&lt;/p&gt;

&lt;h1 id=&#34;sparta-integration&#34;&gt;Sparta Integration&lt;/h1&gt;

&lt;p&gt;With &lt;code&gt;echoCloudWatchLogsEvent()&lt;/code&gt; implemented, the next step is to integrate the &lt;strong&gt;Go&lt;/strong&gt; function with Sparta.  This is done by the &lt;code&gt;appendCloudWatchLogsLambda&lt;/code&gt; in the SpartaApplication &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go&#34;&gt;application.go&lt;/a&gt; source.&lt;/p&gt;

&lt;p&gt;Our lambda function only needs logfile write privileges, and since these are enabled by default, we can use an empty &lt;code&gt;sparta.IAMRoleDefinition&lt;/code&gt; value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func appendCloudWatchLogsLambda(api *sparta.API,
	lambdaFunctions []*sparta.LambdaAWSInfo) []*sparta.LambdaAWSInfo {
	lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoCloudWatchLogsEvent, nil)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The next step is to add a &lt;code&gt;CloudWatchLogsSubscriptionFilter&lt;/code&gt; value that represents the &lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/Subscriptions.html#LambdaFunctionExample&#34;&gt;CloudWatch Lambda&lt;/a&gt; subscription &lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CreateSubscriptionFilter.html&#34;&gt;filter information&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;cloudWatchLogsPermission := sparta.CloudWatchLogsPermission{}
cloudWatchLogsPermission.Filters = make(map[string]sparta.CloudWatchLogsSubscriptionFilter, 1)
cloudWatchLogsPermission.Filters[&amp;#34;MyFilter&amp;#34;] = sparta.CloudWatchLogsSubscriptionFilter{
  LogGroupName: &amp;#34;/aws/lambda/versions&amp;#34;,
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;sparta.CloudWatchLogsPermission&lt;/code&gt; struct provides fields for both the LogGroupName and optional Filter expression (not shown here) to use when calling &lt;a href=&#34;http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CloudWatchLogs.html#putSubscriptionFilter-property&#34;&gt;putSubscriptionFilter&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;# Add Permission&lt;/p&gt;

&lt;p&gt;With the subscription information configured, the final step is to add the &lt;code&gt;sparta.CloudWatchLogsPermission&lt;/code&gt; to our &lt;code&gt;sparta.LambdaAWSInfo&lt;/code&gt; value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn.Permissions = append(lambdaFn.Permissions, cloudWatchLogsPermission)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our entire function is therefore:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func appendCloudWatchLogsLambda(api *sparta.API,
	lambdaFunctions []*sparta.LambdaAWSInfo) []*sparta.LambdaAWSInfo {

	lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoCloudWatchLogsEvent, nil)

	cloudWatchLogsPermission := sparta.CloudWatchLogsPermission{}
	cloudWatchLogsPermission.Filters = make(map[string]sparta.CloudWatchLogsSubscriptionFilter, 1)
	cloudWatchLogsPermission.Filters[&amp;#34;MyFilter&amp;#34;] = sparta.CloudWatchLogsSubscriptionFilter{
		LogGroupName: &amp;#34;/aws/lambda/versions&amp;#34;,
	}
	lambdaFn.Permissions = append(lambdaFn.Permissions, cloudWatchLogsPermission)
	return append(lambdaFunctions, lambdaFn)
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;With the &lt;code&gt;lambdaFn&lt;/code&gt; fully defined, we can provide it to &lt;code&gt;sparta.Main()&lt;/code&gt; and deploy our service.  The workflow below is shared by all CloudWatch Logs-triggered lambda functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define the lambda function (&lt;code&gt;echoCloudWatchLogsEvent&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If needed, create the required &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta*IAMRoleDefinition&#34;&gt;IAMRoleDefinition&lt;/a&gt; with appropriate privileges.&lt;/li&gt;
&lt;li&gt;Provide the lambda function &amp;amp; IAMRoleDefinition to &lt;code&gt;sparta.NewLambda()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Create a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudWatchLogsPermission&#34;&gt;CloudWatchLogsPermission&lt;/a&gt; value.&lt;/li&gt;
&lt;li&gt;Add one or more &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudWatchLogsSubscriptionFilter&#34;&gt;CloudWatchLogsSubscriptionFilter&lt;/a&gt; to the &lt;code&gt;CloudWatchLogsPermission.Filters&lt;/code&gt; map that defines your lambda function&amp;rsquo;s logfile subscription information.&lt;/li&gt;
&lt;li&gt;Append the &lt;code&gt;CloudWatchLogsPermission&lt;/code&gt; value to the lambda function&amp;rsquo;s &lt;code&gt;Permissions&lt;/code&gt; slice.&lt;/li&gt;
&lt;li&gt;Include the reference in the call to &lt;code&gt;sparta.Main()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;other-resources&#34;&gt;Other Resources&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>Event Source - CloudFormation</title>
      <link>http://gosparta.io/docs/eventsources/cloudformation/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/cloudformation/</guid>
      <description>&lt;p&gt;&lt;span class=&#34;label label-warning&#34;&gt;NOT YET IMPLEMENTED&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;TODO: CloudFormation source documentation&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Event Source - CloudWatch Events</title>
      <link>http://gosparta.io/docs/eventsources/cloudwatchevents/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/cloudwatchevents/</guid>
      <description>

&lt;p&gt;In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to different types of &lt;a href=&#34;https://aws.amazon.com/blogs/aws/new-cloudwatch-events-track-and-respond-to-changes-to-your-aws-resources/&#34;&gt;CloudWatch Events&lt;/a&gt;.  This overview is based on the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication&#34;&gt;SpartaApplication&lt;/a&gt; sample code if you&amp;rsquo;d rather jump to the end result.&lt;/p&gt;

&lt;h1 id=&#34;goal&#34;&gt;Goal&lt;/h1&gt;

&lt;p&gt;Assume that we&amp;rsquo;re supposed to write a simple &amp;ldquo;HelloWorld&amp;rdquo; CloudWatch event function that has two requirements:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Run every &lt;em&gt;5 minutes&lt;/em&gt; to provide a heartbeat notification to our alerting system via a logfile entry&lt;/li&gt;
&lt;li&gt;Log &lt;em&gt;EC2-related&lt;/em&gt; events for later processing&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h1&gt;

&lt;p&gt;Our lambda function is relatively small:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func echoCloudWatchEvent(event *json.RawMessage,
                        context *sparta.LambdaContext,
                        w http.ResponseWriter,
                        logger *logrus.Logger) {

	logger.WithFields(logrus.Fields{
		&amp;#34;RequestID&amp;#34;: context.AWSRequestID,
	}).Info(&amp;#34;Request received&amp;#34;)

	config, _ := sparta.Discover()
	logger.WithFields(logrus.Fields{
		&amp;#34;RequestID&amp;#34;:     context.AWSRequestID,
		&amp;#34;Event&amp;#34;:         string(*event),
		&amp;#34;Configuration&amp;#34;: config,
	}).Info(&amp;#34;Request received&amp;#34;)
	fmt.Fprintf(w, &amp;#34;Hello World!&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our lambda function doesn&amp;rsquo;t need to do much with the event other than log it.&lt;/p&gt;

&lt;h1 id=&#34;spartaIntegration&#34;&gt;Sparta Integration&lt;/h1&gt;

&lt;p&gt;With &lt;code&gt;echoCloudWatchEvent()&lt;/code&gt; implemented, the next step is to integrate the &lt;strong&gt;Go&lt;/strong&gt; function with Sparta.  This is done by the &lt;code&gt;appendCloudWatchEventHandler&lt;/code&gt; in the SpartaApplication &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go&#34;&gt;application.go&lt;/a&gt; source.&lt;/p&gt;

&lt;p&gt;Our lambda function only needs logfile write privileges, and since these are enabled by default, we can use an empty &lt;code&gt;sparta.IAMRoleDefinition&lt;/code&gt; value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func appendCloudWatchEventHandler(api *sparta.API,
                                  lambdaFunctions []*sparta.LambdaAWSInfo) []*sparta.LambdaAWSInfo {

  lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoCloudWatchEvent, nil)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The next step is to add a &lt;code&gt;CloudWatchEventsPermission&lt;/code&gt; value that includes the two rule triggers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;cloudWatchEventsPermission := sparta.CloudWatchEventsPermission{}
cloudWatchEventsPermission.Rules = make(map[string]sparta.CloudWatchEventsRule, 0)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our two rules will be inserted into the &lt;code&gt;Rules&lt;/code&gt; map in the next steps.&lt;/p&gt;

&lt;h2 id=&#34;cron-expression&#34;&gt;Cron Expression&lt;/h2&gt;

&lt;p&gt;Our first requirement is that the lambda function write a heartbeat to the logfile every 5 mins.  This can be configured by adding a scheduled event:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;cloudWatchEventsPermission.Rules[&amp;#34;Rate5Mins&amp;#34;] = sparta.CloudWatchEventsRule{
  ScheduleExpression: &amp;#34;rate(5 minutes)&amp;#34;,
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;ScheduleExpression&lt;/code&gt; value can either be a &lt;em&gt;rate&lt;/em&gt; or a &lt;em&gt;cron&lt;/em&gt; &lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/ScheduledEvents.html&#34;&gt;expression&lt;/a&gt;.  The map keyname is used when adding the &lt;a href=&#34;http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CloudWatchEvents.html#putRule-property&#34;&gt;rule&lt;/a&gt; during stack provisioning.&lt;/p&gt;

&lt;h2 id=&#34;event-pattern&#34;&gt;Event Pattern&lt;/h2&gt;

&lt;p&gt;The other requirement is that our lambda function be notified when matching EC2 events are created.  To support this, we&amp;rsquo;ll add a second &lt;code&gt;Rule&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;cloudWatchEventsPermission.Rules[&amp;#34;EC2Activity&amp;#34;] = sparta.CloudWatchEventsRule{
  EventPattern: map[string]interface{}{
    &amp;#34;source&amp;#34;:      []string{&amp;#34;aws.ec2&amp;#34;},
    &amp;#34;detail-type&amp;#34;: []string{&amp;#34;EC2 Instance State-change Notification&amp;#34;},
  },
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The EC2 event pattern is the &lt;strong&gt;Go&lt;/strong&gt; JSON-compatible representation of the event pattern that CloudWatch Events will use to trigger our lambda function.  This structured value will be marshaled to a String during CloudFormation Template marshaling.&lt;/p&gt;

&lt;div class=&#34;panel panel-warning&#34;&gt;
  &lt;div class=&#34;panel-heading&#34;&gt;Validity Checks&lt;/div&gt;
   &lt;div class=&#34;panel-body&#34;&gt;
    Sparta does &lt;b&gt;NOT&lt;/b&gt; attempt to validate either &lt;code&gt;ScheduleExpression&lt;/code&gt; or &lt;code&gt;EventPattern&lt;/code&gt; values prior to calling CloudFormation.  Syntax errors in either value will be detected during provisioning when the Sparta CloudFormation CustomResource calls &lt;a href=&#34;http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CloudWatchEvents.html#putRule-property&#34;&gt;putRule&lt;/a&gt; to add the lambda target.  This error will cause the CloudFormation operation to fail.  Any API errors will be logged &amp; are viewable in the &lt;a href=&#34;https://blogs.aws.amazon.com/application-management/post/TxPYD8JT4CB5UY/View-CloudFormation-Logs-in-the-Console&#34;&gt;CloudFormation Logs Console&lt;/a&gt;.
   &lt;/div&gt;
&lt;/div&gt;

&lt;h1 id=&#34;add-permission&#34;&gt;Add Permission&lt;/h1&gt;

&lt;p&gt;With the two rules configured, the final step is to add the &lt;code&gt;sparta.CloudWatchPermission&lt;/code&gt; to our &lt;code&gt;sparta.LambdaAWSInfo&lt;/code&gt; value:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn.Permissions = append(lambdaFn.Permissions, cloudWatchEventsPermission)
return append(lambdaFunctions, lambdaFn)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Our entire function is therefore:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func appendCloudWatchEventHandler(api *sparta.API,
                                  lambdaFunctions []*sparta.LambdaAWSInfo) []*sparta.LambdaAWSInfo {

  lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoCloudWatchEvent, nil)

  cloudWatchEventsPermission := sparta.CloudWatchEventsPermission{}
  cloudWatchEventsPermission.Rules = make(map[string]sparta.CloudWatchEventsRule, 0)
  cloudWatchEventsPermission.Rules[&amp;#34;Rate5Mins&amp;#34;] = sparta.CloudWatchEventsRule{
    ScheduleExpression: &amp;#34;rate(5 minutes)&amp;#34;,
  }
  cloudWatchEventsPermission.Rules[&amp;#34;EC2Activity&amp;#34;] = sparta.CloudWatchEventsRule{
    EventPattern: map[string]interface{}{
    	&amp;#34;source&amp;#34;:      []string{&amp;#34;aws.ec2&amp;#34;},
    	&amp;#34;detail-type&amp;#34;: []string{&amp;#34;EC2 Instance State-change Notification&amp;#34;},
    },
  }
  lambdaFn.Permissions = append(lambdaFn.Permissions, cloudWatchEventsPermission)

  return append(lambdaFunctions, lambdaFn)
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;With the &lt;code&gt;lambdaFn&lt;/code&gt; fully defined, we can provide it to &lt;code&gt;sparta.Main()&lt;/code&gt; and deploy our service.  The workflow below is shared by all CloudWatch Events-triggered lambda functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define the lambda function (&lt;code&gt;echoCloudWatchEvent&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If needed, create the required &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta*IAMRoleDefinition&#34;&gt;IAMRoleDefinition&lt;/a&gt; with appropriate privileges.&lt;/li&gt;
&lt;li&gt;Provide the lambda function &amp;amp; IAMRoleDefinition to &lt;code&gt;sparta.NewLambda()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Create a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudWatchEventsPermission&#34;&gt;CloudWatchEventsPermission&lt;/a&gt; value.&lt;/li&gt;
&lt;li&gt;Add one or more &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#CloudWatchEventsRule&#34;&gt;CloudWatchEventsRules&lt;/a&gt; to the &lt;code&gt;CloudWatchEventsPermission.Rules&lt;/code&gt; map that define your lambda function&amp;rsquo;s trigger condition:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/ScheduledEvents.html&#34;&gt;Scheduled Events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CloudWatchEventsandEventPatterns.html&#34;&gt;Event Patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Append the &lt;code&gt;CloudWatchEventsPermission&lt;/code&gt; value to the lambda function&amp;rsquo;s &lt;code&gt;Permissions&lt;/code&gt; slice.&lt;/li&gt;
&lt;li&gt;Include the reference in the call to &lt;code&gt;sparta.Main()&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;other-resources&#34;&gt;Other Resources&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Introduction to &lt;a href=&#34;https://aws.amazon.com/blogs/aws/new-cloudwatch-events-track-and-respond-to-changes-to-your-aws-resources/&#34;&gt;CloudWatch Events&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Tim Bray&amp;rsquo;s &lt;a href=&#34;https://www.tbray.org/ongoing/When/201x/2016/01/11/CloudWatch-Events&#34;&gt;Cloud Eventing&lt;/a&gt; writeup&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/RunLambdaSchedule.html&#34;&gt;Run an AWS Lambda Function on a Schedule Using the AWS CLI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The EC2 event pattern is drawn from the AWS &lt;a href=&#34;http://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/CloudWatchEventsandEventPatterns.html&#34;&gt;Events &amp;amp; Event Patterns&lt;/a&gt; documentation&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Event Source - Cognito</title>
      <link>http://gosparta.io/docs/eventsources/cognito/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/cognito/</guid>
      <description>&lt;p&gt;&lt;span class=&#34;label label-warning&#34;&gt;NOT YET IMPLEMENTED&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;TODO: Cognito source documentation&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Event Source - DynamoDB</title>
      <link>http://gosparta.io/docs/eventsources/dynamodb/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/dynamodb/</guid>
      <description>

&lt;p&gt;In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to DynamoDB stream events.  This overview is based on the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication&#34;&gt;SpartaApplication&lt;/a&gt; sample code if you&amp;rsquo;d rather jump to the end result.&lt;/p&gt;

&lt;h1 id=&#34;goal&#34;&gt;Goal&lt;/h1&gt;

&lt;p&gt;Assume that we&amp;rsquo;re given a DynamoDB stream.  See &lt;a href=&#34;http://localhost:1313/docs/eventsources/dynamodb/#creatingDynamoDBStream:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;below&lt;/a&gt; for details on how to create the stream.  We&amp;rsquo;ve been asked to write a lambda function that logs when operations are performed to the table so that we can perform offline analysis.&lt;/p&gt;

&lt;h1 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h1&gt;

&lt;p&gt;We&amp;rsquo;ll start with an empty lambda function and build up the needed functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func echoDynamoDBEvent(event *json.RawMessage,
                       context *sparta.LambdaContext,
                       w http.ResponseWriter,
                      logger *logrus.Logger)
{
  logger.WithFields(logrus.Fields{
    &amp;#34;RequestID&amp;#34;: context.AWSRequestID,
  }).Info(&amp;#34;Request received&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;{#HUGOSHORTCODE-2#&#34;&gt;&amp;lt;a href=&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;#}&amp;ldquo;&amp;gt;Unmarshalling the DynamoDB Event&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since the &lt;code&gt;echoDynamoDBEvent&lt;/code&gt; is expected to be triggered by DynamoDB events, we will unmarshal the &lt;code&gt;*json.RawMessage&lt;/code&gt; data into an DynamoDB-specific event provided by Sparta via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var lambdaEvent spartaDynamoDB.Event
err := json.Unmarshal([]byte(*event), &amp;amp;lambdaEvent)
if err != nil {
  logger.Error(&amp;#34;Failed to unmarshal event data: &amp;#34;, err.Error())
  http.Error(w, err.Error(), http.StatusInternalServerError)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;DynamoDB events are delivered in batches, via lists of &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta/aws/dynamodb#EventRecord&#34;&gt;EventRecords&lt;/a&gt;, so we&amp;rsquo;ll need to process each record.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;for _, eachRecord := range lambdaEvent.Records {
  logger.WithFields(logrus.Fields{
    &amp;#34;Keys&amp;#34;:     eachRecord.DynamoDB.Keys,
    &amp;#34;NewImage&amp;#34;: eachRecord.DynamoDB.NewImage,
  }).Info(&amp;#34;DynamoDb Event&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;That&amp;rsquo;s enough to get the data into CloudWatch Logs.&lt;/p&gt;

&lt;h1 id=&#34;{#HUGOSHORTCODE-5#&#34;&gt;&amp;lt;a href=&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;#}&amp;ldquo;&amp;gt;Sparta Integration&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;With the core of the &lt;code&gt;echoDynamoDBEvent&lt;/code&gt; complete, the next step is to integrate the &lt;strong&gt;Go&lt;/strong&gt; function with Sparta.  This is performed by the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go#L114&#34;&gt;appendDynamoDBLambda&lt;/a&gt; function.  Since the &lt;code&gt;echoDynamoDBEvent&lt;/code&gt; function doesn&amp;rsquo;t access any additional services (Sparta enables CloudWatch Logs privileges by default), the integration is pretty straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn = sparta.NewLambda(sparta.IAMRoleDefinition{}, echoDynamoDBEvent, nil)&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;event-source-mappings&#34;&gt;Event Source Mappings&lt;/h1&gt;

&lt;p&gt;If we were to deploy this Sparta application, the &lt;code&gt;echoDynamoDBEvent&lt;/code&gt; function would have the ability to log DynamoDB stream events, but would not be invoked in response to events published by the stream.  To register for notifications, we need to configure the lambda&amp;rsquo;s &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/intro-core-components.html#intro-core-components-event-sources&#34;&gt;EventSourceMappings&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn.EventSourceMappings = append(lambdaFn.EventSourceMappings, &amp;amp;lambda.CreateEventSourceMappingInput{
    EventSourceArn:   aws.String(dynamoTestStream),
    StartingPosition: aws.String(&amp;#34;TRIM_HORIZON&amp;#34;),
    BatchSize:        aws.Int64(10),
    Enabled:          aws.Bool(true),
  })
lambdaFunctions = append(lambdaFunctions, lambdaFn)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;dynamoTestStream&lt;/code&gt; param is the ARN of the Dynamo stream that that your lambda function will &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/intro-invocation-modes.html&#34;&gt;poll&lt;/a&gt; (eg: &lt;em&gt;arn:aws:dynamodb:us-west-2:000000000000:table/myDynamoDBTable/stream/2015-12-05T16:28:11.869&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;EventSourceMappings&lt;/code&gt; field is transformed into the appropriate &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-eventsourcemapping.html&#34;&gt;CloudFormation Resource&lt;/a&gt; which enables automatic polling of the DynamoDB stream.&lt;/p&gt;

&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;With the &lt;code&gt;lambdaFn&lt;/code&gt; fully defined, we can provide it to &lt;code&gt;sparta.Main()&lt;/code&gt; and deploy our service.  The workflow below is shared by all DynamoDB stream based lambda functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define the lambda function (&lt;code&gt;echoDynamoDBEvent&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If needed, create the required &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta*IAMRoleDefinition&#34;&gt;IAMRoleDefinition&lt;/a&gt; with appropriate privileges if the lambda function accesses other AWS services.&lt;/li&gt;
&lt;li&gt;Provide the lambda function &amp;amp; IAMRoleDefinition to &lt;code&gt;sparta.NewLambda()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add the necessary &lt;a href=&#34;https://godoc.org/github.com/aws/aws-sdk-go/service/lambda#CreateEventSourceMappingInput&#34;&gt;EventSourceMappings&lt;/a&gt; to the &lt;code&gt;LambdaAWSInfo&lt;/code&gt; struct so that the lambda function is properly configured.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;other-resources&#34;&gt;Other Resources&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/blogs/aws/dynamodb-update-triggers-streams-lambda-cross-region-replication-app/&#34;&gt;Using Triggers for Cross Region DynamoDB Replication&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;appendix&#34;&gt;Appendix&lt;/h1&gt;

&lt;h2 id=&#34;creating-a-dynamodb-stream&#34;&gt;Creating a DynamoDB Stream&lt;/h2&gt;

&lt;p&gt;To create a DynamoDB stream for a given table, follow the steps below:&lt;/p&gt;

&lt;h3 id=&#34;select-table&#34;&gt;Select Table&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/eventsources/dynamodb/DynamoDB_ManageStream.png&#34; alt=&#34;Select Table&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;enable-stream&#34;&gt;Enable Stream&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/eventsources/dynamodb/DynamoDB_Enable.png&#34; alt=&#34;Enable Stream&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;copy-arn&#34;&gt;Copy ARN&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://gosparta.io/images/eventsources/dynamodb/DynamoDB_StreamARN.png&#34; alt=&#34;Copy ARN&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Latest stream ARN&lt;/strong&gt; value is the value that should be provided as the &lt;code&gt;EventSourceArn&lt;/code&gt; in to the &lt;a href=&#34;http://localhost:1313/docs/eventsources/dynamodb/#eventSourceMapping:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Event Source Mappings&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Event Source - Kinesis</title>
      <link>http://gosparta.io/docs/eventsources/kinesis/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/kinesis/</guid>
      <description>

&lt;p&gt;In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to &lt;a href=&#34;https://aws.amazon.com/kinesis/&#34;&gt;Amazon Kinesis&lt;/a&gt; streams.  This overview is based on the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go#L130&#34;&gt;SpartaApplication&lt;/a&gt; sample code if you&amp;rsquo;d rather jump to the end result.&lt;/p&gt;

&lt;h1 id=&#34;goal&#34;&gt;Goal&lt;/h1&gt;

&lt;p&gt;The goal of this example is to provision a Sparta lambda function that logs Amazon Kinesis events to CloudWatch logs.&lt;/p&gt;

&lt;h1 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h1&gt;

&lt;p&gt;We&amp;rsquo;ll start with an empty lambda function and build up the needed functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func echoKinesisEvent(event *json.RawMessage,
                      context *sparta.LambdaContext,
                      w http.ResponseWriter,
                      logger *logrus.Logger)
{
  logger.WithFields(logrus.Fields{
		&amp;#34;RequestID&amp;#34;: context.AWSRequestID,
		&amp;#34;Event&amp;#34;:     string(*event),
	}).Info(&amp;#34;Request received&amp;#34;)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;For this sample all we&amp;rsquo;re going to do is unmarshal the Kinesis &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/walkthrough-kinesis-events-adminuser-create-test-function.html#wt-kinesis-invoke-manually&#34;&gt;event&lt;/a&gt; to a Sparta &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta/aws/kinesis#Event&#34;&gt;kinesis event&lt;/a&gt; and log the id to CloudWatch Logs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var lambdaEvent spartaKinesis.Event
  err := json.Unmarshal([]byte(*event), &amp;amp;lambdaEvent)
  if err != nil {
    logger.Error(&amp;#34;Failed to unmarshal event data: &amp;#34;, err.Error())
    http.Error(w, err.Error(), http.StatusInternalServerError)
  }
  for _, eachRecord := range lambdaEvent.Records {
    logger.WithFields(logrus.Fields{
      &amp;#34;EventID&amp;#34;: eachRecord.EventID,
    }).Info(&amp;#34;Kinesis Event&amp;#34;)
  }
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;With the function defined let&amp;rsquo;s register it with Sparta.&lt;/p&gt;

&lt;h1 id=&#34;sparta-integration&#34;&gt;Sparta Integration&lt;/h1&gt;

&lt;p&gt;First we wrap the &lt;strong&gt;Go&lt;/strong&gt; function in a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;LambdaAWSInfo&lt;/a&gt; struct:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoKinesisEvent, nil)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;Since our lambda function doesn&amp;rsquo;t access any other AWS Services, we can use an empty IAMRoleDefinition (&lt;code&gt;sparta.IAMRoleDefinition{}&lt;/code&gt;).&lt;/p&gt;

&lt;h1 id=&#34;event-source-registration&#34;&gt;Event Source Registration&lt;/h1&gt;

&lt;p&gt;Then last step is to configure our AWS Lambda function with Kinesis as the &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/intro-core-components.html&#34;&gt;EventSource&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn.EventSourceMappings = append(lambdaFn.EventSourceMappings, &amp;amp;lambda.CreateEventSourceMappingInput{
  EventSourceArn:   aws.String(kinesisTestStream),
  StartingPosition: aws.String(&amp;#34;TRIM_HORIZON&amp;#34;),
  BatchSize:        aws.Int64(100),
  Enabled:          aws.Bool(true),
})&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;kinesisTestStream&lt;/code&gt; parameter is the Kinesis stream ARN (eg: &lt;em&gt;arn:aws:kinesis:us-west-2:123412341234:stream/kinesisTestStream&lt;/em&gt;) whose events will trigger lambda execution.&lt;/p&gt;

&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;With the &lt;code&gt;lambdaFn&lt;/code&gt; fully defined, we can provide it to &lt;code&gt;sparta.Main()&lt;/code&gt; and deploy our service.  The workflow below is shared by all Kinesis-triggered lambda functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define the lambda function (&lt;code&gt;echoKinesisEvent&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If needed, create the required &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta*IAMRoleDefinition&#34;&gt;IAMRoleDefinition&lt;/a&gt; with appropriate privileges if the lambda function accesses other AWS services.&lt;/li&gt;
&lt;li&gt;Provide the lambda function &amp;amp; IAMRoleDefinition to &lt;code&gt;sparta.NewLambda()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add the necessary &lt;a href=&#34;https://godoc.org/github.com/aws/aws-sdk-go/service/lambda#CreateEventSourceMappingInput&#34;&gt;EventSourceMappings&lt;/a&gt; to the &lt;code&gt;LambdaAWSInfo&lt;/code&gt; struct so that the lambda function is properly configured.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;notes&#34;&gt;Notes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The Kinesis stream and the AWS Lambda function must be provisioned in the same region.&lt;/li&gt;
&lt;li&gt;The AWS docs have an excellent &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/walkthrough-kinesis-events-adminuser.html&#34;&gt;Kinesis EventSource&lt;/a&gt; walkthrough.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Event Source - S3</title>
      <link>http://gosparta.io/docs/eventsources/s3/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/s3/</guid>
      <description>

&lt;p&gt;In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to S3 events.  This overview is based on the &lt;a href=&#34;https://github.com/mweagle/SpartaImager&#34;&gt;SpartaImager&lt;/a&gt; sample code if you&amp;rsquo;d rather jump to the end result.&lt;/p&gt;

&lt;h1 id=&#34;goal&#34;&gt;Goal&lt;/h1&gt;

&lt;p&gt;Assume we have an S3 bucket that stores images.  You&amp;rsquo;ve been asked to write a service that creates a duplicate image that includes a characteristic stamp overlay and store it in the same S3 bucket.&lt;/p&gt;

&lt;h1 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h1&gt;

&lt;p&gt;We&amp;rsquo;ll start with an empty lambda function and build up the needed functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func transformImage(event *json.RawMessage,
                  context *sparta.LambdaContext,
                  w http.ResponseWriter,
                  logger *logrus.Logger)
{
  logger.WithFields(logrus.Fields{
		&amp;#34;RequestID&amp;#34;: context.AWSRequestID,
		&amp;#34;Event&amp;#34;:     string(*event),
	}).Info(&amp;#34;Request received&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;unmarshalling-the-s3-event&#34;&gt;Unmarshalling the S3 Event&lt;/h1&gt;

&lt;p&gt;Since the &lt;code&gt;transformImage&lt;/code&gt; is expected to be triggered by S3 event changes, we will unmarshal the &lt;code&gt;*json.RawMessage&lt;/code&gt; data into an S3-specific event provided by Sparta via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var lambdaEvent spartaS3.Event
err := json.Unmarshal([]byte(*event), &amp;amp;lambdaEvent)
if err != nil {
  logger.Error(&amp;#34;Failed to unmarshal event data: &amp;#34;, err.Error())
  http.Error(w, err.Error(), http.StatusInternalServerError)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;S3 events are delivered in batches, via lists of &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta/aws/s3#EventRecord&#34;&gt;EventRecords&lt;/a&gt;, so we&amp;rsquo;ll need to process each record.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;for _, eachRecord := range lambdaEvent.Records {
  err = nil
  switch eachRecord.EventName {
  case &amp;#34;ObjectCreated:Put&amp;#34;:
    {
      err = stampImage(eachRecord.S3.Bucket.Name, eachRecord.S3.Object.Key, logger)
    }
  case &amp;#34;s3:ObjectRemoved:Delete&amp;#34;:
    {
      // Delete stamped image
    }
  default:
    {
      logger.Info(&amp;#34;Unsupported event: &amp;#34;, eachRecord.EventName)
    }
  }

  //
  if err != nil {
    logger.Error(&amp;#34;Failed to process event: &amp;#34;, err.Error())
    http.Error(w, err.Error(), http.StatusInternalServerError)
  }
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;a href=&#34;https://github.com/mweagle/SpartaImager/blob/master/application.go#L57&#34;&gt;stampImage&lt;/a&gt; function does most of the work, fetching the S3 image to memory, applying the stamp, and putting the transformed content back to S3 with a new name.  It uses a simple &lt;strong&gt;xformed_&lt;/strong&gt; keyname prefix to identify items which have already been stamped &amp;amp; prevents an &amp;ldquo;event-storm&amp;rdquo; from being triggered.  This simple approach is acceptable for an example, but in production you should use a more durable approach.&lt;/p&gt;

&lt;h1 id=&#34;sparta-integration&#34;&gt;Sparta Integration&lt;/h1&gt;

&lt;p&gt;With the core of the &lt;code&gt;transformImage&lt;/code&gt; complete, the next step is to integrate the &lt;strong&gt;Go&lt;/strong&gt; function with Sparta.  This is performed by the &lt;a href=&#34;https://github.com/mweagle/SpartaImager/blob/master/application.go#L200&#34;&gt;imagerFunctions&lt;/a&gt; source.&lt;/p&gt;

&lt;p&gt;Our lambda function needs to both &lt;em&gt;Get&lt;/em&gt; and &lt;em&gt;Put&lt;/em&gt; items back to an S3 bucket, so we need an IAM Role that grants those privileges under which the function will execute:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// Provision an IAM::Role as part of this application
var iamRole = sparta.IAMRoleDefinition{}

// Setup the ARN that includes all child keys
resourceArn := fmt.Sprintf(&amp;#34;%s/*&amp;#34;, s3EventBroadcasterBucket)
iamRole.Privileges = append(iamRole.Privileges, sparta.IAMRolePrivilege{
  Actions: []string{&amp;#34;s3:GetObject&amp;#34;,
    &amp;#34;s3:PutObject&amp;#34;,
  },
  Resource: resourceArn,
})&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;s3EventBroadcasterBucket&lt;/code&gt; param is the ARN of the S3 bucket that will trigger your lambda function (eg: &lt;em&gt;arn:aws:s3:::MyImagingS3Bucket&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;With the IAM Role defined, we can create the Sparta lambda function for &lt;code&gt;transformImage&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;// The default timeout is 3 seconds - increase that to 30 seconds s.t. the
// transform lambda doesn&amp;#39;t fail early.
transformOptions := &amp;amp;sparta.LambdaFunctionOptions{
  Description: &amp;#34;Stamp assets in S3&amp;#34;,
  MemorySize:  128,
  Timeout:     30,
}
lambdaFn := sparta.NewLambda(iamRole, transformImage, transformOptions)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;It typically takes more than 3 seconds to apply the transform, so we increase the execution timeout and provision a new lambda function using the &lt;code&gt;iamRole&lt;/code&gt; we defined earlier.&lt;/p&gt;

&lt;h1 id=&#34;event-source-registration&#34;&gt;Event Source Registration&lt;/h1&gt;

&lt;p&gt;If we were to deploy this Sparta application, the &lt;code&gt;transformImage&lt;/code&gt; function would have the ability to &lt;em&gt;Get&lt;/em&gt; and &lt;em&gt;Put&lt;/em&gt; back to the &lt;code&gt;s3EventBroadcasterBucket&lt;/code&gt;, but would not be invoked in response to events triggered by that bucket.  To register for state change events, we need to configure the lambda&amp;rsquo;s &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html&#34;&gt;Permissions&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;//////////////////////////////////////////////////////////////////////////////
// S3 configuration
//
lambdaFn.Permissions = append(lambdaFn.Permissions, sparta.S3Permission{
  BasePermission: sparta.BasePermission{
    SourceArn: s3EventBroadcasterBucket,
  },
  Events: []string{&amp;#34;s3:ObjectCreated:*&amp;#34;, &amp;#34;s3:ObjectRemoved:*&amp;#34;},
})
lambdaFunctions = append(lambdaFunctions, lambdaFn)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;When &lt;code&gt;Sparta&lt;/code&gt; generates the CloudFormation template, it scans for &lt;code&gt;Permission&lt;/code&gt; configurations.  For &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/intro-invocation-modes.html&#34;&gt;push based sources&lt;/a&gt; like S3, Sparta uses that service&amp;rsquo;s APIs to register your lambda function as a publishing target for events.  This remote registration is handled automatically by CustomResources added to the CloudFormation template.&lt;/p&gt;

&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;With the &lt;code&gt;lambdaFn&lt;/code&gt; fully defined, we can provide it to &lt;code&gt;sparta.Main()&lt;/code&gt; and deploy our service.  The workflow below is shared by all S3-triggered lambda functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define the lambda function (&lt;code&gt;transformImage&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Implement the associated business logic  (&lt;code&gt;stampImage&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If needed, create the required &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta*IAMRoleDefinition&#34;&gt;IAMRoleDefinition&lt;/a&gt; with appropriate privileges.&lt;/li&gt;
&lt;li&gt;Provide the lambda function &amp;amp; IAMRoleDefinition to &lt;code&gt;sparta.NewLambda()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add the necessary &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;Permissions&lt;/a&gt; to the &lt;code&gt;LambdaAWSInfo&lt;/code&gt; struct so that the lambda function is triggered.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;a href=&#34;https://github.com/mweagle/SpartaImager&#34;&gt;SpartaImager&lt;/a&gt; repo contains the full code, and includes &lt;a href=&#34;http://gosparta.io/docs/apigateway&#34;&gt;API Gateway&lt;/a&gt; support that allows you to publicly fetch the stamped image via an expiring S3 URL.&lt;/p&gt;

&lt;h1 id=&#34;other-resources&#34;&gt;Other Resources&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The AWS docs have an excellent &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/getting-started-amazons3-events.html&#34;&gt;S3 event source&lt;/a&gt; walkthrough.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Event Source - SES</title>
      <link>http://gosparta.io/docs/eventsources/ses/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/ses/</guid>
      <description>

&lt;p&gt;In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to inbound email.  This overview is based on the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go&#34;&gt;SpartaApplication&lt;/a&gt; sample code if you&amp;rsquo;d rather jump to the end result.&lt;/p&gt;

&lt;h1 id=&#34;goal&#34;&gt;Goal&lt;/h1&gt;

&lt;p&gt;Assume that we have already &lt;a href=&#34;http://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-domains.html&#34;&gt;verified our email domain&lt;/a&gt; with AWS.  This allows our domain&amp;rsquo;s email to be handled by SES.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve been asked to write a lambda function that logs inbound messages, including the metadata associated with the message body itself.&lt;/p&gt;

&lt;p&gt;There is also an additional requirement to support &lt;a href=&#34;http://radar.oreilly.com/2015/06/an-introduction-to-immutable-infrastructure.html&#34;&gt;immutable infrastructure&lt;/a&gt;, so our service needs to manage the S3 bucket to which message bodies should be stored.  Our service cannot rely on a pre-existing S3 bucket.  The infrastructure (and associated security policies) together with the application logic is coupled.&lt;/p&gt;

&lt;h1 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h1&gt;

&lt;p&gt;We&amp;rsquo;ll start with an empty lambda function and build up the needed functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func echoSESEvent(event *json.RawMessage,
  context *sparta.LambdaContext,
  w http.ResponseWriter,
  logger *logrus.Logger) {

{
  logger.WithFields(logrus.Fields{
    &amp;quot;RequestID&amp;quot;: context.AWSRequestID,
  }).Info(&amp;quot;Request received&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;unmarshalling-the-ses-event&#34;&gt;Unmarshalling the SES Event&lt;/h1&gt;

&lt;p&gt;At this point we would normally continue processing the SES event, using Sparta types if available.&lt;/p&gt;

&lt;p&gt;However, before moving on to the event unmarshaling, we need to take a detour into &lt;a href=&#34;http://gosparta.io/docs/dynamic_infrastructure/&#34;&gt;dynamic infrastructure&lt;/a&gt; because of the immutable infrastructure requirement.&lt;/p&gt;

&lt;p&gt;This requirement implies that our service must be self-contained: we can&amp;rsquo;t assume that &amp;ldquo;something else&amp;rdquo; has created an S3 bucket.  How can our locally compiled code access AWS-created resources?&lt;/p&gt;

&lt;h1 id=&#34;dynamic-resources&#34;&gt;Dynamic Resources&lt;/h1&gt;

&lt;p&gt;The immutable infrastructure requirement makes this lambda function a bit more complex.  Our service needs to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Provision a new S3 bucket for email message body storage

&lt;ul&gt;
&lt;li&gt;SES will not provide the message body in the event data.  It will only store the email body in an S3 bucket, from which your lambda function can later consume it.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Wait for the S3 bucket to be provisioned

&lt;ul&gt;
&lt;li&gt;As we need a new S3 bucket, we&amp;rsquo;re relying on AWS to generate a &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket.html#cfn-s3-bucket-name&#34;&gt;unique name&lt;/a&gt;.  But this means that our lambda function doesn&amp;rsquo;t know the S3 bucket name during provisioning.&lt;/li&gt;
&lt;li&gt;In fact, we shouldn&amp;rsquo;t even create an AWS Lambda function if the S3 bucket can&amp;rsquo;t be created.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Include an IAMPrivilege so that our &lt;strong&gt;Go&lt;/strong&gt; function can access the dynamically created bucket&lt;/li&gt;
&lt;li&gt;Discover the S3 Bucket at lambda execution time&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;provision-message-body-storage-resource&#34;&gt;Provision Message Body Storage Resource&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s first take a look at how the SES lambda handler provisions a new S3 bucket via the &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#MessageBodyStorage&#34;&gt;MessageBodyStorage&lt;/a&gt; type:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;
func appendSESLambda(api *sparta.API,
  lambdaFunctions []*sparta.LambdaAWSInfo) []*sparta.LambdaAWSInfo {

  // Setup options s.t. the lambda function has time to consume the message body
  sesItemInfoOptions := &amp;amp;sparta.LambdaFunctionOptions{
    Description: &amp;quot;&amp;quot;,
    MemorySize:  128,
    Timeout:     10,
  }
  // Our lambda function will need to be able to read from the bucket, which
  // will be handled by the S3MessageBodyBucketDecorator below
  lambdaFn := sparta.NewLambda(sparta.IAMRoleDefinition{}, echoSESEvent, sesItemInfoOptions)

  // Add a Permission s.t. the Lambda function automatically manages SES registration
  sesPermission := sparta.SESPermission{
    BasePermission: sparta.BasePermission{
      // SES only supports wildcard ARNs
      SourceArn: &amp;quot;*&amp;quot;,
    },
    InvocationType: &amp;quot;Event&amp;quot;,
  }
  // Store the message body
  bodyStorage, _ := sesPermission.NewMessageBodyStorageResource(&amp;quot;Special&amp;quot;)
  sesPermission.MessageBodyStorage = bodyStorage

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;MessageBodyStorage&lt;/code&gt; type (and the related &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#MessageBodyStorageOptions&#34;&gt;MessageBodyStorageOptions&lt;/a&gt; type) cause our SESPermission handler to  add an &lt;a href=&#34;http://docs.aws.amazon.com/ses/latest/DeveloperGuide/receiving-email-action-s3.html&#34;&gt;S3 ReceiptRule&lt;/a&gt; at the head of the rules list.  This rule instructs SES to store the message body in the supplied bucket before invoking our lambda function.&lt;/p&gt;

&lt;p&gt;The single parameter &lt;code&gt;&amp;quot;Special&amp;quot;&lt;/code&gt; is an application-unique literal value that is used to create a stable CloudFormation resource identifier so that new buckets are not created in response to stack update requests.&lt;/p&gt;

&lt;p&gt;Our SES handler then adds two &lt;a href=&#34;http://docs.aws.amazon.com/ses/latest/APIReference/API_ReceiptRule.html&#34;&gt;ReceiptRules&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sesPermission.ReceiptRules = make([]sparta.ReceiptRule, 0)
sesPermission.ReceiptRules = append(sesPermission.ReceiptRules, sparta.ReceiptRule{
  Name:       &amp;quot;Special&amp;quot;,
  Recipients: []string{&amp;quot;sombody_special@gosparta.io&amp;quot;},
  TLSPolicy:  &amp;quot;Optional&amp;quot;,
})
sesPermission.ReceiptRules = append(sesPermission.ReceiptRules, sparta.ReceiptRule{
  Name:       &amp;quot;Default&amp;quot;,
  Recipients: []string{},
  TLSPolicy:  &amp;quot;Optional&amp;quot;,
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;dynamic-iamprivilege-arn&#34;&gt;Dynamic IAMPrivilege Arn&lt;/h2&gt;

&lt;p&gt;Our lambda function is required to access the message body in the dynamically created &lt;code&gt;MessageBodyStorage&lt;/code&gt; resource, but the S3 resource Arn is only defined &lt;em&gt;after&lt;/em&gt; the service is provisioned.  The solution to this is to reference the dynamically generated &lt;code&gt;BucketArnAllKeys()&lt;/code&gt; value in the &lt;code&gt;sparta.IAMRolePrivilege&lt;/code&gt; initializer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Then add the privilege to the Lambda function s.t. we can actually get at the data
lambdaFn.RoleDefinition.Privileges = append(lambdaFn.RoleDefinition.Privileges,
  sparta.IAMRolePrivilege{
    Actions:  []string{&amp;quot;s3:GetObject&amp;quot;, &amp;quot;s3:HeadObject&amp;quot;},
    Resource: sesPermission.MessageBodyStorage.BucketArnAllKeys(),
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last step is to register the &lt;code&gt;SESPermission&lt;/code&gt; with the lambda info:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Finally add the SES permission to the lambda function
lambdaFn.Permissions = append(lambdaFn.Permissions, sesPermission)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point we&amp;rsquo;ve implicitly created an S3 bucket via the &lt;code&gt;MessageBodyStorage&lt;/code&gt; value.  Our lambda function now needs to dynamically determine the AWS-assigned bucket name.&lt;/p&gt;

&lt;h2 id=&#34;dynamic-message-body-storage-discovery&#34;&gt;Dynamic Message Body Storage Discovery&lt;/h2&gt;

&lt;p&gt;Our &lt;code&gt;echoSESEvent&lt;/code&gt; function needs to determine, at execution time, the &lt;code&gt;MessageBodyStorage&lt;/code&gt; S3 bucket name.  This is done via &lt;code&gt;sparta.Discover()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;configuration, configErr := sparta.Discover()

logger.WithFields(logrus.Fields{
  &amp;quot;Error&amp;quot;:         configErr,
  &amp;quot;Configuration&amp;quot;: configuration,
}).Debug(&amp;quot;Discovery results&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;sparta.Discover()&lt;/code&gt; function returns a &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#DiscoveryInfo&#34;&gt;DiscoveryInfo&lt;/a&gt; structure.  This structure is the unmarshaled CloudFormation &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-metadata.html&#34;&gt;Metadata&lt;/a&gt; of the CloudFormation &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html&#34;&gt;Lambda::Function&lt;/a&gt; resource.&lt;/p&gt;

&lt;p&gt;The structure includes the stack&amp;rsquo;s &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/pseudo-parameter-reference.html&#34;&gt;Pseudo Parameters&lt;/a&gt; as well information about any &lt;em&gt;immediate&lt;/em&gt; resource dependencies.  Eg, those that were explicitly marked as &lt;code&gt;DependsOn&lt;/code&gt;.  See the &lt;a href=&#34;http://gosparta.io/docs/discovery/&#34;&gt;discovery documentation&lt;/a&gt; for more details.&lt;/p&gt;

&lt;p&gt;Of note is that &lt;code&gt;sparta.Discover()&lt;/code&gt; does not accept any parameters and instead uses &lt;a href=&#34;https://golang.org/pkg/reflect/&#34;&gt;reflect&lt;/a&gt; to determine which &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;sparta.LamdaAWSInfo&lt;/a&gt; structure to lookup.  Discovery is therefore limited to being called from a &lt;em&gt;Sparta-compliant Go lambda function&lt;/em&gt; only.&lt;/p&gt;

&lt;p&gt;It will return the full set of data iff:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It&amp;rsquo;s called from a &lt;code&gt;Sparta.LambdaFunction&lt;/code&gt; function&lt;/li&gt;
&lt;li&gt;That function has immediate AWS resource dependencies&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A sample &lt;code&gt;DiscoveryInfo&lt;/code&gt; for SES is below :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;Region&amp;quot;: &amp;quot;us-west-2&amp;quot;,
  &amp;quot;StackID&amp;quot;: &amp;quot;arn:aws:cloudformation:us-west-2:123412341234:stack/SpartaApplication/a94e1e70-cc2a-11e5-b38e-50d5ca789e4a&amp;quot;,
  &amp;quot;StackName&amp;quot;: &amp;quot;SpartaApplication&amp;quot;,
  &amp;quot;Resources&amp;quot;: {
    &amp;quot;SESMessageStoreBucketa622fdfda5789d596c08c79124f12b978b3da772&amp;quot;: {
      &amp;quot;ResourceID&amp;quot;: &amp;quot;SESMessageStoreBucketa622fdfda5789d596c08c79124f12b978b3da772&amp;quot;,
      &amp;quot;Properties&amp;quot;: {
        &amp;quot;DomainName&amp;quot;: &amp;quot;spartaapplication-sesmessagestorebucketa622fdfda5-1ide79vkwrklp.s3.amazonaws.com&amp;quot;,
        &amp;quot;Ref&amp;quot;: &amp;quot;spartaapplication-sesmessagestorebucketa622fdfda5-1ide79vkwrklp&amp;quot;,
        &amp;quot;WebsiteURL&amp;quot;: &amp;quot;http://spartaapplication-sesmessagestorebucketa622fdfda5-1ide79vkwrklp.s3-website-us-west-2.amazonaws.com&amp;quot;,
        &amp;quot;sparta:cloudformation:restype&amp;quot;: &amp;quot;AWS::S3::Bucket&amp;quot;
      },
      &amp;quot;Tags&amp;quot;: {
        &amp;quot;sparta:logicalBucketName&amp;quot;: &amp;quot;Special&amp;quot;
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;Resources&lt;/code&gt; map has an entry for the S3 bucket.  Our code just needs to root around a bit to find the &lt;a href=&#34;http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket.html&#34;&gt;Ref&lt;/a&gt; property which is the immediate dependencies bucket name output.  If there were multiple resources, we could have disambiguated by also filtering for the &lt;em&gt;Special&lt;/em&gt; tag, which is the logical name we provided earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sesPermission.NewMessageBodyStorageResource(&amp;quot;Special&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we only have a single dependency, our discovery filter is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// The message bucket is an explicit `DependsOn` relationship, so it&#39;ll be in the
// resources map.  We&#39;ll find it by looking for the dependent resource with the &amp;quot;AWS::S3::Bucket&amp;quot; type
bucketName := &amp;quot;&amp;quot;
for _, eachResource := range configuration.Resources {
  if eachResource.Properties[sparta.TagResourceType] == &amp;quot;AWS::S3::Bucket&amp;quot; {
    bucketName = eachResource.Properties[&amp;quot;Ref&amp;quot;]
  }
}
if &amp;quot;&amp;quot; == bucketName {
  logger.Error(&amp;quot;Failed to discover SES bucket from sparta.Discovery&amp;quot;)
  http.Error(w, &amp;quot;Failed to discovery SES MessageBodyBucket&amp;quot;, http.StatusInternalServerError)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sparta-integration&#34;&gt;Sparta Integration&lt;/h1&gt;

&lt;p&gt;The rest of &lt;code&gt;echoSESEvent&lt;/code&gt; satisfies the other requirements, with a bit of help from the SES &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta/aws/ses&#34;&gt;event types&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var lambdaEvent spartaSES.Event
err := json.Unmarshal([]byte(*event), &amp;amp;lambdaEvent)
if err != nil {
  logger.Error(&amp;quot;Failed to unmarshal event data: &amp;quot;, err.Error())
  http.Error(w, err.Error(), http.StatusInternalServerError)
}

// Get the metdata about the item...
svc := s3.New(session.New())
for _, eachRecord := range lambdaEvent.Records {
  logger.WithFields(logrus.Fields{
    &amp;quot;Source&amp;quot;:     eachRecord.SES.Mail.Source,
    &amp;quot;MessageID&amp;quot;:  eachRecord.SES.Mail.MessageID,
    &amp;quot;BucketName&amp;quot;: bucketName,
  }).Info(&amp;quot;SES Event&amp;quot;)

  params := &amp;amp;s3.HeadObjectInput{
    Bucket: aws.String(bucketName),
    Key:    aws.String(eachRecord.SES.Mail.MessageID),
  }
  resp, err := svc.HeadObject(params)
  logger.WithFields(logrus.Fields{
    &amp;quot;Error&amp;quot;:    err,
    &amp;quot;Metadata&amp;quot;: resp,
  }).Info(&amp;quot;SES MessageBody&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;With the &lt;code&gt;lambdaFn&lt;/code&gt; fully defined, we can provide it to &lt;code&gt;sparta.Main()&lt;/code&gt; and deploy our service.  The workflow below is shared by all SES-triggered lambda function:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define the lambda function (&lt;code&gt;echoSESEvent&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If needed, create the required &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta*IAMRoleDefinition&#34;&gt;IAMRoleDefinition&lt;/a&gt; with appropriate privileges if the lambda function accesses other AWS services.&lt;/li&gt;
&lt;li&gt;Provide the lambda function &amp;amp; IAMRoleDefinition to &lt;code&gt;sparta.NewLambda()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add the necessary &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;Permissions&lt;/a&gt; to the &lt;code&gt;LambdaAWSInfo&lt;/code&gt; struct so that the lambda function is triggered.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Additionally, if the SES handler needs to access the raw email message body:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Create a new &lt;code&gt;sesPermission.NewMessageBodyStorageResource(&amp;quot;Special&amp;quot;)&lt;/code&gt; value to store the message body&lt;/li&gt;
&lt;li&gt;Assign the value to the &lt;code&gt;sesPermission.MessageBodyStorage&lt;/code&gt; field&lt;/li&gt;
&lt;li&gt;If your lambda function needs to consume the message body, add an entry to &lt;code&gt;sesPermission.[]IAMPrivilege&lt;/code&gt; that includes the &lt;code&gt;sesPermission.MessageBodyStorage.BucketArnAllKeys()&lt;/code&gt; Arn&lt;/li&gt;
&lt;li&gt;In your &lt;strong&gt;Go&lt;/strong&gt; lambda function definition, discover the S3 bucketname via &lt;code&gt;sparta.Discover()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;notes&#34;&gt;Notes&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;The SES message (including headers) is stored in the &lt;a href=&#34;http://stackoverflow.com/questions/33549327/what-is-the-format-of-the-aws-ses-body-stored-in-s3&#34;&gt;raw format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sparta.Discover()&lt;/code&gt; uses &lt;a href=&#34;https://golang.org/pkg/reflect/&#34;&gt;reflection&lt;/a&gt; to map from the current enclosing &lt;strong&gt;Go&lt;/strong&gt; function name to the owning &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;LambdaAWSInfo&lt;/a&gt; CloudFormation. Therefore, calling &lt;code&gt;sparta.Discover()&lt;/code&gt; from non-Sparta lambda functions (application helpers, function literals) will generate an error.&lt;/li&gt;
&lt;li&gt;More on Immutable Infrastructure:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.subbu.org/blog/2014/10/automate-everything-but-dont-ignore-drift&#34;&gt;Subbu - Automate Everything&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chadfowler.com/2013/06/23/immutable-deployments.html&#34;&gt;Chad Fowler - Immutable Deployments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.thecloudcast.net/2015/09/the-cloudcast-213-what-is-immutable.html&#34;&gt;The Cloudcast - What is Immutable Infrastructure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://thenewstack.io/a-brief-look-at-immutable-infrastructure-and-why-it-is-such-a-quest/&#34;&gt;The New Stack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Event Source - SNS</title>
      <link>http://gosparta.io/docs/eventsources/sns/</link>
      <pubDate>Sun, 29 Nov 2015 06:50:17 +0000</pubDate>
      <author>mweagle@gmail.com (Matt Weagle)</author>
      <guid>http://gosparta.io/docs/eventsources/sns/</guid>
      <description>

&lt;p&gt;In this section we&amp;rsquo;ll walkthrough how to trigger your lambda function in response to SNS events.  This overview is based on the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go#L79&#34;&gt;SpartaApplication&lt;/a&gt; sample code if you&amp;rsquo;d rather jump to the end result.&lt;/p&gt;

&lt;h1 id=&#34;goal&#34;&gt;Goal&lt;/h1&gt;

&lt;p&gt;Assume that we have an SNS topic that broadcasts notifications.  We&amp;rsquo;ve been asked to write a lambda function that logs the &lt;em&gt;Subject&lt;/em&gt; and &lt;em&gt;Message&lt;/em&gt; text to CloudWatch logs for later processing.&lt;/p&gt;

&lt;h1 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h1&gt;

&lt;p&gt;We&amp;rsquo;ll start with an empty lambda function and build up the needed functionality.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;func echoSNSEvent(event *json.RawMessage,
                  context *sparta.LambdaContext,
                  w http.ResponseWriter,
                  logger *logrus.Logger)
{
  logger.WithFields(logrus.Fields{
    &amp;#34;RequestID&amp;#34;: context.AWSRequestID,
  }).Info(&amp;#34;Request received&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;unmarshalling-the-sns-event&#34;&gt;Unmarshalling the SNS Event&lt;/h1&gt;

&lt;p&gt;Since the &lt;code&gt;echoSNSEvent&lt;/code&gt; is expected to be triggered by SNS notifications, we will unmarshal the &lt;code&gt;*json.RawMessage&lt;/code&gt; data into an SNS-specific event provided by Sparta via:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;var lambdaEvent spartaSNS.Event
err := json.Unmarshal([]byte(*event), &amp;amp;lambdaEvent)
if err != nil {
  logger.Error(&amp;#34;Failed to unmarshal event data: &amp;#34;, err.Error())
  http.Error(w, err.Error(), http.StatusInternalServerError)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;SNS events are delivered in batches, via lists of &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta/aws/sns#EventRecord&#34;&gt;EventRecords&lt;/a&gt;, so we&amp;rsquo;ll need to process each record.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;for _, eachRecord := range lambdaEvent.Records {
  logger.WithFields(logrus.Fields{
    &amp;#34;Subject&amp;#34;: eachRecord.Sns.Subject,
    &amp;#34;Message&amp;#34;: eachRecord.Sns.Message,
  }).Info(&amp;#34;SNS Event&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;That&amp;rsquo;s enough to get the data into CloudWatch Logs.&lt;/p&gt;

&lt;h1 id=&#34;sparta-integration&#34;&gt;Sparta Integration&lt;/h1&gt;

&lt;p&gt;With the core of the &lt;code&gt;echoSNSEvent&lt;/code&gt; complete, the next step is to integrate the &lt;strong&gt;Go&lt;/strong&gt; function with Sparta.  This is performed by the &lt;a href=&#34;https://github.com/mweagle/SpartaApplication/blob/master/application.go#L79&#34;&gt;appendSNSLambda&lt;/a&gt; function.  Since the &lt;code&gt;echoSNSEvent&lt;/code&gt; function doesn&amp;rsquo;t access any additional services (Sparta enables CloudWatch Logs privileges by default), the integration is pretty straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn = sparta.NewLambda(sparta.IAMRoleDefinition{}, echoSNSEvent, nil)&lt;/code&gt;&lt;/pre&gt;


&lt;h1 id=&#34;event-source-registration&#34;&gt;Event Source Registration&lt;/h1&gt;

&lt;p&gt;If we were to deploy this Sparta application, the &lt;code&gt;echoSNSEvent&lt;/code&gt; function would have the ability to log SNS events, but would not be invoked in response to messages published to that topic.  To register for notifications, we need to configure the lambda&amp;rsquo;s &lt;a href=&#34;http://docs.aws.amazon.com/lambda/latest/dg/intro-permission-model.html&#34;&gt;Permissions&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;go&#34;&gt;lambdaFn.Permissions = append(lambdaFn.Permissions, sparta.SNSPermission{
  BasePermission: sparta.BasePermission{
    SourceArn: snsTopic,
  },
})
lambdaFunctions = append(lambdaFunctions, lambdaFn)&lt;/code&gt;&lt;/pre&gt;


&lt;p&gt;The &lt;code&gt;snsTopic&lt;/code&gt; param is the ARN of the SNS topic that will notify your lambda function (eg: _arn:aws:sns:us-west-2:000000000000:myTopicName).&lt;/p&gt;

&lt;p&gt;See the &lt;a href=&#34;http://gosparta.io/docs/eventsources/s3/#eventSourceRegistration&#34;&gt;S3 docs&lt;/a&gt; for more information on how the &lt;em&gt;Permissions&lt;/em&gt; data is processed.&lt;/p&gt;

&lt;h1 id=&#34;wrapping-up&#34;&gt;Wrapping Up&lt;/h1&gt;

&lt;p&gt;With the &lt;code&gt;lambdaFn&lt;/code&gt; fully defined, we can provide it to &lt;code&gt;sparta.Main()&lt;/code&gt; and deploy our service.  The workflow below is shared by all SNS-triggered lambda function:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Define the lambda function (&lt;code&gt;echoSNSEvent&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If needed, create the required &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta*IAMRoleDefinition&#34;&gt;IAMRoleDefinition&lt;/a&gt; with appropriate privileges if the lambda function accesses other AWS services.&lt;/li&gt;
&lt;li&gt;Provide the lambda function &amp;amp; IAMRoleDefinition to &lt;code&gt;sparta.NewLambda()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Add the necessary &lt;a href=&#34;https://godoc.org/github.com/mweagle/Sparta#LambdaAWSInfo&#34;&gt;Permissions&lt;/a&gt; to the &lt;code&gt;LambdaAWSInfo&lt;/code&gt; struct so that the lambda function is triggered.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;other-resources&#34;&gt;Other Resources&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;TBD&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>