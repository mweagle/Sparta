---
date: 2016-03-09T19:56:50+01:00
title: Details
weight: 20
---

The [Overview](/sample_service/step1/) walked through a simple "Hello World" example. In this section we'll cover how Sparta works in preparation for moving on to more advanced use. Most development will use the `provision` command line argument, so this section will outline exactly what that entails.

## Provisioning Flow

The provisioning workflow is defined in [provision.go](https://github.com/mweagle/Sparta/blob/master/provision.go), with a goal of marshalling all AWS operations into a [CloudFormation](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html) template. Where CloudFormation does not support a given service, Sparta falls back to using [Lambda-backed Custom Resources](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources-lambda.html) in the template definition.

At a high level, provisioning uses the flow below. We'll dive a bit deeper into each stage in the following sections.

{{< spartaflow >}}

### Verify Static IAM Roles

The `NewAWSLambda` function accepts either a `string` or a `sparta.IAMRoleDefinition` value type. In the event that a string is passed, this function verifies that the IAM role exists and builds up a cache of IAM role information that can be shared and referenced during template generation. Specifically, a pre-existing [IAM Role ARN](http://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns) is cached to minimize AWS calls during template generation.

### Compile

The next step is to cross compile the application to a binary that can be executed on an AWS Lambda instance. The default compile flags are:

- **TAGS**: `-tags lambdabinary`
- **ENVIRONMENT**: `GOOS=linux GOARCH=amd64`

The build output is created in the \_./.sparta/ working directory. The full set of build flags is available by running the provision workflow with the `--level debug` option.

### Package

The end result of the package phase is a ZIP archive of your application. You can inspect this archive, as well as any other Sparta artifacts in the _./.sparta_ directory by supplying the `--noop` argument during a provision operation.

### Upload Archive To S3

Uploads the archive to S3. There's not much else to see here.

### Generate CloudFormation Template

Uploading the archive produces a valid [CodeURI](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html#cfn-lambda-function-code) value that can be used for Lambda function creation. The CloudFormation template is generated by marshaling the `sparta.LambdaAWSInfo` objects into CloudFormation JSON representations.

The AWS Lambda marshaling is automatically handled. This is also the point at which the optional [TemplateDecorator](https://godoc.org/github.com/mweagle/Sparta#TemplateDecorator) functions are called to annocate the automatically generated template with additional resources.

### Upload CloudFormation Template to S3

Uploads the template to S3 to maximize [template size](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html). There's not much else to see here.

### Create/Update Stack

Finally, the provisioning workflow determines whether the Sparta `serviceName` exists and either creates or updates as appropriate using CloudFormation APIs.

## Next Steps

Now that we've covered how Sparta handles provisioning your stack, we're ready to expand functionality to leverge more of the AWS ecosystem in the [next section](/reference/eventsources/).
